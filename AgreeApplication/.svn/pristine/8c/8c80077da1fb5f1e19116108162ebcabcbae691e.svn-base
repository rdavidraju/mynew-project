package com.nspl.app.web.rest;

import com.codahale.metrics.annotation.Timed;
import com.nspl.app.domain.ApplicationPrograms;
import com.nspl.app.domain.DataViews;
import com.nspl.app.domain.LookUpCode;
import com.nspl.app.domain.ReportDefination;
import com.nspl.app.domain.ReportParameters;
import com.nspl.app.domain.ReportRequests;
import com.nspl.app.domain.ReportType;
import com.nspl.app.domain.Reports;
import com.nspl.app.domain.TenantConfig;
import com.nspl.app.repository.ApplicationProgramsRepository;
import com.nspl.app.repository.DataViewsColumnsRepository;
import com.nspl.app.repository.DataViewsRepository;
import com.nspl.app.repository.FavouriteReportsRepository;
import com.nspl.app.repository.FileTemplateLinesRepository;
import com.nspl.app.repository.LookUpCodeRepository;
import com.nspl.app.repository.ReportDefinationRepository;
import com.nspl.app.repository.ReportParametersRepository;
import com.nspl.app.repository.ReportRequestsRepository;
import com.nspl.app.repository.ReportTypeRepository;
import com.nspl.app.repository.ReportsRepository;
import com.nspl.app.repository.TenantConfigRepository;
import com.nspl.app.service.DataViewsService;
import com.nspl.app.service.FileExportService;
import com.nspl.app.service.FileService;
import com.nspl.app.service.PropertiesUtilService;
import com.nspl.app.service.ReportsService;
import com.nspl.app.service.SFTPUtilService;
import com.nspl.app.service.UserJdbcService;
import com.nspl.app.web.rest.util.HeaderUtil;
import com.nspl.app.web.rest.util.PaginationUtil;

import io.swagger.annotations.ApiParam;
import io.github.jhipster.web.util.ResponseUtil;

import org.apache.commons.collections4.MapUtils;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVPrinter;
import org.apache.spark.SparkConf;
import org.apache.spark.api.java.JavaSparkContext;
import org.apache.spark.sql.AnalysisException;
import org.apache.spark.sql.Column;
import org.apache.spark.sql.DataFrameReader;
import org.apache.spark.sql.Dataset;
import org.apache.spark.sql.RelationalGroupedDataset;
import org.apache.spark.sql.Row;
import org.apache.spark.sql.SQLContext;
import org.dom4j.DocumentException;
import org.joda.time.LocalDate;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;
import org.json.JSONException;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.env.Environment;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.FileSystem;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.math.BigInteger;
import java.net.URI;
import java.net.URISyntaxException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.sql.SQLException;
import java.text.SimpleDateFormat;
import java.time.Month;
import java.time.ZonedDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Properties;
import java.util.Set;
import java.util.TreeMap;
import java.util.stream.Collectors;

import javax.activation.DataHandler;
import javax.activation.DataSource;
import javax.activation.FileDataSource;
import javax.inject.Inject;
import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.Multipart;
import javax.mail.PasswordAuthentication;
import javax.mail.Session;
import javax.mail.Transport;
import javax.mail.internet.AddressException;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeBodyPart;
import javax.mail.internet.MimeMessage;
import javax.mail.internet.MimeMultipart;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.hadoop.fs.Path;


/**
 * REST controller for managing Reports.
 */
@RestController
@RequestMapping("/api")
public class ReportsResource {

    private final Logger log = LoggerFactory.getLogger(ReportsResource.class);

    private static final String ENTITY_NAME = "reports";
    
    private final ReportsRepository reportsRepository;
    
    private final FavouriteReportsRepository favouriteReportsRepository;
    
    @Inject
    ReportDefinationRepository reportDefinationRepository;
    
    @Inject
    DataViewsRepository dataViewsRepository;
    
    @Inject
    PropertiesUtilService propertiesUtilService;
    
    @Inject
    DataViewsService dataViewsService;
    
    @Inject
    FileTemplateLinesRepository fileTemplateLinesRepository;
    
    @Inject
    DataViewsColumnsRepository dataViewsColumnsRepository;
    
    @Inject
    ReportParametersRepository reportParametersRepository;

    @Inject
    ReportTypeRepository reportTypeRepository;
    
    @Inject
    LookUpCodeRepository lookUpCodeRepository;
    
    @Inject
    private Environment env;
    
    @Inject
    ReportsService reportsService;
    
    @Inject
	SFTPUtilService sftpService;
    
    @Autowired
	org.apache.hadoop.conf.Configuration hadoopConfiguration;
    
    @Autowired
    ApplicationProgramsRepository applicationProgramsRepository;
    
    @Inject
    ReportRequestsRepository reportRequestsRepository;
    
    @Inject
    UserJdbcService userJdbcService;
    
    
    @Inject
    FileService fileService;
    
    @Inject
    FileExportService fileExportService;
    
    
    @Inject
    TenantConfigRepository tenantConfigRepository;
    
    public ReportsResource(ReportsRepository reportsRepository,FavouriteReportsRepository favouriteReportsRepository) {
        this.reportsRepository = reportsRepository;
        this.favouriteReportsRepository = favouriteReportsRepository;
    }

    /**
     * POST  /reports : Create a new reports.
     *
     * @param reports the reports to create
     * @return the ResponseEntity with status 201 (Created) and with body the new reports, or with status 400 (Bad Request) if the reports has already an ID
     * @throws URISyntaxException if the Location URI syntax is incorrect
     */
    @PostMapping("/reports")
    @Timed
    public ResponseEntity<Reports> createReports(@RequestBody Reports reports) throws URISyntaxException {
        log.debug("REST request to save Reports : {}", reports);
        if (reports.getId() != null) {
            return ResponseEntity.badRequest().headers(HeaderUtil.createFailureAlert(ENTITY_NAME, "idexists", "A new reports cannot already have an ID")).body(null);
        }
        Reports result = reportsRepository.save(reports);
        return ResponseEntity.created(new URI("/api/reports/" + result.getId()))
            .headers(HeaderUtil.createEntityCreationAlert(ENTITY_NAME, result.getId().toString()))
            .body(result);
    }

    /**
     * PUT  /reports : Updates an existing reports.
     *
     * @param reports the reports to update
     * @return the ResponseEntity with status 200 (OK) and with body the updated reports,
     * or with status 400 (Bad Request) if the reports is not valid,
     * or with status 500 (Internal Server Error) if the reports couldn't be updated
     * @throws URISyntaxException if the Location URI syntax is incorrect
     */
    @PutMapping("/reports")
    @Timed
    public ResponseEntity<Reports> updateReports(@RequestBody Reports reports) throws URISyntaxException {
        log.debug("REST request to update Reports : {}", reports);
        if (reports.getId() == null) {
            return createReports(reports);
        }
        Reports result = reportsRepository.save(reports);
        return ResponseEntity.ok()
            .headers(HeaderUtil.createEntityUpdateAlert(ENTITY_NAME, reports.getId().toString()))
            .body(result);
    }

    /**
     * GET  /reports : get all the reports.
     *
     * @param pageable the pagination information
     * @return the ResponseEntity with status 200 (OK) and the list of reports in body
     */
    @GetMapping("/reports")
    @Timed
    public ResponseEntity<List<Reports>> getAllReports(@ApiParam Pageable pageable) {
        log.debug("REST request to get a page of Reports");
        Page<Reports> page = reportsRepository.findAll(pageable);
        HttpHeaders headers = PaginationUtil.generatePaginationHttpHeaders(page, "/api/reports");
        return new ResponseEntity<>(page.getContent(), headers, HttpStatus.OK);
    }

    /**
     * GET  /reports/:id : get the "id" reports.
     *
     * @param id the id of the reports to retrieve
     * @return the ResponseEntity with status 200 (OK) and with body the reports, or with status 404 (Not Found)
     */
    @GetMapping("/reports/{id}")
    @Timed
    public ResponseEntity<Reports> getReports(@PathVariable String id, HttpServletRequest request) {
        log.debug("REST request to get Reports : {}", id);
        HashMap map1=userJdbcService.getuserInfoFromToken(request);
    	Long tenantId=Long.parseLong(map1.get("tenantId").toString());
        Reports reports = reportsRepository.findByTenantIdAndIdForDisplay(tenantId, id);
        return ResponseUtil.wrapOrNotFound(Optional.ofNullable(reports));
    }

    /**
     * DELETE  /reports/:id : delete the "id" reports.
     *
     * @param id the id of the reports to delete
     * @return the ResponseEntity with status 200 (OK)
     */
    @DeleteMapping("/reports/{id}")
    @Timed
    public ResponseEntity<Void> deleteReports(@PathVariable Long id) {
        log.debug("REST request to delete Reports : {}", id);
        reportsRepository.delete(id);
        return ResponseEntity.ok().headers(HeaderUtil.createEntityDeletionAlert(ENTITY_NAME, id.toString())).build();
    }
    
    /**
     * Author: Swetha
     * GET: /getReportsByTenant - Api to fetch list of Reports tagged for a Tenant
     * @param tenantId
     * @return
     * @throws URISyntaxException 
     * @throws SQLException 
     * @throws ClassNotFoundException 
     */
    /**Added condition for datetime while sorting**/
    
    @GetMapping("/getReportsByTenant")
   @Timed	
   public List<JSONObject>  getReportsByTenant(HttpServletRequest request,HttpServletResponse response,@RequestParam(value = "page" , required = false) Integer pageNumber,
			@RequestParam(value = "per_page", required = false) Integer pageSize, @RequestParam(required=false) String reportType,
			@RequestParam(required = false) String sortDirection,@RequestParam(required = false) String sortCol,
			@RequestParam(required = false) Boolean favRpts,@RequestParam(required = false) Boolean recentRpts, @RequestParam(required = false) String searchKeyword) 
					throws URISyntaxException, ClassNotFoundException, SQLException, ParseException{
    	
    	HashMap map1=userJdbcService.getuserInfoFromToken(request);
    	Long tenantId=Long.parseLong(map1.get("tenantId").toString());
    	Long userId=Long.parseLong(map1.get("userId").toString());
    	log.debug("REST request to getReportsByTenant by tenantId: "+tenantId+"reportType: "+reportType+"sortCol: "+sortCol+"favList: "+favRpts+"recentRpts: "+recentRpts);
    	//return object
    	List<JSONObject> repDtoList=new ArrayList<JSONObject>();
    	HashMap<Long, ReportType> reportTypeList=reportsService.getReportTypes(tenantId);
    	HashMap<Long, String> reportTypeNameList=reportsService.getReportTypesLivy(tenantId);
    	HashMap<String,Long> reportTypeRevList=(HashMap<String, Long>) MapUtils.invertMap(reportTypeNameList);
    	Long reportTypeId=reportTypeRevList.get(reportType);
    	log.info("reportTypeId: "+reportTypeId);
    	List<BigInteger> reportIdList=new ArrayList<BigInteger>();
    	List<Long> reportIdLongList=new ArrayList<Long>();
    	if(sortDirection==null)
    		sortDirection="Descending";
    	if(sortCol==null || sortCol.isEmpty() || sortCol.length()<1)
    		sortCol="Id";

    	if(reportTypeId!=null){
    		reportIdList=reportsRepository.fectchActiveReportsByTenantIdAndReportTypeId(tenantId,reportTypeId);
    	}
    	else{
    		reportIdList=reportsRepository.fectchActiveReportsByTenantId(tenantId);
    	}
    	
    	// ********* To filter favourite reports only		Update by @Rk
    	List<BigInteger> favRptIdsList = favouriteReportsRepository.fectchCurrentUserFavouriteReportIds(userId,tenantId);
    	if(favRpts){
    		for(int i=0;i<reportIdList.size();i++){
    			BigInteger id=reportIdList.get(i);
    			if(favRptIdsList.contains(id)){
    				reportIdLongList.add(id.longValue());
    			}
    		}
    	}else if(recentRpts){
			List<BigInteger> recentRequests=reportRequestsRepository.fectchCurrentUserRecentRanReportIds(userId,tenantId);
			for(int i=0;i<recentRequests.size();i++){
				BigInteger id=recentRequests.get(i);
				if(reportIdList.contains(id)){
    				reportIdLongList.add(id.longValue());
    			}
			}
		}
    	else{
    		for(int i=0;i<reportIdList.size();i++)
        		reportIdLongList.add(reportIdList.get(i).longValue());
    	}
    	// ***** END OF UPDATE **********
    	int totReportsCnt=reportIdLongList.size();
    	log.info("totReportsCnt: "+totReportsCnt);
    	
    	/*int totReportsCnt=reportIdLongList.size();
    	int limit = 0;
    	if(pageNumber == null || pageNumber == 0)
    	{
    		pageNumber = 0;
    	}
    	if(pageSize == null || pageSize == 0)
    	{
    		pageSize = totReportsCnt;
    	}
    	limit = ((pageNumber+1) * pageSize + 1)-1;
    	int startIndex=pageNumber*pageSize; 

    	if(limit>totReportsCnt){
    		limit=totReportsCnt;
    	}

    	log.info("Limit Starting Values : "+ limit);
    	log.info("Page Number : "+ pageNumber);
    	log.info("***********startIndex: "+startIndex);*/
    	
    	log.info("reportIdLongList: "+reportIdLongList);
    	log.info("pageNumber: "+pageNumber+" pageSize: "+pageSize+" sortDirection: "+sortDirection+" sortCol: "+sortCol);
    	if(reportIdLongList.size()>0)
    	{
    		Page<Reports> reportsList=reportsRepository.findByTenantIdAndIdIn(tenantId, reportIdLongList, PaginationUtil.generatePageRequestWithSortColumn(pageNumber+1, pageSize,sortDirection,sortCol));
    		//Page<Reports> reportsList=reportsRepository.findByTenantIdAndIdIn(tenantId, reportIdLongList, PaginationUtil.generatePageRequest2(pageNumber+1, pageSize));
    		log.info("reportsList :"+reportsList);
    		List<LinkedHashMap> maps = new ArrayList<LinkedHashMap>();


    		Iterator itr=reportsList.iterator();
    		while(itr.hasNext()){
    			Reports reports= (Reports) itr.next();
    			LinkedHashMap reportsDto=new LinkedHashMap();



    			reportsDto.put("id",reports.getIdForDisplay());
    			reportsDto.put("accVal",reports.getAccVal());
    			if(reports.getAllowDrillDown()!=null)
    				reportsDto.put("allowDrillDown",reports.getAllowDrillDown().toString());
    			else
    				reportsDto.put("allowDrillDown",null);
    			if(reports.getCreatedBy()!=null)
    				reportsDto.put("createdBy",reports.getCreatedBy().toString());
    			else
    				reportsDto.put("createdBy","");
    			if(reports.getCreationDate()!=null)
    				reportsDto.put("creationDate",reports.getCreationDate());
    			else
    				reportsDto.put("creationDate",null);
    			reportsDto.put("description",reports.getDescription());
    			if(reports.isEnableFlag()!=null)
    				reportsDto.put("enableFlag",reports.isEnableFlag().toString());
    			else
    				reportsDto.put("enableFlag",null);
    			if(reports.getEndDate()!=null)
    				reportsDto.put("endDate",reports.getEndDate().toString());
    			else
    				reportsDto.put("endDate",null);
    			if(reports.getLastUpdatedBy()!=null)
    				reportsDto.put("lastUpdatedBy",reports.getLastUpdatedBy().toString());
    			else
    				reportsDto.put("lastUpdatedBy",null);
    			if(reports.getLastUpdatedDate()!=null)
    				reportsDto.put("lastUpdatedDate",reports.getLastUpdatedDate());
    			else
    				reportsDto.put("lastUpdatedDate",null);
    			reportsDto.put("recVal",reports.getRecVal());
    			reportsDto.put("reportMode",reports.getReportMode());
    			reportsDto.put("reportName",reports.getReportName());
    			Long repTypeId=reports.getReportTypeId();
    			ReportType repType=reportTypeList.get(repTypeId);
    			if(repTypeId!=null)
    				reportsDto.put("reportTypeId",repTypeId.toString());
    			else
    				reportsDto.put("reportTypeId",null);
    			if(repType!=null){
    				reportsDto.put("reportTypeCode",repType.getType());
    				reportsDto.put("reportTypeName",repType.getDisplayName());
    			}
    			reportsDto.put("reportVal01",reports.getReportVal01());
    			reportsDto.put("reportVal02",reports.getReportVal02());
    			reportsDto.put("reportViewType",reports.getReportViewType());
    			if(reports.getSourceViewId()!=null)
    				reportsDto.put("sourceViewId",reports.getSourceViewId().toString());
    			else
    				reportsDto.put("sourceViewId",null);
    			if(reports.getStartDate()!=null)
    				reportsDto.put("startDate",reports.getStartDate().toString());
    			else
    				reportsDto.put("startDate",null);
    			if(reports.getTenantId()!=null)
    				reportsDto.put("tenantId",reports.getTenantId().toString());
    			else
    				reportsDto.put("tenantId",null);
    			if(favRptIdsList.contains(new BigInteger(reports.getId().toString())))
    				reportsDto.put("isFavourite",true);
    			else
    				reportsDto.put("isFavourite",false);
    			
    			//Adding first parameter info
    			List<ReportParameters> repParamsList=reportParametersRepository.findByReportId(reports.getId());
    			String firstParam=repParamsList.get(0).getDisplayName();
    			reportsDto.put("firstParam", firstParam+"...");
    			
    			
    			//Added Request Information
    			List<ReportRequests> repRequests=reportRequestsRepository.findByReportIdAndStatusOrderByGeneratedTimeDesc(reports.getId(), "SUCCEEDED");
    			if(repRequests!=null && repRequests.size()>0){
    				ReportRequests req=repRequests.get(0);
    				reportsDto.put("requestId",req.getIdForDisplay());
    				reportsDto.put("requestName",req.getReqName());
    				reportsDto.put("lastRun",req.getGeneratedTime());
    				HashMap map=new HashMap();
    				if(req.getCreatedBy()!=null)
    					map=userJdbcService.getUserInfo(req.getCreatedBy(),tenantId);
    				if(map!=null){
    					if(map.containsKey("assigneeName")){
    						if(map.get("assigneeName")!=null && !(map.get("assigneeName").toString().isEmpty()))
    					reportsDto.put("lastRunBy",map.get("assigneeName").toString());
    					}
    				}
    			}
    			JSONObject jsonValue =new JSONObject();
    			JSONObject obj=new JSONObject();
    			obj.putAll(reportsDto);

    			repDtoList.add(obj);
    		}
    	}
    	
    	
    	//Search Functionality
    	List<JSONObject> searchFilteredObjList=new ArrayList<JSONObject>();
    	if(searchKeyword!=null){
    	/*Set keyset=repDtoList.get(0).keySet();
    	log.info("keyset: "+keyset);
    	Iterator entries = repDtoList.get(0).entrySet().iterator();*/
    	List<String> keyList=new ArrayList<String>();
    	/*while (entries.hasNext()) {
		    Map.Entry entry = (Map.Entry) entries.next();
		    String key = (String)entry.getKey();
		    String value = (String)entry.getValue();
		    System.out.println("key = " + key + ", value = " + value);
		    keyList.add(key);
    	}*/
    	keyList.add("reportName");
    	keyList.add("lastRunBy");
    	keyList.add("createdBy");
    	keyList.add("reportTypeName");
    	keyList.add("description");
    	
    	for (int i = 0; i < repDtoList.size(); i++) {
    		
			for (String  keys:keyList)
    		{
				//log.info("keys: "+keys);
				//log.info("repDtoList.get(i): "+repDtoList.get(i));
				if(repDtoList.get(i).get(keys)!=null)
				if(repDtoList.get(i).get(keys).toString().toLowerCase().contains(searchKeyword.toLowerCase())){
					searchFilteredObjList.add(repDtoList.get(i));
					break;
				}
    		}
    	
    	}
    	}
    	else{
    		searchFilteredObjList=repDtoList;
    	}

    	//log.info("repDtoList :"+repDtoList);
    	String sortColumn=sortCol;
    	String sortDir=sortDirection;
    	if(sortColumn.equalsIgnoreCase("lastRun"))
    	{
    		Collections.sort(searchFilteredObjList, new Comparator<JSONObject>() {
    			  public int compare(JSONObject a, JSONObject b) {
    				if (a.get("lastRun") == null || b.get("lastRun") == null)
    				        return 0;
    			  
    				  ZonedDateTime aDate=ZonedDateTime.parse(a.get("lastRun").toString());
    				  ZonedDateTime bDate=ZonedDateTime.parse(b.get("lastRun").toString());
    				  
    			      return aDate.compareTo(bDate);
    			  }
    			});
    	}
    	else if(!sortColumn.equalsIgnoreCase("lastRun"))
    	{
    	Collections.sort( searchFilteredObjList, new Comparator<JSONObject>() { 


    		@Override
    		public int compare(JSONObject a, JSONObject b) {
    			String valA = new String();
    			String valB = new String();

    			valA = (String) a.get(sortColumn);
    			valB = (String) b.get(sortColumn);
    			if(valA!=null && valB!=null)
    				return 0;
    			if (valA == null)
    				return 1;
    			else if (valB == null)
    				return -1;
    			if(sortDir!=null && sortDir.equalsIgnoreCase("ascending"))
    				return valA.compareTo(valB);
    			else
    				return -valA.compareTo(valB);



    		}
    	});
    	}
    	response.addIntHeader("X-COUNT", totReportsCnt);


log.info("***end of API**** "+ZonedDateTime.now());
    	return searchFilteredObjList;

    }
    
    
    /**
     * Author: Swetha
     * Api to validate duplication of ReportName
     * @param tenantId
     * @param reportName
     * @return
     */
    @GetMapping("/validateReportName")
    @Timed
    public Long validateReportName(HttpServletRequest request,@RequestParam String reportName){
    	
    	HashMap map=userJdbcService.getuserInfoFromToken(request);
      	Long tenantId=Long.parseLong(map.get("tenantId").toString());
    	log.info("Rest Request to validateReportName with tenantId: "+tenantId+" and reportName: "+reportName);
    	Long result=0l;
    	Long count=reportsRepository.fetchReportNameCount(tenantId, reportName);
    	log.info("count of reportName: "+reportName+" is: "+count);
    	if(count>1){
    		
    	}
    	else if(count==1){
    		Reports reports=reportsRepository.findByTenantIdAndReportName(tenantId, reportName);
    		result=reports.getId();
    	}
		return result;
    }
    
   
    
    
    /**
     * author :ravali
     * @param email
     * @param filePath
     * @param tenantId
     * @throws AddressException
     * @throws MessagingException
     * @throws IOException
     * @throws DocumentException
     * @throws URISyntaxException
     * @throws ParseException
     * Desc :sharing csv through mail
     */
    @GetMapping("/shareReportingCSVBKP/{email:.+}")
    @Timed
    public void shareReportingCSVBKP(@RequestParam String email,@RequestParam String filePath,@RequestParam Long tenantId) 
    		throws AddressException, MessagingException, IOException, DocumentException, URISyntaxException, ParseException
    {
    	log.info("REST API FOR SHARING SampleCSV");
    	log.info("email :"+email);


    	ApplicationPrograms prog=applicationProgramsRepository.findByPrgmNameAndTenantIdAndEnableIsTrue("Reporting",tenantId);
    	String localPath=prog.getGeneratedPath();
    	log.info("localPath :"+localPath);
    	String finalPath=hadoopConfiguration.get("fs.defaultFS")+filePath;
    	log.info("filePath :"+finalPath);

    	Configuration configuration = new Configuration();
    	URI uri = new URI(finalPath); //hdfs://192.168.0.155:9000/user/hdsingle/examples/apps/dev/reporting/report_parameters/Params_9_2018-01-25_12-28-21.834072.json
    	FileSystem hdfs = FileSystem.get(uri, configuration);
    	log.info("hdfs :"+hdfs);
    	InputStream inputStream = null;
    	//Connecting to remote server

    	Path path = new Path(uri);
    	log.info("path :"+path);
    	if (hdfs.exists(path)) {
    		System.out.println("File " + finalPath + " exists");
    		hdfs.copyToLocalFile(false, path, new Path( localPath), true);
    		//hdfs.copyToLocalFile(false, finalPath,new Path( "/home/nspl/temp"));

    	}
    	else
    	{
    		System.out.println("File " + finalPath + " does not exists");
    		return;
    	}

    	//log.info("fileData: "+fileData);


    	String filename = filePath.substring(filePath.lastIndexOf('/') + 1,
    			filePath.length());
    	log.info("filename: "+filename);
    	//String toEmail = "nishanthteam@gmail.com";

    	final String username = "carat.nspl@gmail.com";
    	final String password = "Welcome!23";
    	final String to = email;

    	Properties prts = new Properties();
    	prts.put("mail.smtp.auth", "true");
    	prts.put("mail.smtp.starttls.enable", "true");
    	prts.put("mail.smtp.host", "smtp.gmail.com");
    	prts.put("mail.smtp.port", "587");
    	prts.put("mail.smtp.ssl.trust", "smtp.gmail.com");

    	Session session = Session.getInstance(prts,new javax.mail.Authenticator(){
    		protected PasswordAuthentication getPasswordAuthentication() {
    			return new PasswordAuthentication(username, password);
    		}});
    	try {
    		Message message = new MimeMessage(session);
    		message.setFrom(new InternetAddress(username));
    		message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(to));
    		message.setSubject("Reporting sample Attachments");

    		Multipart multipart = new MimeMultipart("mixed");

    		MimeBodyPart messageBodyPart = new MimeBodyPart();
    		String content = "Hi there! <br><br>Please find the attachments regarding Resporting";
    		messageBodyPart.setContent(content, "text/html; charset=utf-8");

    		multipart.addBodyPart(messageBodyPart);


    		messageBodyPart = new MimeBodyPart();
    		DataSource source = new FileDataSource(localPath+filename);
    		messageBodyPart.setDataHandler(new DataHandler(source));
    		messageBodyPart.setFileName(filename);
    		multipart.addBodyPart(messageBodyPart);


    		message.setContent(multipart);


    		try{
    			Transport.send(message);
    			
    		}

    		catch(Exception e)
    		{

    			log.info(">>"+e);
    		}


    	} 
    	catch (MessagingException e) 
    	{
    		log.info("Invalid Credentials..."+ e);
    	}

    	File file = new File(localPath+filename);

		if(file.delete()){
			System.out.println(file.getName() + " is deleted!");
		}else{
			System.out.println("Delete operation is failed.");
		}
		hdfs.close();
    	return ;

    }
    
    
    
    @GetMapping("/shareReportingCSV")
    @Timed
    public LinkedHashMap shareReportingCSV(@RequestParam(required=false) String emailList,@RequestParam String requetId, HttpServletRequest request) 
    		throws AddressException, MessagingException, IOException, DocumentException, URISyntaxException, ParseException, ClassNotFoundException, SQLException
    {
    	log.info("REST API FOR SHARING SampleCSV");
    	log.info("email :"+emailList);


    	LinkedHashMap finalMap=new LinkedHashMap();
    	finalMap.put("status", "success");
    	
    	HashMap map=reportJsonToCSV(requetId, request);
    	log.info("map :"+map);
    	String localPath=map.get("path").toString();
    	/*ApplicationPrograms prog=applicationProgramsRepository.findByPrgmNameAndTenantIdAndEnableIsTrue("Reporting",tenantId);
    	String localPath=prog.getGeneratedPath();*/
    	log.info("localPath :"+localPath);

    	String filename = localPath.substring(localPath.lastIndexOf('/') + 1,
    			localPath.length());
    	log.info("filename: "+filename);
    	//String toEmail = "nishanthteam@gmail.com";
    	Long send=0l;
    	Long failed=0l;
    	final String username = "nspl.recon@gmail.com";
    	final String password = "Welcome!23";
    	String content = "";
    	String resourceName="";
    	
    	Reports reportsData=(Reports) map.get("ReportsData");
    	String reportName=reportsData.getReportName();
    	Long tenantId=reportsData.getTenantId();
    	Long repTypeId=reportsData.getReportTypeId();
    	HashMap<Long,ReportType> reportTypes=reportsService.getReportTypes(tenantId);
    	ReportType reportTypeData=reportTypes.get(repTypeId);
    	String reportType=reportTypeData.getDisplayName();
    	Long srcId=reportsData.getSourceViewId();
    	DataViews dataViews=dataViewsRepository.findOne(srcId);
    	String dataSourceTagged=dataViews.getDataViewDispName();
    	
    	ReportRequests reportRequests=(ReportRequests) map.get("reportRequests");
    	String requestName=reportRequests.getReqName();
    	ZonedDateTime generatedTime=reportRequests.getGeneratedTime();
    	Month month=generatedTime.getMonth();
		String mnthName=month.name();
		mnthName=mnthName.substring(0,1).toUpperCase() + mnthName.substring(1).toLowerCase();;
		int day=generatedTime.getDayOfMonth();
		int year=generatedTime.getYear();
		String generatedOn=day+" "+mnthName+" "+year+" "+generatedTime.getHour()+":"+generatedTime.getMinute()+":"+generatedTime.getSecond();
		Long createdBy=reportRequests.getCreatedBy();
		
		HashMap userInfo=userJdbcService.getUserInfo(createdBy,tenantId);
		String submittedBy=userInfo.get("assigneeName").toString();
		
    	/* Integrating Email Template Start */
    	BufferedReader br = null;
    	
		try {

			String sCurrentLine;
			InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream("reportsNotification.html");
			br = new BufferedReader(new InputStreamReader(inputStream, "UTF-8"));
			while ((sCurrentLine = br.readLine()) != null) {
				//log.info(sCurrentLine);
				content = content + sCurrentLine;
			}
			//System.out.println("content: "+content);
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
			try {
				if (br != null)br.close();
			} catch (IOException ex) {
				ex.printStackTrace();
			}
		}
		
		content = content.replaceAll("ReportName",reportName);
		content = content.replaceAll("ReportType",reportType);
		content = content.replaceAll("RequestName",requestName);
		content = content.replaceAll("GeneratedOn",generatedOn);
		content = content.replaceAll("SubmittedBy",submittedBy);
		content = content.replaceAll("DataSourceTagged",dataSourceTagged);
		String loginUrl=""; //get from tenantConfig table
		if(loginUrl!=null){
			loginUrl="#";
		}
		TenantConfig tenConfig=tenantConfigRepository.findByTenantIdAndKey(tenantId, "Application URL");
		String applicationUrl=tenConfig.getValue();
		String requestId=reportRequests.getIdForDisplay();
		String reportId=reportsData.getIdForDisplay();
		//String LoginBtn="<a href="+"\""+loginUrl+"\""+" style=\"font-weight:bold;padding:5px;border-radius:5px;background-color:#5270ff;color:white;margin-right:10px;text-decoration: none !important;\">Login</a>";
		String reportView="<a href="+applicationUrl+"/#/reports/(content:run-reports/"+requestId+"/"+reportId+")>Click Here</a>";
		log.info("reportView: "+reportView);
		content = content.replaceAll("reportView",reportView);
		
		/* Integrating Email Template end */

    	String[] emailArr=emailList.split(";");
    	for(int i=0;i<emailArr.length;i++){
    		//final String to = email;

    		String to=emailArr[i];
    		log.info("to: "+to);
    		
    		HashMap data=userJdbcService.getUserByEmail(to,tenantId);
    		if(data!=null && !(data.isEmpty())){
    			if(data.get("assigneeName")!=null)
    		resourceName=data.get("assigneeName").toString();
    		}
    		else{
    			resourceName=to;
    		}
    		
    		content = content.replaceAll("ResourceName",resourceName);

    		Properties prts = new Properties();
    		prts.put("mail.smtp.auth", "true");
    		prts.put("mail.smtp.starttls.enable", "true");
    		prts.put("mail.smtp.host", "smtp.gmail.com");
    		prts.put("mail.smtp.port", "587");
    		prts.put("mail.smtp.ssl.trust", "smtp.gmail.com");

    		Session session = Session.getInstance(prts,new javax.mail.Authenticator(){
    			protected PasswordAuthentication getPasswordAuthentication() {
    				return new PasswordAuthentication(username, password);
    			}});
    		try {
    			Message message = new MimeMessage(session);
    			message.setFrom(new InternetAddress(username));
    			message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(to));
    			message.setSubject("Reporting sample Attachments");

    			Multipart multipart = new MimeMultipart("mixed");

    			MimeBodyPart messageBodyPart = new MimeBodyPart();
    			//String content = "Hi there! <br><br>Please find the attachments regarding Reporting";
    			messageBodyPart.setContent(content, "text/html; charset=utf-8");

    			multipart.addBodyPart(messageBodyPart);


    			messageBodyPart = new MimeBodyPart();
    			DataSource source = new FileDataSource(localPath);
    			messageBodyPart.setDataHandler(new DataHandler(source));
    			//messageBodyPart.setFileName(filename);
    			multipart.addBodyPart(messageBodyPart);


    			message.setContent(multipart);


    			try{
    				Transport.send(message);
    				send=send+1l;
    			}

    			catch(Exception e)
    			{

    				log.info(">>"+e);
    				finalMap.put("status", "success");
    				failed=failed+1l;
    			}


    		} 
    		catch (MessagingException e) 
    		{
    			log.info("Invalid Credentials..."+ e);
    		}


    	}

    	File file = new File(localPath);

    	if(file.delete()){
    		System.out.println(file.getName() + " is deleted!");
    	}else{
    		System.out.println("Delete operation is failed.");
    	}
    	finalMap.put("send", send);
    	finalMap.put("failed", failed);


    	return finalMap;


    }

    
    
    
    
    
    
    
    /**
     * author :ravali
     * @param map
     * @throws IOException
     * @throws ParseException 
     * @throws URISyntaxException 
     */
    @GetMapping("/reportJsonExportToCSV")
    @Timed
    public HashMap reportJsonToCSV(@RequestParam String requestId,HttpServletRequest request) throws IOException, URISyntaxException, ParseException
    { 
    	log.info("Rest Request to Download reportJsonToCSV for requestId: "+requestId);
    	HashMap finalMap=new HashMap();
    	//ReportRequests reportRequests=reportRequestsRepository.findOne(requestId);
    	HashMap map1=userJdbcService.getuserInfoFromToken(request);
    	Long tenantId=Long.parseLong(map1.get("tenantId").toString());
    	ReportRequests reportRequests=reportRequestsRepository.findByTenantIdAndIdForDisplay(tenantId, requestId);
    	Reports rep=reportsRepository.findOne(reportRequests.getReportId());
    	String reportName=rep.getReportName();
    	
    	ApplicationPrograms prog=applicationProgramsRepository.findByPrgmNameAndTenantIdAndEnableIsTrue("Reporting",tenantId);
    	String localPath=prog.getGeneratedPath();
    	log.info("ProgramPath configured for Reports :"+localPath);
    	LinkedHashMap cmpltOutput=reportsService.hdfsFileReading(reportRequests.getOutputPath());
    	
    	List<HashMap> header=(List<HashMap>) cmpltOutput.get("columns");
    	List<HashMap> values=(List<HashMap>) cmpltOutput.get("data");
    	List<String> head=new ArrayList<String>();
    	for(int i=0;i<header.size();i++)
    	{
    		head.add(header.get(i).get("field").toString());
    	}

    	log.info("head :"+head);

    	Long startDate = System.currentTimeMillis() ;
    	Long startNanoseconds = System.nanoTime() ;
    	SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS") ;
    	Long microSeconds = (System.nanoTime() - startNanoseconds) / 1000 ;
    	Long date = startDate + (microSeconds/1000) ;
		    String res= dateFormat.format(date) + String.format("%03d", microSeconds % 1000);
		    String updRes=res.replace(' ', '_');
		    updRes=updRes.replace(':', '-');
		    updRes=updRes.replace('.', '-');
    	
    	
    	String newFileName = localPath+reportName.replaceAll("\\s","")+"_"+requestId+"_"+updRes+".csv";
    	log.info("Report File Name :"+newFileName);
    	finalMap.put("path", newFileName);
    	File newFile = new File(newFileName);
    	boolean b = false;
        if (!newFile.exists()) {
          b = newFile.createNewFile();
        }
      
        log.info("Report file Created :"+b);
    	
    	String commaSeparated = head.stream()
    			.collect(Collectors.joining("\",\""));
    	
    	try (

    			BufferedWriter writer = Files.newBufferedWriter(Paths.get(newFileName));

    			CSVPrinter csvPrinter = new CSVPrinter(writer, CSVFormat.DEFAULT
    					.withHeader("\""+commaSeparated+"\""));
    			) {

    		for(int j=0;j<values.size();j++)
    		{
    			List<String> valuesList=new ArrayList<String>();
    			for(String hea:head)
    			{
    				//log.info("hea: "+hea);
    				if(values.get(j).containsKey(hea)){
    					//log.info("values.get(j).get(hea): "+values.get(j).get(hea));
    				valuesList.add(values.get(j).get(hea).toString());
    				}
    				else{
    					valuesList.add("");
    				}
    			}
    			
    			commaSeparated=valuesList.stream()
    					.collect(Collectors.joining("\",\""));
    			
    			csvPrinter.printRecord("\""+commaSeparated+"\"");
    		}
    	//	finalMap.put("path", newFileName);
    		
    		log.info("Report File Name :"+newFileName);
    		
    		File file = new File(newFileName);
        	InputStream inputStream=new FileInputStream(file);
        	String[] destPath=fileService.fileUpload(inputStream, reportName.replaceAll("\\s","")+"_"+requestId+"_"+updRes+".csv");
        	
        	if(destPath[0].equalsIgnoreCase("success"))
        	{
        		finalMap.put("status", destPath[0]);
        		log.info("destPath[1] :"+destPath[1]);
        		String finalFSPath="";
        		TenantConfig fileServerUrl=tenantConfigRepository.findByTenantIdAndKey(tenantId, "File Server Path");
        		
        		if(fileServerUrl!=null)
        			finalFSPath=fileServerUrl.getValue()+destPath[1];
        		else
        		{
        			 fileServerUrl=tenantConfigRepository.findByTenantIdAndKey(0l, "File Server Path");
        			 finalFSPath=fileServerUrl.getValue()+destPath[1];
        		}
        		
        		finalMap.put("destPath", finalFSPath);
        	}
        	else
        	{
        		finalMap.put("status", "failure");
        	}
    		
        	finalMap.put("ReportsData", rep);
        	finalMap.put("reportRequests", reportRequests);
    		csvPrinter.flush();            
    	}
		return finalMap;
		
    }
    
    
    @PostMapping("/sortbykey")
    @Timed
    public static void sortbykey(@RequestParam LinkedHashMap output)
    {
        // TreeMap to store values of HashMap
    	Map<String, Integer> map = new HashMap<>();
        TreeMap<String, Integer> sorted = new TreeMap<>();
 
        // Copy all data from hashMap into TreeMap
        sorted.putAll(map);
 
        // Display the TreeMap which is naturally sorted
        for (Map.Entry<String, Integer> entry : sorted.entrySet()) 
            System.out.println("Key = " + entry.getKey() + 
                         ", Value = " + entry.getValue());        
    }
    
    @PostMapping("/sortingValuesInReportOutputJson")
    @Timed
    public JSONObject sortingValuesInJson(@RequestParam Long requestId,@RequestParam String sortColumn,@RequestParam(required=false) String sortOrder,
    		 @RequestParam(required=false) Integer pageNumber, @RequestParam(required=false) Integer pageSize,HttpServletResponse response) 
    		throws IOException, JSONException, ParseException, URISyntaxException
    {

    	
    	log.info("requestId: "+requestId);
    	log.info("pageNumber: "+pageNumber+" & pageSize: "+pageSize);
    	ReportRequests req=reportRequestsRepository.findOne(requestId);
    	log.info("req.getOutputPath(): "+req.getOutputPath());
    	JSONObject jsonValue =new JSONObject();
    	if(req.getOutputPath()!=null)
    	{
    	LinkedHashMap cmpltOutput=reportsService.hdfsFileReading(req.getOutputPath());
    	JSONObject obj=new JSONObject();
    	obj.putAll(cmpltOutput);
    	String paramVal=obj.toJSONString();
    	JSONParser parser = new JSONParser();
    	 jsonValue = (JSONObject) parser.parse(paramVal);
    	

    	List<JSONObject> jsonValueList = (List<JSONObject>) jsonValue.get("data");

    	Collections.sort( jsonValueList, new Comparator<JSONObject>() { 


    		@Override
    		public int compare(JSONObject a, JSONObject b) {
    			String valA = new String();
    			String valB = new String();

    			valA = (String) a.get(sortColumn);
    			valB = (String) b.get(sortColumn);


    			if(sortOrder!=null && sortOrder.equalsIgnoreCase("ascending"))
    				return valA.compareTo(valB);
    			else
    				return -valA.compareTo(valB);
    			//if you want to change the sort order, simply use the following:
    			//return -valA.compareTo(valB);
    		}
    	});
    	
    	
    	List<JSONObject> finalObj=new ArrayList<JSONObject>();
    	/*for (int i = 0; i < jsonValueList.size(); i++) {
    		finalObj.add(jsonValueList.get(i));
    	}*/
    	int totDataCnt=Integer.parseInt(cmpltOutput.get("X-COUNT").toString());
		log.info("totDataCnt: "+totDataCnt);
		response.addIntHeader("X-COUNT", totDataCnt);
    //	jsonValue.put("data", finalObj);
    	
    	
    	int limit = 0;
		if(pageNumber == null || pageNumber == 0)
		{
			pageNumber = 0;
		}
		if(pageSize == null || pageSize == 0)
		{
			pageSize = totDataCnt;
		}
			limit = ((pageNumber+1) * pageSize + 1)-1;
		int startIndex=pageNumber*pageSize; 
		
		if(limit>totDataCnt){
			limit=totDataCnt;
		}
		
		log.info("startIndex: "+startIndex+" limit: "+limit);
		
		for(int j=startIndex;j<limit;j++){
			
			JSONObject map=jsonValueList.get(j);
			finalObj.add(map);
			
		}
		
		log.info("finalObj: "+finalObj);
		jsonValue.put("data", finalObj);
    	}
    	return jsonValue;
    }
    
    
    
    
    @PostMapping("/SearchValuesInReportOutputJson")
    @Timed
    public JSONObject SearchValuesInReportOutputJson(@RequestParam Long requestId,@RequestParam String serachString,
    		 @RequestParam(required=false) Integer pageNumber, @RequestParam(required=false) Integer pageSize,HttpServletResponse response) 
    		throws IOException, JSONException, ParseException, URISyntaxException
    {

    	
    	log.info("requestId: "+requestId);
    	log.info("pageNumber: "+pageNumber+" & pageSize: "+pageSize);
    	ReportRequests req=reportRequestsRepository.findOne(requestId);
    	log.info("req :"+req);
    	JSONObject jsonValue =new JSONObject();
    	if(req.getOutputPath()!=null)
    	{
    	LinkedHashMap cmpltOutput=reportsService.hdfsFileReading(req.getOutputPath());
    	JSONObject obj=new JSONObject();
    	obj.putAll(cmpltOutput);
    	String paramVal=obj.toJSONString();
    	JSONParser parser = new JSONParser();
    	 jsonValue = (JSONObject) parser.parse(paramVal);
    	

    	List<JSONObject> jsonValueList = (List<JSONObject>) jsonValue.get("data");
    	List<JSONObject> searchObj=new ArrayList<JSONObject>();
    	
    	List<JSONObject> finalObj=new ArrayList<JSONObject>();
    	
    	List<HashMap> header=(List<HashMap>) cmpltOutput.get("columns");
    //	List<HashMap> values=(List<HashMap>) cmpltOutput.get("data");
    	List<String> headList=new ArrayList<String>();
    	for(int i=0;i<header.size();i++)
    	{
    		headList.add(header.get(i).get("field").toString());
    	}

    	log.info("head :"+headList);
    	
    	
    	for (int i = 0; i < jsonValueList.size(); i++) {
    		
    		for (String  head:headList)
    		{
    			
    			
    			if(jsonValueList.get(i).get(head).toString().toLowerCase().contains(serachString.toLowerCase()))
    				searchObj.add(jsonValueList.get(i));
    			/*else if(jsonValueList.get(i).get(head).toString().toUpperCase().contains(serachString))
    				searchObj.add(jsonValueList.get(i));*/
    		}
    	
	}
    
    	int totDataCnt= searchObj.size();
		response.addIntHeader("X-COUNT", searchObj.size());
    
    	int limit = 0;
		if(pageNumber == null || pageNumber == 0)
		{
			pageNumber = 0;
		}
		if(pageSize == null || pageSize == 0)
		{
			pageSize = totDataCnt;
		}
		log.info("pageNumber :"+pageNumber +" pageSize :"+pageSize );
			limit = ((pageNumber+1) * pageSize + 1)-1;
			log.info("limit :"+limit);
		int startIndex=pageNumber*pageSize; 
		
		if(limit>totDataCnt){
			limit=totDataCnt;
		}
		
		log.info("startIndex: "+startIndex+" limit: "+limit);
		if(searchObj!=null && !searchObj.isEmpty())
		{
		for(int j=startIndex;j<limit;j++){
			
			
			JSONObject map=searchObj.get(j);
			finalObj.add(map);
		
			
		}
    	}
		
		log.info("finalObj: "+finalObj);
		jsonValue.put("data", finalObj);
    	}
    	return jsonValue;
    }
    
    
    /**seraching based on key values**/
    
    @PostMapping("/SearchKeyValuesInReportOutputJson")
    @Timed
    public JSONObject SearchKeyValuesInReportOutputJson(@RequestParam(required=false) LinkedHashMap keyValues,@RequestParam Long requestId,@RequestParam String serachString,
    		 @RequestParam(required=false) Integer pageNumber, @RequestParam(required=false) Integer pageSize,HttpServletResponse response) 
    		throws IOException, JSONException, ParseException, URISyntaxException
    {

    	
    	log.info("requestId: "+requestId);
    	log.info("pageNumber: "+pageNumber+" & pageSize: "+pageSize);
    	ReportRequests req=reportRequestsRepository.findOne(requestId);
    	log.info("req :"+req);
    	JSONObject jsonValue =new JSONObject();
    	if(req.getOutputPath()!=null)
    	{
    	LinkedHashMap cmpltOutput=reportsService.hdfsFileReading(req.getOutputPath());
    	JSONObject obj=new JSONObject();
    	obj.putAll(cmpltOutput);
    	String paramVal=obj.toJSONString();
    	JSONParser parser = new JSONParser();
    	 jsonValue = (JSONObject) parser.parse(paramVal);
    	

    	List<JSONObject> jsonValueList = (List<JSONObject>) jsonValue.get("data");
    	List<JSONObject> searchObj=new ArrayList<JSONObject>();
    	
    	List<JSONObject> finalObj=new ArrayList<JSONObject>();
    	
    	List<HashMap> header=(List<HashMap>) cmpltOutput.get("columns");
    //	List<HashMap> values=(List<HashMap>) cmpltOutput.get("data");
    	List<String> headList=new ArrayList<String>();
    	for(int i=0;i<header.size();i++)
    	{
    		headList.add(header.get(i).get("field").toString());
    	}

    	log.info("head :"+headList);
    	
    	
    	for (int i = 0; i < jsonValueList.size(); i++) {
    		
    		if(keyValues.size()>0 && keyValues !=null)
    		{
    			
    		}
    		else
    		{
    		for (String  head:headList)
    		{
    			
    			
    			if(jsonValueList.get(i).get(head).toString().toLowerCase().contains(serachString.toLowerCase()))
    				searchObj.add(jsonValueList.get(i));
    			/*else if(jsonValueList.get(i).get(head).toString().toUpperCase().contains(serachString))
    				searchObj.add(jsonValueList.get(i));*/
    		}
    	}
    	
	}
    
    	int totDataCnt= searchObj.size();
		response.addIntHeader("X-COUNT", searchObj.size());
    
    	int limit = 0;
		if(pageNumber == null || pageNumber == 0)
		{
			pageNumber = 0;
		}
		if(pageSize == null || pageSize == 0)
		{
			pageSize = totDataCnt;
		}
		log.info("pageNumber :"+pageNumber +" pageSize :"+pageSize );
			limit = ((pageNumber+1) * pageSize + 1)-1;
			log.info("limit :"+limit);
		int startIndex=pageNumber*pageSize; 
		
		if(limit>totDataCnt){
			limit=totDataCnt;
		}
		
		log.info("startIndex: "+startIndex+" limit: "+limit);
		if(searchObj!=null && !searchObj.isEmpty())
		{
		for(int j=startIndex;j<limit;j++){
			
			
			JSONObject map=searchObj.get(j);
			finalObj.add(map);
		
			
		}
    	}
		
		log.info("finalObj: "+finalObj);
		jsonValue.put("data", finalObj);
    	}
    	return jsonValue;
    }
    
    
    /**
     * author :ravali
     * @param tenantId
     * @return
     */
    
    @GetMapping("/reportingSideBarAPI")
    @Timed
    public List<LinkedHashMap> reportingSideBarAPI(@RequestParam Long tenantId) 
    		
    {
    	log.info("rest request to get reports and their counts by tenantId :"+tenantId);
    	
    	List<String> reportNames=reportTypeRepository.findDistinctTypeBytenantIdAndEnableFlagIsTrue(tenantId);
    	List<LinkedHashMap> finalMapList=new ArrayList<LinkedHashMap>();
    	for(String report:reportNames)
    	{
    		
    		if(report!=null)
    		{
    			ReportType reportType=reportTypeRepository.findByTypeAndTenantId(report,tenantId);
    			if(reportType!=null)
    			{
    			LinkedHashMap reportMap=new LinkedHashMap();
    			reportMap.put("reportTypeName", report);
    			int count=0;
    			List<LinkedHashMap> reportMapLiist=new ArrayList<LinkedHashMap>();
    			List<Reports> reportsList=reportsRepository.findByReportTypeId(reportType.getId());
    			for(Reports reports:reportsList)
    			{
    				count=count+1;
    				LinkedHashMap map=new LinkedHashMap();
    				map.put("id", reports.getId());
    				map.put("reportName", reports.getReportName());
    				reportMapLiist.add(map);
    				
    			}
    			reportMap.put("totalCount", count);
    			reportMap.put("reportsList", reportMapLiist);
    			if(reportsList.size()>0)
    			finalMapList.add(reportMap);
    			}
    			
    		}
    	}
		return finalMapList;
    	
    }
    
    
    
    
    @GetMapping("/reportOutPutExport")
    @Timed
    public HashMap reportOutPutExport(@RequestParam String requestId,HttpServletRequest request,@RequestParam(value="fileType",required=false) String fileType,HttpServletResponse response) throws IOException, URISyntaxException, ParseException
    { 
    	log.info("Rest Request to Download reportJsonToCSV for requestId: "+requestId);
    	HashMap finalMap=new HashMap();
    	//ReportRequests reportRequests=reportRequestsRepository.findOne(requestId);
    	HashMap map1=userJdbcService.getuserInfoFromToken(request);
    	Long tenantId=Long.parseLong(map1.get("tenantId").toString());
    	ReportRequests reportRequests=reportRequestsRepository.findByTenantIdAndIdForDisplay(tenantId, requestId);
    	Reports rep=reportsRepository.findOne(reportRequests.getReportId());
    	log.info("rep :"+rep);
    	String reportName=rep.getReportName();
    	
    	ApplicationPrograms prog=applicationProgramsRepository.findByPrgmNameAndTenantIdAndEnableIsTrue("Reporting",tenantId);
    	String localPath=prog.getGeneratedPath();
    	log.info("ProgramPath configured for Reports :"+localPath);
    	LinkedHashMap cmpltOutput=reportsService.hdfsFileReading(reportRequests.getOutputPath());
    	
    	List<HashMap> header=(List<HashMap>) cmpltOutput.get("columns");
    	List<HashMap> values=(List<HashMap>) cmpltOutput.get("data");
    
    	List<String> head=new ArrayList<String>();
    	for(int i=0;i<header.size();i++)
    	{
    		head.add(header.get(i).get("field").toString());
    	}

    	log.info("head :"+head);

   
    		
    		if(fileType.equalsIgnoreCase("csv"))
        	{
        		response.setContentType ("application/csv");
        		response.setHeader ("Content-Disposition", "attachment; filename=\"reportOutPut.csv\"");

        		fileExportService.jsonToCSVForReports(values,head,response.getWriter());
        


        	}
    		
    		if(fileType.equalsIgnoreCase("pdf"))
        	{
        		response.setContentType ("application/pdf");
        		response.setHeader ("Content-Disposition", "attachment; filename=\"reportOutPut.pdf\"");

        		fileExportService.jsonToCSVForReports(values,head,response.getWriter());
      


        	}
        	else if(fileType.equalsIgnoreCase("excel"))
        	{
        		response.setContentType("application/vnd.ms-excel");
        		response.setHeader(
        				"Content-Disposition",
        				"attachment; filename=\"reportOutPut.xlsx\""
        				);
        		fileExportService.jsonToCSVForReports(values,head,response.getWriter());
        	}
    		
    		
    	
		return finalMap;
		
    }
    

}