package com.nspl.app.service;

import static org.elasticsearch.index.query.QueryBuilders.queryStringQuery;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.text.DateFormat;
import java.text.NumberFormat;
import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.time.ZonedDateTime;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.stream.Collectors;

import javax.inject.Inject;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.sql.DataSource;

import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVPrinter;
import org.apache.poi.xssf.usermodel.XSSFRow;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.core.env.Environment;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.nspl.app.config.ApplicationContextProvider;
import com.nspl.app.domain.AccountingEvents;
import com.nspl.app.domain.AppModuleSummary;
import com.nspl.app.domain.DataViews;
import com.nspl.app.domain.DataViewsColumns;
import com.nspl.app.domain.FileTemplateLines;
import com.nspl.app.domain.FormConfig;
import com.nspl.app.domain.LookUpCode;
import com.nspl.app.domain.ReconciliationResult;
import com.nspl.app.domain.RuleGroup;
import com.nspl.app.domain.Rules;
import com.nspl.app.domain.TenantConfig;
import com.nspl.app.repository.AccountingEventsRepository;
import com.nspl.app.repository.AppModuleSummaryRepository;
import com.nspl.app.repository.AppRuleConditionsRepository;
import com.nspl.app.repository.BalanceTypeRepository;
import com.nspl.app.repository.DataChildRepository;
import com.nspl.app.repository.DataViewsColumnsRepository;
import com.nspl.app.repository.DataViewsRepository;
import com.nspl.app.repository.FileTemplateLinesRepository;
import com.nspl.app.repository.LookUpCodeRepository;
import com.nspl.app.repository.ReconciliationDuplicateResultRepository;
import com.nspl.app.repository.ReconciliationResultRepository;
import com.nspl.app.repository.RuleConditionsRepository;
import com.nspl.app.repository.RuleGroupDetailsRepository;
import com.nspl.app.repository.RuleGroupRepository;
import com.nspl.app.repository.RulesRepository;
import com.nspl.app.repository.TenantConfigRepository;
import com.nspl.app.repository.search.ReconciliationResultSearchRepository;
import com.nspl.app.web.rest.DataViewsResource;
import com.nspl.app.web.rest.dto.FilterColumns;
import com.nspl.app.web.rest.dto.ReconCountNAmountsDTO;
import com.nspl.app.web.rest.dto.ReconUnReconAmountsDTO;

/**
 * Service Implementation for managing ReconciliationResult.
 */
@Service
@Transactional
public class ReconciliationResultService {

    private final Logger log = LoggerFactory.getLogger(ReconciliationResultService.class);
    
    private final ReconciliationResultRepository reconciliationResultRepository;

    private final ReconciliationResultSearchRepository reconciliationResultSearchRepository;
    
    @Inject
    RuleGroupDetailsRepository ruleGroupDetailsRepository;
    
    @Inject
    RuleGroupRepository ruleGroupRepository;
    
    @Inject
    RulesRepository rulesRepository;
    
    @Inject
    DataViewsResource dataViewsResource;
    
    @Inject
    FileTemplateLinesRepository fileTemplateLinesRepository;
    
    @Inject
    DataViewsColumnsRepository dataViewsColumnsRepository;
    
    @Inject
    PropertiesUtilService propertiesUtilService;
    
    @Inject
    DataViewsRepository dataViewsRepository;
    
    @Inject
    RuleConditionsRepository ruleConditionsRepository;
    
    @Inject
    ReconciliationResultService reconciliationResultService;
    
    @Inject
    AccountingDataService accountingDataService;
    
    @Inject
    BalanceTypeService balanceTypeService;
    
    @Inject
    AppRuleConditionsRepository  appRuleConditionsRepository;
    
    @Inject
    AccountingEventsRepository accountingEventsRepository;
    
    @Inject
    AppModuleSummaryRepository appModuleSummaryRepository;
    
    @Inject
    BalanceTypeRepository balanceTypeRepository;

    @Inject
    ReconciliationDuplicateResultRepository reconciliationDuplicateResultRepository;

    @Inject
    LookUpCodeRepository lookUpCodeRepository;
    
    @Inject
    TenantConfigRepository tenantConfigRepository;
    
    @Inject
    DataChildRepository dataChildRepository;
    
    @Inject
    FileService fileService;
    
    
    @Inject
    UserJdbcService userJdbcService;
    
    @Inject
    private Environment env;
    
	@PersistenceContext(unitName="default")
	private EntityManager em;

    public ReconciliationResultService(ReconciliationResultRepository reconciliationResultRepository, ReconciliationResultSearchRepository reconciliationResultSearchRepository) {
        this.reconciliationResultRepository = reconciliationResultRepository;
        this.reconciliationResultSearchRepository = reconciliationResultSearchRepository;
    }

    /**
     * Save a reconciliationResult.
     *
     * @param reconciliationResult the entity to save
     * @return the persisted entity
     */
    public ReconciliationResult save(ReconciliationResult reconciliationResult) {
        log.debug("Request to save ReconciliationResult : {}", reconciliationResult);
        ReconciliationResult result = reconciliationResultRepository.save(reconciliationResult);
        reconciliationResultSearchRepository.save(result);
        return result;
    }

    /**
     *  Get all the reconciliationResults.
     *  
     *  @param pageable the pagination information
     *  @return the list of entities
     */
    @Transactional(readOnly = true)
    public Page<ReconciliationResult> findAll(Pageable pageable) {
        log.debug("Request to get all ReconciliationResults");
        Page<ReconciliationResult> result = reconciliationResultRepository.findAll(pageable);
        return result;
    }

    /**
     *  Get one reconciliationResult by id.
     *
     *  @param id the id of the entity
     *  @return the entity
     */
    @Transactional(readOnly = true)
    public ReconciliationResult findOne(Long id) {
        log.debug("Request to get ReconciliationResult : {}", id);
        ReconciliationResult reconciliationResult = reconciliationResultRepository.findOne(id);
        return reconciliationResult;
    }

    /**
     *  Delete the  reconciliationResult by id.
     *
     *  @param id the id of the entity
     */
    public void delete(Long id) {
        log.debug("Request to delete ReconciliationResult : {}", id);
        reconciliationResultRepository.delete(id);
        reconciliationResultSearchRepository.delete(id);
    }

    /**
     * Search for the reconciliationResult corresponding to the query.
     *
     *  @param query the query of the search
     *  @param pageable the pagination information
     *  @return the list of entities
     */
    @Transactional(readOnly = true)
    public Page<ReconciliationResult> search(String query, Pageable pageable) {
        log.debug("Request to search for a page of ReconciliationResults for query {}", query);
        Page<ReconciliationResult> result = reconciliationResultSearchRepository.search(queryStringQuery(query), pageable);
        return result;
    }
    
    /**
     * Author: Shiva
     * Description: Service for getting original ids based on view id
     * @return
     * @throws ClassNotFoundException
     * @throws SQLException 
     */
    public List<BigInteger> getViewIds(BigInteger viewId) throws ClassNotFoundException, SQLException
    {
    	List<BigInteger> originalIds = new ArrayList<BigInteger>();
		Connection conn = null;
		Statement stmt = null;
		ResultSet result = null; 
    	try{
			DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
			conn = ds.getConnection();
     	    stmt = conn.createStatement();
      	    DataViews dv=dataViewsRepository.findOne(viewId.longValue());
      	    if(dv!= null)
      	    {
         	    String viewName=dv.getDataViewName();
         	    result=stmt.executeQuery("select scrIds from `"+viewName.toLowerCase()+"`");
         	 	while(result.next()){
         	 	    	originalIds.add(new BigInteger((result.getString(1))));
         	 	}  
      	    }
      	    else
      	    {
      	    	log.info("View doen't not exist for the view id: "+viewId);
      	    }
    	 }catch(SQLException se){
    		   log.info("Error while executing query: "+se);
         }
    	catch(Exception e)
    	{
        	 log.info("Exception while getting databse properties");
    	}
    	finally{
    		if(result != null)
    			result.close();	
    		if(stmt != null)
    			stmt.close();
			if(conn != null)
				conn.close();
		}
    	log.info("View ID: "+ viewId+", Row Ids Size: "+originalIds.size());
    	return originalIds;
    }

    /* Get Distinct DvIds based on RuleGroup */
    public HashMap<String, List<BigInteger>> getDistinctDVIdsforRuleGrp(Long ruleGrpId, Long tenantId){
    	log.info("In Service for getting distinct source and target ids for grup id: "+ruleGrpId+", tenantId: "+ tenantId);
    	HashMap<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
    	List<BigInteger> distSrcIds = new ArrayList<BigInteger>();
    	List<BigInteger> distTargetIds = new ArrayList<BigInteger>();
    	List<Long> ruleIds = ruleGroupDetailsRepository.fetchByRuleGroupIdAndTenantId(ruleGrpId, tenantId);
    	log.info("Rule Ids Size for Group Id "+ruleGrpId+": "+ruleIds.size()+", "+ruleIds);
    	if(ruleIds.size()>0)
    	{
    		distSrcIds = rulesRepository.fetchDistictSrcViewIdsByRuleId(ruleIds);
    		distTargetIds = rulesRepository.fetchDistictTargetViewIdsByRuleId(ruleIds);
    	}
    	log.info("Distinct Source View Ids for GroupId "+ruleGrpId+" : "+distSrcIds);
    	log.info("Distinct Target View Ids for GroupId "+ruleGrpId+" : "+distTargetIds);
    	finalMap.put("sourceViewIds", distSrcIds);
    	finalMap.put("targeViewIds", distTargetIds);
		return finalMap;
    }

	/* Getting Amount Qualifier Field for DataViewId */
	public String getQualifier(BigInteger dataViewId){
		log.info("In Service for getting qualifier column name for the view id: "+ dataViewId);
    	DataViewsColumns dvc = dataViewsColumnsRepository.findByDataViewIdAndQualifier(dataViewId.longValue(), "AMOUNT");
    	String qualifier = "";
    	if(dvc != null)
    	{
    		if("File Template".equalsIgnoreCase(dvc.getRefDvType()))
    		{
        		FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dvc.getRefDvColumn()));
        		if(ftl != null)
        		{
        			qualifier = ftl.getColumnAlias();
        		}
        		log.info("Amount Qualifier for View ID "+ dataViewId +" is ["+dvc.getColumnName()+", "+qualifier+"]");
    		}
    		else if("Data View".equalsIgnoreCase(dvc.getRefDvType()) || dvc.getRefDvType() == null)
    		{
    			qualifier= dvc.getColumnName();
    		}
    	}
    	else
    	{
    		log.info("There is no Amount Qualifier for the view id : "+ dataViewId);
    	}
    	return qualifier;
 }
	
	/* Getting Amount Qualifier Field for DataViewId */
	public String getCurrencyQualifier(BigInteger dataViewId) throws ClassNotFoundException{
		log.info("In Service for getting currency code qualifier column name for the view id: "+ dataViewId);
    	DataViewsColumns dvc = dataViewsColumnsRepository.findByDataViewIdAndQualifier(dataViewId.longValue(), "CURRENCYCODE");
    	String qualifier = "";
    	if(dvc != null)
    	{
    		if("File Template".equalsIgnoreCase(dvc.getRefDvType()))
    		{
        		FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dvc.getRefDvColumn()));
        		if(ftl != null)
        		{
        			qualifier = ftl.getColumnAlias();
        		}
        		log.info("Currency Code Qualifier for View ID "+ dataViewId +" is ["+dvc.getColumnName()+", "+qualifier+"]");
    		}
    		else if("Data View".equalsIgnoreCase(dvc.getRefDvType()) || dvc.getRefDvType() == null)
    		{
    			qualifier= dvc.getColumnName();
    		}
    	}
    	else
    	{
    		log.info("There is no currency code qualifier for the view id : "+ dataViewId);
    	}
    	return qualifier;
 }
	
	public String getQualifierColumnName(BigInteger dataViewId) throws ClassNotFoundException{
		log.info("In Service for getting qualifier column name for the view id: "+ dataViewId);
    	DataViewsColumns dvc = dataViewsColumnsRepository.findByDataViewIdAndQualifier(dataViewId.longValue(), "AMOUNT");
    	String qualifier = "";
    	if(dvc != null)
    	{
    		qualifier = qualifier + dvc.getColumnName();
    		log.info("Qualifier column name for data view id "+ dataViewId + " is: "+ qualifier);
    	}
    	else
    	{
    		log.info("There is no Qualifier for the view id : "+ dataViewId);
    	}
    	return qualifier;
 }
	
    /* Getting Count and Amount based on DVId */
	public HashMap getCountNAmountForDVId(BigInteger dataViewId, Long tenantId, String quaifierCol, List<BigInteger> viewTotalIds) throws ClassNotFoundException{		
		int count = viewTotalIds.size();
		NumberFormat numFormat = NumberFormat.getInstance();
    	HashMap finalMap=new HashMap();
    	Double totalAmount = 0.0d;
    	totalAmount = totalAmount + Double.parseDouble(getAmountSumByIds(viewTotalIds, quaifierCol, dataViewId));
        finalMap.put("totalCount", numFormat.format(count));
        finalMap.put("totalAmount", totalAmount);
        finalMap.put("totalIds", viewTotalIds);
		return finalMap;
    }
       
    /* Getting Reconciled Map<String, List<Long>> and UnReconciled Id's for Source*/
    public Map<String, List<BigInteger>> getSourceRecNUnRecIds(Long dataViewId, Long tenantId, List<BigInteger> srcTotalIds, Long groupId) throws ClassNotFoundException{
    	List<Long> ruleIds = rulesRepository.fetchIdsByViewId(dataViewId, tenantId);
    	Map<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
    	List<BigInteger> reconciledIds = new ArrayList<BigInteger>();
    	List<BigInteger> sourceUnreconciledIds = new ArrayList<BigInteger>();
    	if(ruleIds.size()>0)
    	{
    		reconciledIds = reconciliationResultRepository.fetchOriginalRowIdsByTenantIdAndRuleIdsAndSourceViewId(tenantId, ruleIds, dataViewId, groupId);
    		/*reconciledIds = reconciliationResultRepository.fetchOriginalRowIdsByOriginalIdsAndJobReferenceNull(tenantId, dataViewId, srcTotalIds,groupId);*/
    	}
    	if(srcTotalIds.size()>0)
    	{
			for(BigInteger id : srcTotalIds)
			{
				if(!reconciledIds.contains(id))
				{
					sourceUnreconciledIds.add(id);
				}
			}
    	}
    	finalMap.put("reconciled", reconciledIds);
    	finalMap.put("unReconciled", sourceUnreconciledIds);
    	log.info("Source View ID: "+dataViewId+", Total Size: "+srcTotalIds.size());
    	log.info("Source View ID: "+dataViewId+", Reconciled Size: "+reconciledIds.size());
    	log.info("Source View ID: "+dataViewId+", UnReconciled Size: "+sourceUnreconciledIds.size());
		return finalMap;
    }
    
    public Map<String, List<BigInteger>> getSourceViewRecNUnRecIdsWithJobReference(Long dataViewId, Long tenantId, List<BigInteger> srcTotalIds, Long groupId, String jobReference) throws ClassNotFoundException{
    	List<Long> ruleIds = rulesRepository.fetchIdsByViewId(dataViewId, tenantId);
    	Map<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
    	List<BigInteger> reconciledIds = new ArrayList<BigInteger>();
    	List<BigInteger> sourceUnreconciledIds = new ArrayList<BigInteger>();
    	if(srcTotalIds.size()>0)
    	{
	    	if(ruleIds.size()>0)
	    	{
	    		reconciledIds = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForSource(tenantId, groupId, srcTotalIds,dataViewId);
	    	}
			for(BigInteger id : srcTotalIds)
			{
				if(!reconciledIds.contains(id))
				{
					sourceUnreconciledIds.add(id);
				}
			}
    	}
    	finalMap.put("reconciled", reconciledIds);
    	finalMap.put("unReconciled", sourceUnreconciledIds);
    	finalMap.put("totalIds", srcTotalIds);
    	log.info("Source View ID: "+dataViewId+", Total Size: "+srcTotalIds.size());
    	log.info("Source View ID: "+dataViewId+", Reconciled Size: "+reconciledIds.size());
    	log.info("Source View ID: "+dataViewId+", UnReconciled Size: "+sourceUnreconciledIds.size());
		return finalMap;
    }
    
    public Map<String, List<BigInteger>> getTargetViewRecNUnRecIdsWithJobReference(Long dataViewId, Long tenantId, List<BigInteger> srcTotalIds, Long groupId, String jobReference) throws ClassNotFoundException{
    	List<Long> ruleIds = rulesRepository.fetchIdsByViewId(dataViewId, tenantId);
    	Map<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
    	List<BigInteger> reconciledIds = new ArrayList<BigInteger>();
    	List<BigInteger> sourceUnreconciledIds = new ArrayList<BigInteger>();
    	if(ruleIds.size()>0)
    	{
    		if(jobReference.length()>0)
    		{
 
    			reconciledIds = reconciliationResultRepository.fetchTargetRowIdsByOriginalIdsAndJobReference(tenantId,dataViewId, srcTotalIds,groupId,jobReference);
    			
    		}
    		else
    		{
    			reconciledIds = reconciliationResultRepository.fetchTargetRowIdsByOriginalIdsAndJobReferenceNull(tenantId,dataViewId, srcTotalIds,groupId);
    		}
    	}
    	if(srcTotalIds.size()>0)
    	{
			for(BigInteger id : srcTotalIds)
			{
				if(!reconciledIds.contains(id))
				{
					sourceUnreconciledIds.add(id);
				}
			}
    	}
    	finalMap.put("reconciled", reconciledIds);
    	finalMap.put("unReconciled", sourceUnreconciledIds);
    	log.info("Source View ID: "+dataViewId+", Total Size: "+srcTotalIds.size());
    	log.info("Source View ID: "+dataViewId+", Reconciled Size: "+reconciledIds.size());
    	log.info("Source View ID: "+dataViewId+", UnReconciled Size: "+sourceUnreconciledIds.size());
		return finalMap;
    }
    
    public Map<String, List<BigInteger>> getTargetViewRecNUnRecIdsWithJobReferenceProcess(Long dataViewId, Long tenantId, List<BigInteger> srcTotalIds, Long groupId, String jobReference) throws ClassNotFoundException{
    	List<Long> ruleIds = rulesRepository.fetchIdsByViewId(dataViewId, tenantId);
    	Map<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
    	List<BigInteger> reconciledIds = new ArrayList<BigInteger>();
    	List<BigInteger> sourceUnreconciledIds = new ArrayList<BigInteger>();
    	if(srcTotalIds.size()>0)
    	{
	    	if(ruleIds.size()>0)
	    	{
	    		reconciledIds = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForTarget(tenantId, groupId, srcTotalIds, dataViewId);
	    	}
			for(BigInteger id : srcTotalIds)
			{
				if(!reconciledIds.contains(id))
				{
					sourceUnreconciledIds.add(id);
				}
			}
    	}
    	finalMap.put("reconciled", reconciledIds);
    	finalMap.put("unReconciled", sourceUnreconciledIds);
    	finalMap.put("totalIds", srcTotalIds);
    	log.info("Source View ID: "+dataViewId+", Total Size: "+srcTotalIds.size());
    	log.info("Source View ID: "+dataViewId+", Reconciled Size: "+reconciledIds.size());
    	log.info("Source View ID: "+dataViewId+", UnReconciled Size: "+sourceUnreconciledIds.size());
		return finalMap;
    }
    
    public Map<String, List<BigInteger>> getSourceRecNUnRecIdsNJobReference(Long dataViewId, Long tenantId, List<BigInteger> srcTotalIds, Long groupId, String jobReference) throws ClassNotFoundException{
    	List<Long> ruleIds = rulesRepository.fetchIdsByViewId(dataViewId, tenantId);
    	Map<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
    	List<BigInteger> reconciledIds = new ArrayList<BigInteger>();
    	List<BigInteger> recIds = new ArrayList<BigInteger>();
    	List<BigInteger> unRecIds = new ArrayList<BigInteger>();
    	if(ruleIds.size()>0)
    	{
    		if(jobReference.length()>0)
    		{
    			reconciledIds = reconciliationResultRepository.fetchOriginalRowIdsBySourceViewIdNJobReference(tenantId, srcTotalIds, groupId,jobReference);	
    			recIds = reconciliationResultRepository.fetchReconciledIdswithJobReferenceForSource(tenantId, groupId, srcTotalIds, jobReference,dataViewId);
    		}
    		else
    		{
    			reconciledIds = reconciliationResultRepository.fetchOriginalRowIdsBySourceViewidNJobReferenceNull(tenantId, srcTotalIds, groupId);
    			recIds = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForSource(tenantId, groupId, srcTotalIds,dataViewId);
    		}
    	}
    	if(srcTotalIds.size()>0)
    	{
    		for(BigInteger id : srcTotalIds)
    		{
    			if(!recIds.contains(id))
    				unRecIds.add(id);
    		}
    	}
    	finalMap.put("reconciled", reconciledIds);
    	finalMap.put("unReconciled", unRecIds);
    	log.info("Source View ID: "+dataViewId+", Total Size: "+srcTotalIds.size());
    	log.info("Source View ID: "+dataViewId+", Reconciled Size: "+reconciledIds.size());
    	log.info("Source View ID: "+dataViewId+", UnReconciled Size: "+unRecIds.size());
		return finalMap;
    }
    
	    /* Get Reconciled Map<String, List<Long>>and UnReconciled Id's for Target*/
		public Map<String, List<BigInteger>> getTargetRecNUnRecIds(Long dataViewId, Long tenantId, List<BigInteger> srcTotalIds,  Long groupId) throws ClassNotFoundException{
		List<Long> ruleIds = rulesRepository.fetchTargetIdsByViewId(dataViewId, tenantId);
		Map<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
		List<BigInteger> reconciledIds = new ArrayList<BigInteger>();
		List<BigInteger> sourceUnreconciledIds = new ArrayList<BigInteger>();
		if(ruleIds.size()>0)
		{
			reconciledIds = reconciliationResultRepository.fetchOriginalRowIdsByTenantIdAndRuleIdsAndTargetViewId(tenantId, ruleIds, dataViewId, groupId);
		}
		if(srcTotalIds.size()>0)
		{
			for(BigInteger id : srcTotalIds)
			{
			
				if(!reconciledIds.contains(id))
				{
					sourceUnreconciledIds.add(id);
				}
			}
		}
		finalMap.put("reconciled", reconciledIds);
		finalMap.put("unReconciled", sourceUnreconciledIds);
		log.info("Target View ID: "+dataViewId+", Total Size: "+srcTotalIds.size());
		log.info("Target View ID: "+dataViewId+", Reconciled Size: "+reconciledIds.size());
		log.info("Target View ID: "+dataViewId+", UnReconciled Size: "+sourceUnreconciledIds.size());
		return finalMap;
	}
    
    /* Get Reconciled Map<String, List<Long>>and UnReconciled Id's for Target*/
    	public Map<String, List<BigInteger>> getTargetRecNUnRecIds(Long dataViewId, Long tenantId, List<BigInteger> srcTotalIds, Long groupId, String jobReference) throws ClassNotFoundException{
    	List<Long> ruleIds = rulesRepository.fetchTargetIdsByViewId(dataViewId, tenantId);
    	Map<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
    	List<BigInteger> reconciledIds = new ArrayList<BigInteger>();
    	List<BigInteger> sourceUnreconciledIds = new ArrayList<BigInteger>();
    	if(ruleIds.size()>0)
    	{
    		if(jobReference.length()>0)
    		{
    			reconciledIds = reconciliationResultRepository.fetchReconciledIdswithJobReferenceForTarget(tenantId, groupId, srcTotalIds, jobReference, dataViewId);
    		}
    		else
    		{
    			reconciledIds = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForTarget(tenantId, groupId, srcTotalIds, dataViewId);
    		}
    	}
    	if(srcTotalIds.size()>0)
    	{
			for(BigInteger id : srcTotalIds)
			{
				if(!reconciledIds.contains(id))
				{
					sourceUnreconciledIds.add(id);
				}
			}
    	}
    	finalMap.put("reconciled", reconciledIds);
    	finalMap.put("unReconciled", sourceUnreconciledIds);
    	log.info("Target View ID: "+dataViewId+", Total Size: "+srcTotalIds.size());
    	log.info("Target View ID: "+dataViewId+", Reconciled Size: "+reconciledIds.size());
    	log.info("Target View ID: "+dataViewId+", UnReconciled Size: "+sourceUnreconciledIds.size());
		return finalMap;
    }
    	
       	public Map<String, List<BigInteger>> getTargetRecNUnRecIdsBatches(Long dataViewId, Long tenantId, List<BigInteger> srcTotalIds, Long groupId) throws ClassNotFoundException{
        	List<Long> ruleIds = rulesRepository.fetchTargetIdsByViewId(dataViewId, tenantId);
        	Map<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
        	List<BigInteger> reconciledIds = new ArrayList<BigInteger>();
        	List<BigInteger> sourceUnreconciledIds = new ArrayList<BigInteger>();
        	if(ruleIds.size()>0)
        	{
        		//reconciledIds = reconciliationResultRepository.fetchReconciledIdswithBatchesForTarget(tenantId, groupId, srcTotalIds);
        	}
        	if(srcTotalIds.size()>0)
        	{
    			for(BigInteger id : srcTotalIds)
    			{
    				if(!reconciledIds.contains(id))
    				{
    					sourceUnreconciledIds.add(id);
    				}
    			}
        	}
        	finalMap.put("reconciled", reconciledIds);
        	finalMap.put("unReconciled", sourceUnreconciledIds);
        	log.info("Target View ID: "+dataViewId+", Total Size: "+srcTotalIds.size());
        	log.info("Target View ID: "+dataViewId+", Reconciled Size: "+reconciledIds.size());
        	log.info("Target View ID: "+dataViewId+", UnReconciled Size: "+sourceUnreconciledIds.size());
    		return finalMap;
        }
       
   
    /* Getting Sum of amount qualifier field */
    public String getAmountSumByIds(List<BigInteger> ids, String qualifierField, BigInteger viewId)
    {
    	String idStr=ids.toString();
    	idStr=idStr.replace("[", "");
    	idStr=idStr.replace("]", "");
    	String res="";
    	if(idStr!=null && !(idStr.isEmpty())){
    		//log.info("Qualifier Filed: "+qualifierField);
    		// Connection to JDBC
    		Connection conn = null;
    		Statement stmt = null;
    		ResultSet result = null; 
        	try{
				DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
				conn = ds.getConnection();
        		stmt = conn.createStatement();
         	    DataViews dv = dataViewsRepository.findById(viewId.longValue());
         	    if(dv != null)
         	    {
         	    	//log.info("SumQuery: SELECT SUM(`"+qualifierField+"`) from `"+dv.getDataViewName().toLowerCase()+"` WHERE scrIds IN ("+idStr+")");
         	    	result=stmt.executeQuery("SELECT SUM(`"+qualifierField+"`) from `"+dv.getDataViewName().toLowerCase()+"` WHERE scrIds IN ("+idStr+")");
         	    	while(result.next()){
         	    		if(result.getString(1) != null)
         	    			res = result.getString(1);
         	    		else
         	    			res = res + "0";
         	    	}
         	    //	log.info("Sum of amount : "+ res);
         	    }
         	    else
         	    {
         	    	res = res + "0";
         	    	log.info("Data View Doesn't Exist");
         	    }   
        	 }catch(SQLException se){
        		   log.info("Error while executing query: "+se);
             }
        	catch(Exception e)
        	{
            	 log.info("Exception while getting databse properties");
        	}
        	finally{
        		try {
            		if(result != null)
            			result.close();	
            		if(stmt != null)
            			stmt.close();
        			if(conn != null)
        				conn.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}	

    		}
    	}
    	else
    	{
    		res = res + "0";
    	}
		return res;
    }
    /* */
    public int getCustomFilterCount(Long viewId, List<BigInteger> ids, String whereString) throws SQLException
    {
    	int totalCount = 0;
    	List<HashMap> finalMap = new ArrayList<HashMap>();
    	String idStr=ids.toString();
    	idStr=idStr.replace("[", "");
    	idStr=idStr.replace("]", "");
		// Connection to JDBC
		Connection conn = null;
		Statement stmt = null;
		ResultSet result = null; 
    	try{
			DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
			conn = ds.getConnection();
    		stmt = conn.createStatement();
     	    DataViews dv = dataViewsRepository.findById(viewId.longValue());
     	    if(dv != null)
     	    {
     	    	result=stmt.executeQuery("SELECT count(*) from `"+dv.getDataViewName().toLowerCase()+"` WHERE scrIds IN ("+idStr+")"+ whereString);
     	    	while(result.next()){
     	    		totalCount = totalCount + result.getInt(1);
     	    	}
     	    }
    	}
    	catch(Exception e)
    	{
    		log.info("Exception "+e);
    	}
    	finally{
    		if(result != null)
    			result.close();	
    		if(stmt != null)
    			stmt.close();
			if(conn != null)
				conn.close();
    	}
    	return totalCount;
    }
    
    public List<BigInteger> getOriginalIdsByColumnSearch(List<BigInteger> ids, String columnSearchQuery, Long viewId) throws SQLException
    {
    	List<BigInteger> finalIds = new ArrayList<BigInteger>();
		Connection conn = null;
		Statement stmt = null;
		ResultSet result = null; 
		
    	String idStr=ids.toString();
    	idStr=idStr.replace("[", "");
    	idStr=idStr.replace("]", "");
    	
    	try{
			DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
			conn = ds.getConnection();
     	    stmt = conn.createStatement();
     	    DataViews dv = dataViewsRepository.findOne(viewId);
     	    if(dv != null)
     	    {
     	    	result=stmt.executeQuery("SELECT scrIds from `"+dv.getDataViewName().toLowerCase()+"` WHERE scrIds in("+idStr+") "+columnSearchQuery);
         	 	while(result.next()){
         	 		finalIds.add(new BigInteger((result.getString(1))));
         	 	}  
     	    }
    	}
    	catch(Exception e)
    	{
    		log.info("Exception "+e);
    	}
    	finally
    	{
    		if(result != null)
    			result.close();	
    		if(stmt != null)
    			stmt.close();
			if(conn != null)
				conn.close();
    	}
    	return finalIds;
    }
    
    public List<BigInteger> getSearchKeywordFilteredOriginalIds(List<BigInteger> ids, String searchKeyWord, String columnAsString, Long viewId) throws SQLException
    {
    	List<BigInteger> finalIds = new ArrayList<BigInteger>();
		Connection conn = null;
		Statement stmt = null;
		ResultSet result = null; 
		String idStr=ids.toString();
    	idStr=idStr.replace("[", "");
    	idStr=idStr.replace("]", "");
    	try{
			DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
			conn = ds.getConnection();
     	    stmt = conn.createStatement();
     	    DataViews dv = dataViewsRepository.findOne(viewId);
     	    if(dv != null)
     	    {
     	    	//log.info("SearchQuery: "+" SELECT scrIds from "+schemaName+"."+dv.getDataViewName().toLowerCase()+" WHERE scrIds in("+idStr+") AND concat("+columnAsString+") LIKE '%"+searchKeyWord+"%'");
     	    	result=stmt.executeQuery("SELECT scrIds from `"+dv.getDataViewName().toLowerCase()+"` WHERE scrIds in("+idStr+") AND concat("+columnAsString+") LIKE '%"+searchKeyWord+"%'");
         	 	while(result.next()){
         	 		finalIds.add(new BigInteger((result.getString(1))));
         	 	}  
     	    }
    	}
    	catch(Exception e)
    	{
    		log.info("Exception "+e);
    	}
    	finally
    	{
    		if(result != null)
    			result.close();	
    		if(stmt != null)
    			stmt.close();
			if(conn != null)
				conn.close();
    	}
    	return finalIds;
    }
    public List<BigInteger> convertLongToBig(List<Long> longIds)
    {
    	List<BigInteger> finalList = new ArrayList<BigInteger>();
    	if(longIds.size()>0)
    	{
    		for(Long id: longIds)
    		{
    			finalList.add(BigInteger.valueOf(id));
    		}
    	}
    	return finalList;
    }
    
    public List<BigInteger> getFilteredIdsForSource(List<BigInteger> ids, Long tenantId, Long dataViewId, Long limit, Long pageSize, HashMap headerColumns, Long groupId, String amtQualifier, String searchWord, String columnAsString, String exportFile, HashMap columnInfo, String sortByOrder, String columnSearchQuery, String statusNRecRefQuery, String status) throws SQLException
    {
    	List<BigInteger> filteredIds = new ArrayList<BigInteger>();
    	String idsString = ids.toString();
    	idsString = idsString.replace("[", "");
    	idsString = idsString.replace("]", "");
    	log.info("Total Ids Size: "+ids.size());
    	log.info("columnSearchQuery: "+columnSearchQuery.length());
    	log.info("statusNRecRefQuery: "+statusNRecRefQuery.length());
    	if(ids.size()>0)
    	{
    		if(columnSearchQuery.length()>0 && statusNRecRefQuery.length()>0)
    		{
    			log.info("Filtering with column search and recon reference/status...");
    			List<BigInteger> colSearchIds = getOriginalIdsByColumnSearch(ids, columnSearchQuery, dataViewId);
    			log.info("Column Search Ids Size: "+colSearchIds.size());
    			if(colSearchIds.size()>0)
    			{
    				String idString = colSearchIds.toString();
    				idString = idString.replace("]", "");
    				idString = idString.replace("[", "");
    				List<Long> recStatusIds = new ArrayList<Long>(); 
    				if("suggestion".equalsIgnoreCase(status))
    				{
    					recStatusIds = em.createQuery("SELECT originalRowId from ReconciliationSuggestionResult where reconciliationRuleGroupId = "+groupId+" and originalViewId = "+dataViewId+" and originalRowId in ("+idString+") "+statusNRecRefQuery + " order by reconReference asc", Long.class).getResultList();
    				}
    				else
    				{
    					recStatusIds = em.createQuery("SELECT originalRowId from ReconciliationResult where reconciliationRuleGroupId = "+groupId+" and originalViewId = "+dataViewId+" and originalRowId in ("+idString+") "+statusNRecRefQuery + " order by reconReference asc", Long.class).getResultList();	
    				}
    				
    				filteredIds.addAll(convertLongToBig(recStatusIds));
    			}
    			log.info("Column and Recon Reference/Status Search Ids Size: "+filteredIds.size());
    		}
    		else if(columnSearchQuery.length() == 0 && statusNRecRefQuery.length()>0)
    		{
    			log.info("Filtering with Status/Recon Reference... ");
    			List<Long> recStatusIds = new ArrayList<Long>(); 
    			if("suggestion".equalsIgnoreCase(status))
    			{
    				recStatusIds = em.createQuery("SELECT originalRowId from ReconciliationSuggestionResult where reconciliationRuleGroupId = "+groupId+" and originalViewId = "+dataViewId+" and originalRowId in ("+idsString+") "+statusNRecRefQuery +" order by reconReference asc",  Long.class).getResultList();
    			}
    			else
    			{
    				recStatusIds = em.createQuery("SELECT originalRowId from ReconciliationResult where reconciliationRuleGroupId = "+groupId+" and originalViewId = "+dataViewId+" and originalRowId in ("+idsString+") "+statusNRecRefQuery +" order by reconReference asc",  Long.class).getResultList();
    			}
    			filteredIds.addAll(convertLongToBig(recStatusIds));
    			log.info("Status/ReconReference Search Ids Size: "+ filteredIds.size());
    		}
    		else if(columnSearchQuery.length()>0 && statusNRecRefQuery.length() == 0)
    		{
    			log.info("Filtering with columns...");
    			List<BigInteger> colSearchIds = new ArrayList<BigInteger>(); 
    			colSearchIds = getOriginalIdsByColumnSearch(ids, columnSearchQuery, dataViewId);
    			filteredIds.addAll(colSearchIds);
    			log.info("Column Search Ids Size: "+ filteredIds.size());
    		}
    		else
    		{
    			log.info("No column or recon reference or status search applying..");
    			filteredIds.addAll(ids);
    		}
    	}
    	return filteredIds;
    }
    
    public List<BigInteger> getFilteredIdsForTarget(List<BigInteger> ids, Long tenantId, Long dataViewId, Long limit, Long pageSize, HashMap headerColumns, Long groupId, String amtQualifier, String searchWord, String columnAsString, String exportFile, HashMap columnInfo, String sortByOrder, String columnSearchQuery, String statusNRecRefQuery, String status) throws SQLException
    {
    	List<BigInteger> filteredIds = new ArrayList<BigInteger>();
    	String idsString = ids.toString();
    	idsString = idsString.replace("[", "");
    	idsString = idsString.replace("]", "");
    	log.info("Total Ids Size: "+ids.size());
    	if(ids.size()>0)
    	{
    		if(columnSearchQuery.length()>0 && statusNRecRefQuery.length()>0)
    		{
    			log.info("Filtering with column search and recon reference/status...");
    			List<BigInteger> colSearchIds = getOriginalIdsByColumnSearch(ids, columnSearchQuery, dataViewId);
    			log.info("Column Search Ids Size: "+colSearchIds.size());
    			if(colSearchIds.size()>0)
    			{
    				String idString = colSearchIds.toString();
    				idString = idString.replace("]", "");
    				idString = idString.replace("[", "");
    				List<Long> recStatusIds = new ArrayList<Long>(); 
    				if("suggestion".equalsIgnoreCase(status))
    				{
    					recStatusIds = em.createQuery("SELECT targetRowId from ReconciliationSuggestionResult where reconciliationRuleGroupId = "+groupId+" and targetViewId = "+dataViewId+" and targetRowId in ("+idString+") "+statusNRecRefQuery+" order by reconReference asc", Long.class).getResultList();		
    				}
    				else
    				{
    					recStatusIds = em.createQuery("SELECT targetRowId from ReconciliationResult where reconciliationRuleGroupId = "+groupId+" and targetViewId = "+dataViewId+" and targetRowId in ("+idString+") "+statusNRecRefQuery+" order by reconReference asc", Long.class).getResultList();
    				}
    				filteredIds.addAll(convertLongToBig(recStatusIds));
    			}
    			log.info("Column and Recon Reference/Status Search Ids Size: "+filteredIds.size());
    		}
    		else if(columnSearchQuery.length() == 0 && statusNRecRefQuery.length()>0)
    		{
    			log.info("Filtering with Status/Recon Reference... ");
    			List<Long> recStatusIds = new ArrayList<Long>(); 
    			if("suggestion".equalsIgnoreCase(status))
    			{
    				recStatusIds = em.createQuery("SELECT targetRowId from ReconciliationSuggestionResult where reconciliationRuleGroupId = "+groupId+" and targetViewId = "+dataViewId+" and targetRowId in ("+idsString+") "+statusNRecRefQuery+" order by reconReference asc", Long.class).getResultList();
    			}
    			else
    			{
    				recStatusIds = em.createQuery("SELECT targetRowId from ReconciliationResult where reconciliationRuleGroupId = "+groupId+" and targetViewId = "+dataViewId+" and targetRowId in ("+idsString+") "+statusNRecRefQuery +" order by reconReference asc", Long.class).getResultList();
    			}
    			filteredIds.addAll(convertLongToBig(recStatusIds));
    			log.info("Recon Reference/Status Search Ids Size: "+filteredIds.size());
    		}
    		else if(columnSearchQuery.length()>0 && statusNRecRefQuery.length() == 0)
    		{
    			log.info("Filtering with columns...");
    			List<BigInteger> colSearchIds = new ArrayList<BigInteger>(); 
    			colSearchIds = getOriginalIdsByColumnSearch(ids, columnSearchQuery, dataViewId);
    			filteredIds.addAll(colSearchIds);
    			log.info("Column Search Ids Size: "+ filteredIds.size());
    		}
    		else
    		{
    			log.info("No column or recon reference or status search applying..");
    			filteredIds.addAll(ids);
    		}
    	}
    	return filteredIds;
    }
    
    public List<LinkedHashMap> getReconData(Map<String, List<BigInteger>> recUnrecIds, String status, Long tenantId, Long dataViewId, Long limit, Long pageSize, HashMap headerColumns, Long groupId, String amtQualifier, String searchWord, String columnAsString, String exportFile, HashMap columnInfo, String sortByOrder, String columnSearchQuery, String statusNRecRefQuery) throws ClassNotFoundException, SQLException, java.text.ParseException
    {
    	List<LinkedHashMap> finalList = new ArrayList<LinkedHashMap>();
    	HashMap info = new HashMap();
    	LinkedHashMap recMain = new LinkedHashMap();
    	
		if("reconciled".equalsIgnoreCase(status) || "suggestion".equalsIgnoreCase(status))
		{
			log.info("Fetching recociled data . .");
	    	List<BigInteger> recIds = recUnrecIds.get("reconciled");
	    	if(recIds.size()>0)
	    	{
	    		if(searchWord != null)
	    		{
	    			log.info("Filtering reconciled data with column search keyword...");
	    			List<BigInteger> searchIds = getSearchKeywordFilteredOriginalIds(recIds, searchWord, columnAsString,dataViewId);
	    			log.info("Reconciled Search Keyword ids: "+searchIds.size());
	    			List<BigInteger> filterIds = getFilteredIdsForSource(searchIds, tenantId, dataViewId, limit, pageSize, headerColumns, groupId, amtQualifier, searchWord, columnAsString, exportFile, columnInfo, sortByOrder, columnSearchQuery, statusNRecRefQuery, status);
	    			if(filterIds.size()>0)
	    			{
	    				finalList = reconciliationResultService.fetchDataByViewIdInSequence(dataViewId, filterIds, limit, pageSize, headerColumns, "source", tenantId, groupId, "", exportFile,columnInfo.get("columnName").toString(),columnInfo.get("dataType").toString(),sortByOrder, status);
	    			}
	    			info.put("totalCount", filterIds.size());
	    		}
	    		else
	    		{
	    			List<BigInteger> filterIds = getFilteredIdsForSource(recIds, tenantId, dataViewId, limit, pageSize, headerColumns, groupId, amtQualifier, searchWord, columnAsString, exportFile, columnInfo, sortByOrder, columnSearchQuery, statusNRecRefQuery, status);
	    			if(filterIds.size()>0)
	    			{
	    				finalList = reconciliationResultService.fetchDataByViewIdInSequence(dataViewId, filterIds, limit, pageSize, headerColumns, "source", tenantId, groupId, "", exportFile,columnInfo.get("columnName").toString(),columnInfo.get("dataType").toString(),sortByOrder,status);
	    			}
	    			info.put("totalCount", filterIds.size());
	    		}
	    	}
	    	info.put("amountQualifier", amtQualifier);
	    	recMain.put("info", info);
	    	finalList.add(recMain);
	    	return finalList;
		}
		else if("unreconciled".equalsIgnoreCase(status))
		{
			log.info("Fetching Un Reconciled data . .");
	    	List<BigInteger> unRecIds = recUnrecIds.get("unReconciled");
	    	if(unRecIds.size()>0)
	    	{
	    		if(searchWord != null)
	    		{
	    			List<BigInteger> searchIds = getSearchKeywordFilteredOriginalIds(unRecIds, searchWord, columnAsString,dataViewId);
	    			log.info("UnReconciled Search Keyword ids: "+searchIds.size());
	    			List<BigInteger> filterIds = getFilteredIdsForSource(searchIds, tenantId, dataViewId, limit, pageSize, headerColumns, groupId, amtQualifier, searchWord, columnAsString, exportFile, columnInfo, sortByOrder, columnSearchQuery, statusNRecRefQuery, status);
	    			if(filterIds.size()>0)
	    			{
	    				finalList = reconciliationResultService.fetchDataByViewIdInSequence(dataViewId, filterIds, limit, pageSize, headerColumns, "source", tenantId, groupId, "", exportFile,columnInfo.get("columnName").toString(),columnInfo.get("dataType").toString(),sortByOrder,status);
	    			}
	    			info.put("totalCount", filterIds.size());
	    		}
	    		else
	    		{
	    			List<BigInteger> filterIds = getFilteredIdsForSource(unRecIds, tenantId, dataViewId, limit, pageSize, headerColumns, groupId, amtQualifier, searchWord, columnAsString, exportFile, columnInfo, sortByOrder, columnSearchQuery, statusNRecRefQuery, status);
	    			if(filterIds.size()>0)
	    			{
	    				log.info("dataViewId: "+dataViewId);
	    				log.info("filterIds: "+filterIds.size());
	    				log.info("columnInfo.get('columnName').toString(): "+columnInfo.get("columnName"));
	    				log.info("columnInfo.get('dataType').toString(): "+columnInfo.get("dataType"));
	    				finalList = reconciliationResultService.fetchDataByViewIdInSequence(dataViewId, filterIds, limit, pageSize, headerColumns, "source", tenantId, groupId, "", exportFile,columnInfo.get("columnName").toString(),columnInfo.get("dataType").toString(),sortByOrder,status);
	    			}
	    			info.put("totalCount", filterIds.size());
	    		}
	    	}
	    	info.put("amountQualifier", amtQualifier);
	    	recMain.put("info", info);
	    	finalList.add(recMain);
	    	return finalList;
		}
		else
		{
			log.info("Fetching total data . .");
	    	List<BigInteger> totalIds = recUnrecIds.get("totalIds");
	    	if(totalIds.size()>0)
	    	{
	    		if(searchWord != null)
	    		{
	    			List<BigInteger> searchIds = getSearchKeywordFilteredOriginalIds(totalIds, searchWord, columnAsString,dataViewId);
	    			log.info("Total Search Keyword ids: "+searchIds.size());
	    			List<BigInteger> filterIds = getFilteredIdsForSource(searchIds, tenantId, dataViewId, limit, pageSize, headerColumns, groupId, amtQualifier, searchWord, columnAsString, exportFile, columnInfo, sortByOrder, columnSearchQuery, statusNRecRefQuery, status);
	    			if(filterIds.size()>0)
	    			{
	    				finalList = reconciliationResultService.fetchDataByViewIdInSequence(dataViewId, filterIds, limit, pageSize, headerColumns, "source", tenantId, groupId, "", exportFile,columnInfo.get("columnName").toString(),columnInfo.get("dataType").toString(),sortByOrder,status);
	    			}
	    			info.put("totalCount", filterIds.size());
	    		}
	    		else
	    		{
	    			List<BigInteger> filterIds = getFilteredIdsForSource(totalIds, tenantId, dataViewId, limit, pageSize, headerColumns, groupId, amtQualifier, searchWord, columnAsString, exportFile, columnInfo, sortByOrder, columnSearchQuery, statusNRecRefQuery, status);
	    			if(filterIds.size()>0)
	    			{
	    				finalList = reconciliationResultService.fetchDataByViewIdInSequence(dataViewId, filterIds, limit, pageSize, headerColumns, "source", tenantId, groupId, "", exportFile,columnInfo.get("columnName").toString(),columnInfo.get("dataType").toString(),sortByOrder,status);
	    			}
	    			info.put("totalCount", filterIds.size());
	    		}
	    	}
	    	info.put("amountQualifier", amtQualifier);
	    	recMain.put("info", info);
	    	finalList.add(recMain);
	    	return finalList;
		}
    }
    
    public List<LinkedHashMap> getReconDataTarget(Map<String, List<BigInteger>> recUnrecIds, String status, Long tenantId, Long dataViewId, Long limit, Long pageSize, HashMap headerColumns, Long groupId, String amtQualifier, String searchWord,String columnAsString, String exportFile, HashMap columnInfo, String sortByOrder, String columnSearchQuery,String statusNRecRefQuery) throws ClassNotFoundException, SQLException, java.text.ParseException
    {
    	List<LinkedHashMap> finalList = new ArrayList<LinkedHashMap>();
    	HashMap info = new HashMap();
    	LinkedHashMap recMain = new LinkedHashMap();
		if("reconciled".equalsIgnoreCase(status) || "suggestion".equalsIgnoreCase(status))
		{
			log.info("Fetching recociled data . .");
	    	List<BigInteger> recIds = recUnrecIds.get("reconciled");
	    	if(recIds.size()>0)
	    	{
	    		if(searchWord != null)
	    		{
	    			List<BigInteger> searchIds = getSearchKeywordFilteredOriginalIds(recIds, searchWord, columnAsString,dataViewId);
	    			List<BigInteger> filterIds = getFilteredIdsForTarget(searchIds, tenantId, dataViewId, limit, pageSize, headerColumns, groupId, amtQualifier, searchWord, columnAsString, exportFile, columnInfo, sortByOrder, columnSearchQuery, statusNRecRefQuery, status);
	    			if(filterIds.size()>0)
	    			{
	    				finalList = reconciliationResultService.fetchDataByViewIdInSequence(dataViewId, filterIds, limit, pageSize, headerColumns, "target", tenantId, groupId, "", exportFile,columnInfo.get("columnName").toString(),columnInfo.get("dataType").toString(),sortByOrder, status);
	    			}
	    			info.put("totalCount", filterIds.size());
	    		}
	    		else
	    		{
	    			List<BigInteger> filterIds = getFilteredIdsForTarget(recIds, tenantId, dataViewId, limit, pageSize, headerColumns, groupId, amtQualifier, searchWord, columnAsString, exportFile, columnInfo, sortByOrder, columnSearchQuery, statusNRecRefQuery, status);
	    			if(filterIds.size()>0)
	    			{
	    				finalList = reconciliationResultService.fetchDataByViewIdInSequence(dataViewId, filterIds, limit, pageSize, headerColumns, "target", tenantId, groupId, "", exportFile,columnInfo.get("columnName").toString(),columnInfo.get("dataType").toString(),sortByOrder, status);
	    			}
	    			info.put("totalCount", filterIds.size());
	    		}
	    	}
	    	info.put("amountQualifier", amtQualifier);
	    	recMain.put("info", info);
	    	finalList.add(recMain);
	    	return finalList;
		}
		else if("unreconciled".equalsIgnoreCase(status))
		{
			log.info("Fetching Un Reconciled data . .");
	    	List<BigInteger> unRecIds = recUnrecIds.get("unReconciled");
	    	if(unRecIds.size()>0)
	    	{
	    		if(searchWord != null)
	    		{
	    			List<BigInteger> searchIds = getSearchKeywordFilteredOriginalIds(unRecIds, searchWord, columnAsString,dataViewId);
	    			List<BigInteger> filterIds = getFilteredIdsForTarget(searchIds, tenantId, dataViewId, limit, pageSize, headerColumns, groupId, amtQualifier, searchWord, columnAsString, exportFile, columnInfo, sortByOrder, columnSearchQuery, statusNRecRefQuery, status);
	    			if(filterIds.size()>0)
	    			{
	    				finalList = reconciliationResultService.fetchDataByViewIdInSequence(dataViewId, filterIds, limit, pageSize, headerColumns, "target", tenantId, groupId, "", exportFile,columnInfo.get("columnName").toString(),columnInfo.get("dataType").toString(),sortByOrder,status);
	    			}
	    			info.put("totalCount", filterIds.size());
	    		}
	    		else
	    		{
	    			List<BigInteger> filterIds = getFilteredIdsForTarget(unRecIds, tenantId, dataViewId, limit, pageSize, headerColumns, groupId, amtQualifier, searchWord, columnAsString, exportFile, columnInfo, sortByOrder, columnSearchQuery, statusNRecRefQuery, status);
	    			if(filterIds.size()>0)
	    			{
	    				finalList = reconciliationResultService.fetchDataByViewIdInSequence(dataViewId, filterIds, limit, pageSize, headerColumns, "target", tenantId, groupId, "", exportFile,columnInfo.get("columnName").toString(),columnInfo.get("dataType").toString(),sortByOrder,status);
	    			}
	    			info.put("totalCount", filterIds.size());
	    		}
	    	}
	    	info.put("amountQualifier", amtQualifier);
	    	recMain.put("info", info);
	    	finalList.add(recMain);
	    	return finalList;
		}
		else
		{
			log.info("Fetching total data . .");
	    	List<BigInteger> totalIds = recUnrecIds.get("totalIds");
	    	if(totalIds.size()>0)
	    	{
	    		if(searchWord != null)
	    		{
	    			List<BigInteger> searchIds = getSearchKeywordFilteredOriginalIds(totalIds, searchWord, columnAsString,dataViewId);
	    			List<BigInteger> filterIds = getFilteredIdsForTarget(searchIds, tenantId, dataViewId, limit, pageSize, headerColumns, groupId, amtQualifier, searchWord, columnAsString, exportFile, columnInfo, sortByOrder, columnSearchQuery, statusNRecRefQuery, status);
	    			if(filterIds.size()>0)
	    			{
	    				finalList = reconciliationResultService.fetchDataByViewIdInSequence(dataViewId, filterIds, limit, pageSize, headerColumns, "target", tenantId, groupId, "", exportFile,columnInfo.get("columnName").toString(),columnInfo.get("dataType").toString(),sortByOrder,status);
	    			}
	    			info.put("totalCount", filterIds.size());
	    		}
	    		else
	    		{
	    			List<BigInteger> filterIds = getFilteredIdsForTarget(totalIds, tenantId, dataViewId, limit, pageSize, headerColumns, groupId, amtQualifier, searchWord, columnAsString, exportFile, columnInfo, sortByOrder, columnSearchQuery, statusNRecRefQuery, status);
	    			if(filterIds.size()>0)
	    			{
	    				finalList = reconciliationResultService.fetchDataByViewIdInSequence(dataViewId, filterIds, limit, pageSize, headerColumns, "target", tenantId, groupId, "", exportFile,columnInfo.get("columnName").toString(),columnInfo.get("dataType").toString(),sortByOrder,status);
	    			}
	    			info.put("totalCount", filterIds.size());
	    		}
	    	}
	    	info.put("amountQualifier", amtQualifier);
	    	recMain.put("info", info);
	    	finalList.add(recMain);
	    	return finalList;
		}
    }
    
    public List<LinkedHashMap> fetchSuggestedFilteredData(Long viewId, Long id, Long groupId, String type, Long tenantId)  throws ClassNotFoundException, SQLException, java.text.ParseException {
    	List<LinkedHashMap> dataMap = new ArrayList<LinkedHashMap>();
    	Connection conn = null;
		Statement stmt = null;
		ResultSet result = null; 
    	try{
			DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
			conn = ds.getConnection();
     	    stmt = conn.createStatement();
     	    log.info("Successfully connected to JDBC");
	     	   String suggestionquery = "";
	     	   if("source".equalsIgnoreCase(type)){
	     		  suggestionquery = "select original_row_id,GROUP_CONCAT(DISTINCT recon_reference ORDER BY recon_reference DESC SEPARATOR ',') as recon_reference,"
							+ "reconciliation_rule_group_id from"
							+ " t_reconciliation_suggestion_result where original_row_id = "+ id
							+ ""+ " and tenant_id = "+ tenantId+ " and original_view_id = "+ viewId
							+ " and reconciliation_rule_group_id = "+ groupId+ ""
							+ " and recon_status = 'RECONCILED' and current_record_flag is true and sign(original_row_id) = 1 "
							+ "group by original_row_id, reconciliation_rule_group_id";
	     	   } else 
	     	   {
	     		  suggestionquery = "select target_row_id,GROUP_CONCAT(DISTINCT recon_reference ORDER BY recon_reference DESC SEPARATOR ',') as recon_reference,"
							+ "reconciliation_rule_group_id from"
							+ " t_reconciliation_suggestion_result where target_row_id = "+ id+ ""
							+ " and tenant_id = "+ tenantId+ " and target_view_id = "+ viewId
							+ " and reconciliation_rule_group_id = "+ groupId+ ""
							+ " and recon_status = 'RECONCILED' and current_record_flag is true and sign(target_row_id) = 1 "
							+ "group by target_row_id, reconciliation_rule_group_id";
	     	   }
				log.info("Query to fetch filtered suggested records: "+ suggestionquery);
				result = stmt.executeQuery(suggestionquery);
		    	while(result.next()){
		    		LinkedHashMap shm = new LinkedHashMap();
		    		if("source".equalsIgnoreCase(type))
		    		{
		    			shm.put("originalRowId", result.getString(1));
		    		}
		    		else
		    		{
		    			shm.put("targetRowId", result.getString(1));	    			
		    		}
		    		shm.put("reconReference", result.getString(2));
		    		shm.put("ruleGroupId", result.getString(3));
//		    		shm.put("ruleId", result.getString(4));
//		    		shm.put("jobReference",result.getString(5));
		    		dataMap.add(shm);
		    	}
     	    
    	}
    	catch(Exception e)
    	{
    		log.info("Exceptin while fetching data: "+ e);
    	}
    	finally
    	{
    		if(result != null)
    			result.close();	
    		if(stmt != null)
    			stmt.close();
			if(conn != null)
				conn.close();
    	}
    	return dataMap;
    }
    
    /*Fetching Reconciliation Data in Sequencing Order*/
    public List<LinkedHashMap> fetchDataByViewIdInSequence(Long viewId, List<BigInteger> ids, Long pageStartIndx, Long pageSize, HashMap headerColumns, String sourceOrTarget, Long tenantId, Long groupId, String whereString, String exportFile, String columnName, String dataType, String sortByOrder, String typeOfReconData) throws ClassNotFoundException, SQLException, java.text.ParseException
    {
    	//log.info("Fetching data based on view id with proper sequence order for the status: "+typeOfReconData);
    	headerColumns.remove("Status");
    	List<LinkedHashMap> finalMap = new ArrayList<LinkedHashMap>();
    	Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
    	String currencyFormat = props.getProperty("currencyFormat");
    	String idStr=ids.toString();
    	idStr = idStr.replace(" ", "");
    	idStr=idStr.replace("[", "");
    	idStr=idStr.replace("]", "");
		Connection conn = null;
		Statement stmt = null;
		ResultSet result = null; 
    	try{
			DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
			conn = ds.getConnection();
     	    stmt = conn.createStatement();
     	    DataViews dv = dataViewsRepository.findById(viewId.longValue());
     	    List<HashMap> dataMap = new ArrayList<HashMap>();

     	    if(dv != null)
     	    {
     	    	if(exportFile != null)
     	    	{
     	    		/*log.info("Fetching data with pagination export file...");*/
     	    		result=stmt.executeQuery("SELECT * from `"+dv.getDataViewName().toLowerCase()+"` WHERE scrIds IN ("+idStr+")");
     	    	}
     	    	else
     	    	{
         	    	/*log.info("Fetching Data with pagination.....");*/
         	    	if(pageSize>0)
         	    		result=stmt.executeQuery("SELECT * from `"+dv.getDataViewName().toLowerCase()+"` WHERE scrIds IN ("+idStr+") order by `"+columnName+"` "+ sortByOrder +" limit "+pageStartIndx+", "+ pageSize);
         	    	else
         	    		result=stmt.executeQuery("SELECT * from `"+dv.getDataViewName().toLowerCase()+"` WHERE scrIds IN ("+idStr+") order by `"+columnName+"` "+ sortByOrder);
     	    	}

     	    	ResultSetMetaData rsmd = result.getMetaData();
     	    	int colCount = rsmd.getColumnCount();
     	    	while(result.next()){
     	    		HashMap hm = new HashMap();
     	    		for(int i=1; i<=colCount; i++)
     	    		{
     	    			hm.put(rsmd.getColumnName(i), result.getString(i));
     	    		}
     	    		dataMap.add(hm);
     	    	}
     	    }
     	    log.info("Shiva DataMap Size: "+dataMap.size());
     	    if(dataMap.size()>0)
    	    {
    	    	for(HashMap hm : dataMap)
    	    	{
    	    		Long id = Long.parseLong(hm.get("scrIds").toString());
    	    		List<LinkedHashMap> reconDataList = new ArrayList<LinkedHashMap>();
    	    		LinkedHashMap reconData = new LinkedHashMap();
    	    		reconData.put("dataRowId", id);
/*   	     	    for(Object key : headerColumns.keySet())
   	     	    {
   	     	    	if(hm.get(key.toString()) != null)
   	     	    	{
   	     	    		reconData.put(headerColumns.get(key.toString()), hm.get(key.toString()));
   	     	    	}
   	     	    }
*/					if ("source".equalsIgnoreCase(sourceOrTarget)) {
						if ("suggestion".equalsIgnoreCase(typeOfReconData)) {
							List<LinkedHashMap> rsDuplicates = new ArrayList<LinkedHashMap>();
							rsDuplicates = fetchSuggestedFilteredData(viewId, id, groupId, "source", tenantId);
							if (rsDuplicates.size() > 0) {
								for (LinkedHashMap rsDuplicate : rsDuplicates) {
									LinkedHashMap recSugg = new LinkedHashMap();
									recSugg = (LinkedHashMap) reconData.clone();
									recSugg.put("reconReference",rsDuplicate.get("reconReference"));
									reconDataList.add(recSugg);
								}
							}
						} else {
							ReconciliationResult rs = reconciliationResultRepository.fetchSourceUniqueRecord(id, tenantId,viewId, groupId);
							if (rs != null) {
								Rules rule = rulesRepository.findOne(rs.getReconciliationRuleId());
								if (rule != null) {
									reconData.put("Rule_Name",rule.getRuleCode());
								} else {
									reconData.put("Rule_Name", "MANUAL");
								}
								reconData.put("Rule Id",rs.getReconciliationRuleId());
								reconData.put("Job Reference",rs.getReconJobReference());
								reconData.put("reconReference",rs.getReconReference());
								reconData.put("Status", "R");
								reconData.put("Final Status",rs.getFinalStatus());
							}
							reconDataList.add(reconData);
						}
					} else if ("target".equalsIgnoreCase(sourceOrTarget)) {
						if ("suggestion".equalsIgnoreCase(typeOfReconData)) {
							List<LinkedHashMap> rsDuplicates = new ArrayList<LinkedHashMap>();
							rsDuplicates = fetchSuggestedFilteredData(viewId, id, groupId, "target", tenantId);
							if (rsDuplicates.size() > 0) {
								for (LinkedHashMap rsDuplicate : rsDuplicates) {
									LinkedHashMap recSugg = new LinkedHashMap();
									recSugg = (LinkedHashMap) reconData.clone();
									recSugg.put("reconReference",rsDuplicate.get("reconReference"));
									reconDataList.add(recSugg);
								}
							}
						} else {
							ReconciliationResult rs = reconciliationResultRepository.fetchTargetUniqueRecord(id, tenantId,viewId, groupId);
							if (rs != null) {
								Rules rule = rulesRepository.findOne(rs.getReconciliationRuleId());
								if (rule != null) 
								{
									reconData.put("Rule_Name",rule.getRuleCode());
								} else {
									reconData.put("Rule_Name", "MANUAL");
								}
								reconData.put("Rule Id",rs.getReconciliationRuleId());
								reconData.put("Job Reference",rs.getReconJobReference());
								reconData.put("reconReference",rs.getReconReference());
								reconData.put("Status", "R");
								reconData.put("Final Status",rs.getFinalStatus());
							}
							reconDataList.add(reconData);
						}
					}
				  finalMap.addAll(reconDataList);
    	    	}
    	    }
	   	}
	   	catch(Exception e)
	   	{
	   		log.info("Exceptin while fetching data: "+ e);
	   	}
	   	finally
	   	{
	   		if(result != null)
	   			result.close();	
	   		if(stmt != null)
	   			stmt.close();
				if(conn != null)
					conn.close();
	   	}
	   	return finalMap;
   }
    
    /*Getting View Name based on View Id*/
    public String getViewNameByViewId(Long viewId)
    {
    	String dataViewName = "";
    	DataViews dv = dataViewsRepository.findOne(viewId);
    	if(dv != null)
    	{
    		dataViewName = dv.getDataViewDispName();
    	}
    	log.info("View Id : " + viewId+", View Name: "+ dataViewName);
    	return dataViewName;
    }
    public String getColumnsAsString(HashMap colsMap)
    {
    	String finalString = "";
    	Iterator it = colsMap.entrySet().iterator();
    	while (it.hasNext()) {
    	        Map.Entry pair = (Map.Entry)it.next();
    	        // System.out.println(pair.getKey() + " = " + pair.getValue());
    	        finalString = finalString+"dv.`"+pair.getKey().toString()+"`,";
    	        //it.remove();
    	}
    	finalString = finalString.substring(0, finalString.length()-1);
    	return finalString;
    }
    
    public HashMap getColumnInfobyId(Long colId)
    {
    	HashMap finalMap = new HashMap();
		DataViewsColumns dc = dataViewsColumnsRepository.findOne(colId);
		if(dc != null)
		{
			if("File Template".equalsIgnoreCase(dc.getRefDvType()))
			{
				FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dc.getRefDvColumn().toString()));
				if(ftl != null)
				{
					// finalMap.put(ftl.getColumnAlias(), dc.getColumnName());
					finalMap.put("columnAlias", ftl.getColumnAlias());
				}
			}
			else if("Data View".equalsIgnoreCase(dc.getRefDvType()) || dc.getRefDvType() == null)
			{
				//finalMap.put(dc.getColumnName(), dc.getColumnName());
				finalMap.put("columnAlias", dc.getColumnName());
			}
		}
		log.info("finalMap: "+finalMap);
		return finalMap;
    }
    
    public HashMap getColumnInfobyIds(List<BigInteger> colIds)
    {
    	HashMap finalMap = new HashMap();
		for(BigInteger id : colIds)
		{
			DataViewsColumns dc = dataViewsColumnsRepository.findOne(id.longValue());
			if(dc != null)
			{
				if("File Template".equalsIgnoreCase(dc.getRefDvType()))
				{
					FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dc.getRefDvColumn().toString()));
					if(ftl != null)
					{
						finalMap.put(ftl.getColumnAlias(), dc.getColumnName());
					}
				}
				else if("Data View".equalsIgnoreCase(dc.getRefDvType()) || dc.getRefDvType() == null)
				{
					finalMap.put(dc.getColumnName(), dc.getColumnName());
				}
			}
		}
		log.info("finalMap: "+finalMap);
		return finalMap;
    }
    
    public HashMap<BigInteger, String> getRecSequenceColumns(Long viewId, Long groupId, Long tenantId, String sourceOrTarget)
    {
    	HashMap<BigInteger, String> seqCols = new HashMap<BigInteger, String>();
    	log.info("In service for getting column headers in sequence");
    	List<BigInteger> ruleIds = ruleGroupDetailsRepository.fetchRuleIdsByGroupAndTenantId(groupId, tenantId);
    	log.info("Rule Ids "+ ruleIds+" for the group id "+ groupId);
    	if(ruleIds.size()>0)
    	{
    		if("source".equalsIgnoreCase(sourceOrTarget))
    		{
    			log.info("In Source : "+ viewId);
    			List<BigInteger> ids = rulesRepository.fetchIdsBySourceViewIdAndIds(tenantId, viewId, ruleIds);
    			log.info("Rule Ids "+ ids +" tagged to source view id"+ viewId);
    			if(ids.size()>0)
    			{
    				List<BigInteger> sColumnIds = ruleConditionsRepository.fetchSourceColumnIdsByRuleIds(ids);
    				log.info("Source Column Ids: "+ sColumnIds+" for Source View Id: "+viewId);
    				if(sColumnIds.size()>0 && !sColumnIds.contains(null))
    				{
    		   			for(BigInteger id : sColumnIds)
    		   			{
    		   				DataViewsColumns dc = dataViewsColumnsRepository.findOne(id.longValue());
    		   				if(dc != null)
    		   				{
    							if("File Template".equalsIgnoreCase(dc.getRefDvType()))
    							{
        							FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dc.getRefDvColumn().toString()));
        							if(ftl != null)
        							{
        								seqCols.put(id, ftl.getColumnAlias());
        							}
    							}
    							else if("Data View".equalsIgnoreCase(dc.getRefDvType()) || dc.getRefDvType() == null)
    							{
    								seqCols.put(id, dc.getColumnName());
    							}
    		   				}
    		   			}
    				}
    			}
    		}
    		else if("target".equalsIgnoreCase(sourceOrTarget))
    		{
    			log.info("In Target : "+ viewId);
    			List<BigInteger> ids = rulesRepository.fetchIdsByTargetViewIdAndIds(tenantId, viewId, ruleIds);
    			log.info("Rule Ids "+ ids + " which are tagged to target view id : "+ ids);
    			if(ids.size()>0)
    			{
    				List<BigInteger> tColumnIds = ruleConditionsRepository.fetchTargetColumnIdsByRuleIds(ids);
    				log.info("Target view id "+viewId+"Target Column Ids: "+ tColumnIds);
    				if(tColumnIds.size()>0 && !tColumnIds.contains(null))
    				{
    		   			for(BigInteger id : tColumnIds)
    		   			{
    		   				DataViewsColumns dc = dataViewsColumnsRepository.findOne(id.longValue());
    		   				if(dc != null)
    		   				{		 
       							if("File Template".equalsIgnoreCase(dc.getRefDvType()))
    							{
        							FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dc.getRefDvColumn().toString()));
        							if(ftl != null)
        							{
        								seqCols.put(id, ftl.getColumnAlias());
        							}
    							}
    							else if("Data View".equalsIgnoreCase(dc.getRefDvType()) || dc.getRefDvType() == null)
    							{
    								seqCols.put(id, dc.getColumnName());
    							}
    		   				}
    		   			}	
    				}
    			}
    		}
    	}
    	return seqCols;
    }
    /*Getting data view column alias names in sequence order*/
    public List<String> getViewColumnHeadersInSequence(Long viewId, Long groupId, Long tenantId, String sourceOrTarget)
    {
    	log.info("In service for getting column headers in sequence");
    	List<String> colNames = new ArrayList<String>();
    	List<BigInteger> ruleIds = ruleGroupDetailsRepository.fetchRuleIdsByGroupAndTenantId(groupId, tenantId);
    	log.info("Rule Ids "+ ruleIds+" for the group id "+ groupId);
    	List<BigInteger> allViewColIds = dataViewsColumnsRepository.fetchIdsByDataViewId(viewId);
    	log.info("All View Column Ids: "+ allViewColIds);
    	List<String> sysColumns = new ArrayList<String>();
    	sysColumns.add("Recon Ref Id");
    	sysColumns.add("Status");
    	List<BigInteger> remainingSequence = new ArrayList<BigInteger>();
    	if(ruleIds.size()>0)
    	{
    		if("source".equalsIgnoreCase(sourceOrTarget))
    		{
    			log.info("In Source : "+ viewId);
    			List<BigInteger> ids = rulesRepository.fetchIdsBySourceViewIdAndIds(tenantId, viewId, ruleIds);
    			log.info("Rule Ids "+ ids +" tagged to source view id"+ viewId);
    			if(ids.size()>0)
    			{
    				List<BigInteger> sColumnIds = ruleConditionsRepository.fetchSourceColumnIdsByRuleIds(ids);
    				sColumnIds.remove(null);
    				log.info("Source Column Ids: "+ sColumnIds+" for Source View Id: "+viewId);
    				if(sColumnIds.size()>0)
    				{
    	    			List<String> dvc = dataViewsColumnsRepository.fetchFileTemplateLineIdsByIds(sColumnIds);
    	    			List<String> seqColumns = new ArrayList<String>();
    	    	    	if(dvc.size()>0)
    	    	    	{
    	    	    		List<Long> idsAsLong = new ArrayList<Long>();
    	    	    		for(String idString : dvc)
    	    	    		{
    	    	    			idsAsLong.add(Long.parseLong(idString));
    	    	    		}
    	    	    		seqColumns = fileTemplateLinesRepository.fetchColumnAliasByIds(idsAsLong);
    	    	    		log.info("Sequence Columns "+ seqColumns);
    	    	    		colNames.addAll(seqColumns);
    	    	    	}
    				}
    				colNames.addAll(sysColumns);
    				log.info("System Columns: "+sysColumns);
    				if(allViewColIds.size()>0)
    				{
    					for(BigInteger id : allViewColIds)
    					{
    						if(!sColumnIds.contains(id))
    						{
    							remainingSequence.add(id);
    						}
    					}
    				}
    				log.info("Sourece View id: "+ viewId + ", Remaining Column Ids: "+ remainingSequence);
    				if(remainingSequence.size()>0)
    				{
    	    			List<String> dvc = dataViewsColumnsRepository.fetchFileTemplateLineIdsByIds(remainingSequence);
    	    			List<String> remainingColumns = new ArrayList<String>();
    	    	    	if(dvc.size()>0)
    	    	    	{
    	    	    		List<Long> idsAsLong = new ArrayList<Long>();
    	    	    		for(String idString : dvc)
    	    	    		{
    	    	    			idsAsLong.add(Long.parseLong(idString));
    	    	    		}
    	    	    		remainingColumns = fileTemplateLinesRepository.fetchColumnAliasByIds(idsAsLong);
    	    	    		log.info("Remaining Columns "+ remainingColumns);
    	    	    		colNames.addAll(remainingColumns);
    	    	    	}
    	    	    	log.info("Source View Id: "+ viewId + ", Remaining Columns: "+ remainingColumns);
    				}
    			}
    		}
    		else if("target".equalsIgnoreCase(sourceOrTarget))
    		{
    			log.info("In Target : "+ viewId);
    			List<BigInteger> ids = rulesRepository.fetchIdsByTargetViewIdAndIds(tenantId, viewId, ruleIds);
    			log.info("Rule Ids "+ ids + " which are tagged to target view id : "+ ids);
    			if(ids.size()>0)
    			{
    				List<BigInteger> tColumnIds = ruleConditionsRepository.fetchTargetColumnIdsByRuleIds(ids);
    				tColumnIds.remove(null);
    				log.info("Target view id "+viewId+"Target Column Ids: "+ tColumnIds);
    				if(tColumnIds.size()>0)
    				{
    	    			List<String> dvc = dataViewsColumnsRepository.fetchFileTemplateLineIdsByIds(tColumnIds);
    	    			List<String> seqColumns = new ArrayList<String>();
    	    	    	if(dvc.size()>0)
    	    	    	{
    	    	    		List<Long> idsAsLong = new ArrayList<Long>();
    	    	    		for(String idString : dvc)
    	    	    		{
    	    	    			idsAsLong.add(Long.parseLong(idString));
    	    	    		}
    	    	    		seqColumns = fileTemplateLinesRepository.fetchColumnAliasByIds(idsAsLong);
    	    	    		log.info("Target View Id"+viewId+"Sequence Columns "+ seqColumns);
    	    	    		colNames.addAll(seqColumns);
    	    	    	}
    				}
    				colNames.addAll(sysColumns);
    				log.info("System Columns Columns "+ sysColumns);
    				if(allViewColIds.size()>0)
    				{
    					for(BigInteger id : allViewColIds)
    					{
    						if(!tColumnIds.contains(id))
    						{
    							remainingSequence.add(id);
    						}
    					}
    				}
    				log.info("View Id : "+ viewId + ", Remaining Column Ids "+ remainingSequence);
    				if(remainingSequence.size()>0)
    				{
    	    			List<String> dvc = dataViewsColumnsRepository.fetchFileTemplateLineIdsByIds(remainingSequence);
    	    			List<String> remainingColumns = new ArrayList<String>();
    	    	    	if(dvc.size()>0)
    	    	    	{
    	    	    		List<Long> idsAsLong = new ArrayList<Long>();
    	    	    		for(String idString : dvc)
    	    	    		{
    	    	    			idsAsLong.add(Long.parseLong(idString));
    	    	    		}
    	    	    		remainingColumns = fileTemplateLinesRepository.fetchColumnAliasByIds(idsAsLong);
    	    	    		log.info("Target View Id "+viewId+"Remaining Columns "+ remainingColumns);
    	    	    		colNames.addAll(remainingColumns);
    	    	    	}
    				}
    			}
    		}
    	}
    	else
    	{
    		log.info("No Rule Ids found for the group id: "+ groupId);
    	}
    	return colNames;
    }
    
    public String getColumnNamesAsString(Long dataViewId)
    {
    	String columnString = "";
    	List<DataViewsColumns> dvcs = dataViewsColumnsRepository.findByDataViewId(dataViewId);
    	if(dvcs.size()>0)
    	{
    		for(DataViewsColumns dvc : dvcs)
    		{
				if("File Template".equalsIgnoreCase(dvc.getRefDvType()))
				{
					FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dvc.getRefDvColumn().toString()));
					if(ftl != null)
					{
						columnString = columnString + ftl.getColumnAlias()+", ";
					}
				}
				else if("Data View".equalsIgnoreCase(dvc.getRefDvType()) || dvc.getRefDvType() == null)
				{
					columnString = columnString + dvc.getColumnName()+", ";
				}
    		}
    		columnString = columnString.substring(0, columnString.length()-2);
    		//log.info("Column As String: "+ columnString);
    	}
    	return columnString;
    }
    
    
    /*Getting data view column alias and names map in sequence order*/
    public LinkedHashMap getColHeadersMapInSequence(Long viewId, Long groupId, Long tenantId, String sourceOrTarget)
    {
    	log.info("In service for getting column headers in sequence");
    	LinkedHashMap finalMap = new LinkedHashMap();
    	//List<String> colNames = new ArrayList<String>();
    	List<BigInteger> ruleIds = ruleGroupDetailsRepository.fetchRuleIdsByGroupAndTenantId(groupId, tenantId);
    	log.info("Rule Ids "+ ruleIds+" for the group id "+ groupId);
    	List<BigInteger> allViewColIds = dataViewsColumnsRepository.fetchIdsByDataViewId(viewId);
    	log.info("All View Column Ids: "+ allViewColIds);
    	List<BigInteger> remainingSequence = new ArrayList<BigInteger>();
    	if(ruleIds.size()>0)
    	{
    		if("source".equalsIgnoreCase(sourceOrTarget))
    		{
    			log.info("In Source : "+ viewId);
    			List<BigInteger> ids = rulesRepository.fetchIdsBySourceViewIdAndIds(tenantId, viewId, ruleIds);
    			log.info("Rule Ids "+ ids +" tagged to source view id"+ viewId);
    			if(ids.size()>0)
    			{
    				List<BigInteger> sColumnIds = ruleConditionsRepository.fetchSourceColumnIdsByRuleIds(ids);
    				sColumnIds.remove(null);
    				log.info("Source Column Ids: "+ sColumnIds+" for Source View Id: "+viewId);
    				finalMap.put("Recon Ref Id", "Recon Ref Id");
    				if(sColumnIds.size()>0)
    				{
    					for(BigInteger colId : sColumnIds)
    					{
    						DataViewsColumns dvc = dataViewsColumnsRepository.findOne(colId.longValue());
    						if(dvc != null)
    						{
    							if("File Template".equalsIgnoreCase(dvc.getRefDvType()))
    							{
        							FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dvc.getRefDvColumn().toString()));
        							if(ftl != null)
        							{
        								finalMap.put(ftl.getColumnAlias(), dvc.getColumnName());
        							}
    							}
    							else if("Data View".equalsIgnoreCase(dvc.getRefDvType()) || dvc.getRefDvType() == null)
    							{
    								finalMap.put(dvc.getColumnName(), dvc.getColumnName());
    							}
    						}
    					}
    				}
    				finalMap.put("Rule_Name", "Rule_Name");
    				finalMap.put("rowDescription", "rowDescription");
    				finalMap.put("adjustmentType", "adjustmentType");
    				finalMap.put("Status", "Status");
    				if(allViewColIds.size()>0)
    				{
    					for(BigInteger id : allViewColIds)
    					{
    						if(!sColumnIds.contains(id))
    						{
    							remainingSequence.add(id);
    						}
    					}
    				}
    				log.info("Sourece View id: "+ viewId + ", Remaining Column Ids: "+ remainingSequence);
    				if(remainingSequence.size()>0)
    				{
       					for(BigInteger colId : remainingSequence)
    					{
    						DataViewsColumns dvc = dataViewsColumnsRepository.findOne(colId.longValue());
    						if(dvc != null)
    						{
    							if("File Template".equalsIgnoreCase(dvc.getRefDvType()))
    							{
	    							FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dvc.getRefDvColumn().toString()));
	    							if(ftl != null)
	    							{
	    								finalMap.put(ftl.getColumnAlias(), dvc.getColumnName());
	    							}
    							}
       							else if("Data View".equalsIgnoreCase(dvc.getRefDvType()) || dvc.getRefDvType() == null)
    							{
    								finalMap.put(dvc.getColumnName(), dvc.getColumnName());
    							}
    						}
    					}
    				}
    			}
    		}
    		else if("target".equalsIgnoreCase(sourceOrTarget))
    		{
    			log.info("In Target : "+ viewId);
    			List<BigInteger> ids = rulesRepository.fetchIdsByTargetViewIdAndIds(tenantId, viewId, ruleIds);
    			log.info("Rule Ids "+ ids + " which are tagged to target view id : "+ ids);
    			if(ids.size()>0)
    			{
    				List<BigInteger> tColumnIds = ruleConditionsRepository.fetchTargetColumnIdsByRuleIds(ids);
    				tColumnIds.remove(null);
    				log.info("Target view id "+viewId+"Target Column Ids: "+ tColumnIds);
    				finalMap.put("Recon Ref Id", "Recon Ref Id");
    				if(tColumnIds.size()>0)
    				{
    					for(BigInteger colId : tColumnIds)
    					{
    						DataViewsColumns dvc = dataViewsColumnsRepository.findOne(colId.longValue());
    						if(dvc != null)
    						{
    							if("File Template".equalsIgnoreCase(dvc.getRefDvType()))
    							{
	    							FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dvc.getRefDvColumn().toString()));
	    							if(ftl != null)
	    							{
	    								finalMap.put(ftl.getColumnAlias(), dvc.getColumnName());
	    							}
    							}
       							else if("Data View".equalsIgnoreCase(dvc.getRefDvType()) || dvc.getRefDvType() == null)
    							{
       								finalMap.put(dvc.getColumnName(), dvc.getColumnName());
    							}
    						}
    					}
    				}
    				finalMap.put("Rule_Name", "Rule_Name");
    				finalMap.put("rowDescription", "rowDescription");
    				finalMap.put("adjustmentType", "adjustmentType");
    				finalMap.put("Status", "Status");
    				if(allViewColIds.size()>0)
    				{
    					for(BigInteger id : allViewColIds)
    					{
    						if(!tColumnIds.contains(id))
    						{
    							remainingSequence.add(id);
    						}
    					}
    				}
    				log.info("View Id : "+ viewId + ", Remaining Column Ids "+ remainingSequence);
    				if(remainingSequence.size()>0)
    				{
    					for(BigInteger colId : remainingSequence)
    					{
    						DataViewsColumns dvc = dataViewsColumnsRepository.findOne(colId.longValue());
    						if(dvc != null)
    						{
    							if("File Template".equalsIgnoreCase(dvc.getRefDvType()))
    							{
	    							FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dvc.getRefDvColumn().toString()));
	    							if(ftl != null)
	    							{
	    								finalMap.put(ftl.getColumnAlias(), dvc.getColumnName());
	    							}
    							}
       							else if("Data View".equalsIgnoreCase(dvc.getRefDvType()) || dvc.getRefDvType() == null)
    							{
       								finalMap.put(dvc.getColumnName(), dvc.getColumnName());
    							}
    						}
    					}
    				}
    			}
    		}
    	}
    	else
    	{
    		log.info("No Rule Ids found for the group id: "+ groupId);
    	}
    	return finalMap;
    }
    
    /*Building Query based on custom column filters*/
   public String buildCustomQuery(List<FilterColumns> filterCols, Long viewId)
    {
	    String whereString = "";
	    if(filterCols.size()>0)
	    {
	    	try{
		        for(FilterColumns fc : filterCols)
		        {
		        	String colDataType = "";
		        	String col = "";
		        	log.info("ViewId: "+ viewId+", ColumnName: "+fc.getColumnName());
		        	DataViewsColumns dvc = dataViewsColumnsRepository.findByDataViewIdAndColumnName(viewId, fc.getColumnName());
		        	if(dvc != null)
		        	{
		        		colDataType = colDataType+dvc.getColDataType();
		        		if("File Template".equalsIgnoreCase(dvc.getRefDvType()))
						{
			        		FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dvc.getRefDvColumn()));
			        		if(ftl != null)
			        		{
			        			col = ftl.getColumnAlias();
			        		}
						}
						else if("Data View".equalsIgnoreCase(dvc.getRefDvType()) || dvc.getRefDvType() == null)
						{
								col = dvc.getColumnName();
						}
		        	}
		        	else
		        	{
		        		log.info("Custom col found");
		        		whereString=whereString+"custom column";
		        	}
		        	if(colDataType!=null && !(colDataType.isEmpty()) && "VARCHAR".equalsIgnoreCase(colDataType) || "STRING".equalsIgnoreCase(colDataType))
		        	{
		        		log.info("Building query string");
		        		String columnValue = fc.getColumnValue();
		        		columnValue = "'"+columnValue.replace(",", "','")+"'";
		        		if("=".equalsIgnoreCase(fc.getOperator()) || "EQUALS".equals(fc.getOperator()))
		        		{
		        			whereString = whereString + " AND "+ col + " IN ("+columnValue+")";
		        		}
		        		else if("!=".equalsIgnoreCase(fc.getOperator()) || "NOT_EQUALS".equalsIgnoreCase(fc.getOperator()))
		        		{
		        			whereString = whereString + " AND "+ col + " NOT IN ("+columnValue+")";
		        		}
		        		else if("CONTAINS".equalsIgnoreCase(fc.getOperator()))
		        		{
		        			whereString = whereString + " AND "+col+" LIKE '%"+fc.getColumnValue()+"%'";
		        			whereString = whereString + " AND "+col+" REGEXP '"+fc.getColumnValue().replace(",", "|")+"'";
		        		}
		        		else if("BEGINS_WITH".equalsIgnoreCase(fc.getOperator()))
		        		{
		        			whereString = whereString + " AND "+col +" LIKE '"+fc.getColumnValue()+"%'";
		        		}
		        		else if("ENDS_WITH".equalsIgnoreCase(fc.getOperator()))
		        		{
		        			whereString = whereString + " AND " + col + " LIKE '%"+fc.getColumnValue()+"'";
		        		}
		        	}
		        	else if(colDataType!=null && !(colDataType.isEmpty()) && "INTEGER".equalsIgnoreCase(colDataType) || "NUMBER".equalsIgnoreCase(colDataType) || "DECIMAL".equalsIgnoreCase(colDataType))
		        	{
		        		log.info("Building query integer");
		        		if("=".equalsIgnoreCase(fc.getOperator()) || "EQUALS".equalsIgnoreCase(fc.getOperator()))
		        		{
		        			whereString = whereString + " AND "+ col + " IN("+fc.getColumnValue()+")";
		        		}
		        		else if("!=".equalsIgnoreCase(fc.getOperator()) || "NOT_EQUALS".equalsIgnoreCase(fc.getOperator()))
		        		{
		        			whereString = whereString + " AND "+ col + " NOT IN("+fc.getColumnValue()+")";
		        		}
		        		else if("BETWEEN".equalsIgnoreCase(fc.getOperator()))
		        		{
		        			String[] dateRange = fc.getColumnValue().toString().split("\\,");
		        			whereString = whereString + " AND (" + col + " BETWEEN "+dateRange[0]+" AND "+dateRange[1]+")";
		        		}
		        		else
		        		{
		        			whereString = whereString + " AND "+ col + " "+ fc.getOperator()+ " " + fc.getColumnValue();
		        		}
		        	}
		        	else if(colDataType!=null && !(colDataType.isEmpty()) && "DATE".equalsIgnoreCase(colDataType) || "DATETIME".equalsIgnoreCase(colDataType))
		        	{
		        		log.info("Building query date");
		        		String columnValue = fc.getColumnValue();
		        		columnValue = "'"+columnValue.replace(",", "','")+"'";
		        		if("=".equalsIgnoreCase(fc.getOperator()) || "EQUALS".equalsIgnoreCase(fc.getOperator()))
		        		{
		        			whereString = whereString + " AND " + col + " IN("+columnValue+")";
		        		}
		        		else if("!=".equalsIgnoreCase(fc.getOperator()) || "NOT_EQUALS".equalsIgnoreCase(fc.getOperator()))
		        		{
		        			whereString = whereString + " AND " + col + " NOT IN("+ columnValue +")";
		        		}
		        		else if("BETWEEN".equalsIgnoreCase(fc.getOperator()))
		        		{
		        			String[] dateRange = fc.getColumnValue().split("\\,");
		        			whereString = whereString + " AND ("+col+" BETWEEN '"+dateRange[0]+"' AND '"+ dateRange[1]+"')";
		        		}
		        		else
		        		{
		        			whereString = whereString + " AND "+col+fc.getOperator()+columnValue;
		        		}
		        	}
		        }
	    	}
	    	catch(Exception e)
	    	{
	    		log.info("Error while building query"+e);
	    	}
	    }
	    log.info("Final Where String in Service: "+ whereString);
    	return whereString;
    }
       
   public String getAmountInFormat(String value, String currencyType)
    {
    	String valueInCurrency = "";
    	if("US".equalsIgnoreCase(currencyType))
    	{
    		if(value.length()>0)
    		{
    			valueInCurrency = valueInCurrency+String.format("%,.2f", Double.parseDouble(value));
    		}
    	}
    	if(valueInCurrency.length() == 0)
    	{
    		valueInCurrency = valueInCurrency + "0";
    	}
    	return valueInCurrency;
    }
   
   public List<HashMap> getRecColsAlignInfo(Long viewId, Long groupId, Long tenantId, String sourceOrTarget, String status, String type, Long ruleId, String groupBy)
   {
   	log.info("In service for getting column headers in sequence");
   	List<HashMap> finalMap = new ArrayList<HashMap>();
   	List<BigInteger> ruleIds = ruleGroupDetailsRepository.fetchRuleIdsByGroupAndTenantId(groupId, tenantId);
   	log.info("Rule Ids "+ ruleIds+" for the group id "+ groupId);
   	List<BigInteger> allViewColIds = dataViewsColumnsRepository.fetchIdsByDataViewId(viewId);
   	log.info("All View Column Ids: "+ allViewColIds);
   	List<BigInteger> remainingSequence = new ArrayList<BigInteger>();
   	if(ruleIds.size()>0)
   	{
   		if(type.toLowerCase().contains("summary")) 
   		{
   			if("reconciled".equalsIgnoreCase(status))
   			{
   				HashMap reconRefMp = new HashMap();
		   			reconRefMp.put("field", "reconReference");
		   			reconRefMp.put("header", "Recon Reference");
		   			reconRefMp.put("columnName", "recon_reference");
		   			reconRefMp.put("align", "left");
		   			reconRefMp.put("width", "150px");
		   			reconRefMp.put("colId", "recon_reference");
		   			reconRefMp.put("dataType", "STRING");
		   			finalMap.add(reconRefMp);
		   			if("rules".equalsIgnoreCase(groupBy))
		   			{
		   				HashMap ruleMp = new HashMap();
		   				ruleMp.put("field", "groupByColumn");
		   				ruleMp.put("header", "Rule Name");
		   				ruleMp.put("columnName", "rule_code");
		   				ruleMp.put("align", "left");
		   				ruleMp.put("width", "150px");
		   				ruleMp.put("colId", "rule_code");
		   				ruleMp.put("dataType", "STRING");
			   			finalMap.add(ruleMp);
		   			}
		   			else if("batch".equalsIgnoreCase(groupBy))
		   			{
		   				HashMap batchMp = new HashMap();
		   				batchMp.put("field", "groupByColumn");
		  				batchMp.put("header", "Batch");
		   				batchMp.put("columnName", "recon_job_reference");
		   				batchMp.put("align", "left");
		   				batchMp.put("width", "150px");
		   				batchMp.put("colId", "recon_job_reference");
		   				batchMp.put("dataTygetColAlignInfope", "STRING");
		   				finalMap.add(batchMp);		   				
		   			}
		   			else if("approvalRule".equalsIgnoreCase(groupBy))
		   			{
		   				HashMap apprRuleMp = new HashMap();
		   				apprRuleMp.put("field", "groupByColumn");
		   				apprRuleMp.put("header", "Approval Rule");
		   				apprRuleMp.put("columnName", "rule_code");
		   				apprRuleMp.put("align", "left");
		   				apprRuleMp.put("width", "150px");
		   				apprRuleMp.put("colId", "rule_code");
		   				apprRuleMp.put("dataType", "STRING");
		   				finalMap.add(apprRuleMp);		   				
		   			}
		   			else if("approvalDate".equalsIgnoreCase(groupBy))
		   			{
		   				HashMap apprDateMp = new HashMap();
		   				apprDateMp.put("field", "groupByColumn");
		   				apprDateMp.put("header", "Approval Date");
		   				apprDateMp.put("columnName", "final_action_date");
		   				apprDateMp.put("align", "left");
		   				apprDateMp.put("width", "150px");
		   				apprDateMp.put("colId", "final_action_date");
		   				apprDateMp.put("dataType", "DATE");
		   				finalMap.add(apprDateMp);		   				
		   			}
		   			else if("approvalStatus".equalsIgnoreCase(groupBy))
		   			{
		   				HashMap apprStatusMp = new HashMap();
		   				apprStatusMp.put("field", "groupByColumn");
		   				apprStatusMp.put("header", "Approval Status");
		   				apprStatusMp.put("columnName", "final_status");
		   				apprStatusMp.put("align", "left");
		   				apprStatusMp.put("width", "150px");
		   				apprStatusMp.put("colId", "final_status");
		   				apprStatusMp.put("dataType", "STRING");
		   				finalMap.add(apprStatusMp);
		   			}
		   			else
		   			{
		   				DataViewsColumns dvc = dataViewsColumnsRepository.findByDataViewIdAndQualifier(viewId, "CURRENCYCODE");
		   				if(dvc != null)
		   				{
		   					HashMap mp = getColNameNType(dvc.getId());
			   				HashMap colMp = new HashMap();
			   				colMp.put("field", "groupByColumn");
			   				colMp.put("header", mp.get("displayColName").toString());
			   				colMp.put("columnName", mp.get("columnName").toString());
			   				colMp.put("align", "left");
			   				colMp.put("width", "150px");
			   				colMp.put("colId", mp.get("columnName").toString());
			   				colMp.put("dataType", "STRING");
			   				finalMap.add(colMp);
		   				}
		   			}
	   			HashMap countRefMp = new HashMap();
		   	   		countRefMp.put("field", "count");
		   	   		countRefMp.put("header", "Transaction Count");
		   	   		countRefMp.put("align", "center");
		   	   		countRefMp.put("width", "150px");
		   	   		countRefMp.put("colId", "");
		   	   		countRefMp.put("dataType", "STRING");
		   	   		finalMap.add(countRefMp);
		   	   	HashMap amountRefMp = new HashMap();
			   	   	amountRefMp.put("field", "amount");
			   	   	amountRefMp.put("header", "Reconciled Amount");
			   	   	amountRefMp.put("align", "right");
			   	   	amountRefMp.put("width", "150px");
			   	   	amountRefMp.put("colId", "");
			   	   	amountRefMp.put("dataType", "DECIMAL");
		   	   		finalMap.add(amountRefMp);
		   	   	HashMap varianceRefMp = new HashMap();
	   				varianceRefMp.put("field", "varianceAmount");
	   				varianceRefMp.put("header", "Variance Amount");
	   				varianceRefMp.put("align", "right");
	   				varianceRefMp.put("width", "150px");
	   				varianceRefMp.put("colId", "");
	   				varianceRefMp.put("dataType", "DECIMAL");
		   	   		finalMap.add(varianceRefMp);
   			} 
   			else
   			{
   				if("source".equalsIgnoreCase(sourceOrTarget)){
						HashMap transIdRefMp = new HashMap();
   					transIdRefMp.put("field", "dataRowId");
   					transIdRefMp.put("header", "Transaction Id");
   					transIdRefMp.put("columnName", "original_row_id");
	   				transIdRefMp.put("align", "left");
	   				transIdRefMp.put("width", "150px");
	   				transIdRefMp.put("colId", "original_row_id");
	   				transIdRefMp.put("dataType", "STRING");
		   			finalMap.add(transIdRefMp);
						
					} else {
						HashMap transIdRefMp = new HashMap();
	   					transIdRefMp.put("field", "dataRowId");
	   					transIdRefMp.put("header", "Transaction Id");
	   					transIdRefMp.put("columnName", "target_row_id");
		   				transIdRefMp.put("align", "left");
		   				transIdRefMp.put("width", "150px");
		   				transIdRefMp.put("colId", "target_row_id");
		   				transIdRefMp.put("dataType", "STRING");
			   			finalMap.add(transIdRefMp);
					}
   				if("suggestion".equalsIgnoreCase(status)){
   					if(allViewColIds.size()>0)
		  			{
		    	   		finalMap.addAll(getColAlignInfo(allViewColIds));
		  			}
   					
   				} else {
   					if(allViewColIds.size()>0)
	  				{
	    	   		    finalMap.addAll(getColAlignInfo(allViewColIds));
	  				}
   				}
   				HashMap rowDescRefMp = new HashMap();
	   	   		  	rowDescRefMp.put("field", "rowDescription");
	   	   		  	rowDescRefMp.put("header", "Row Description");
	   	   		  	rowDescRefMp.put("columnName", "rowDescription");
	   	   		  	rowDescRefMp.put("align", "right");
	   	   		  	rowDescRefMp.put("width", "150px");
	   	   		  	rowDescRefMp.put("colId", "rowDescription");
	   	   		  	rowDescRefMp.put("dataType", "STRING");
		   	   		finalMap.add(rowDescRefMp);
	   	   		HashMap adjTypeRefMp = new HashMap();
		   	   		adjTypeRefMp.put("field", "adjustmentType");
		   	   		adjTypeRefMp.put("header", "Adjustment Type");
		   	   		adjTypeRefMp.put("columnName", "adjustmentType");
		   	   		adjTypeRefMp.put("align", "right");
		   	   		adjTypeRefMp.put("width", "150px");
		   	   		adjTypeRefMp.put("colId", "adjustmentType");
		   	   		adjTypeRefMp.put("dataType", "STRING");
		   	   		finalMap.add(adjTypeRefMp);
   			}
   		} 
   		else {
   			if(ruleId != null){
   				if("source".equalsIgnoreCase(sourceOrTarget))
   	   	   		{
   	   				if("reconciled".equalsIgnoreCase(status)){
 	   			   			List<BigInteger> sColumnIds = ruleConditionsRepository.fetchSourceColumnIdsByRuleId(ruleId);
   	   		   				log.info("Source Column Ids: "+ sColumnIds+" for Source View Id: "+viewId);
   	   		   				if(sColumnIds.size()>0)
   	   		   				{
   	   		   					finalMap.addAll(getColAlignInfo(sColumnIds));
   	   		   				}
		   	   		   		if(allViewColIds.size()>0)
				  	   		{
				  	   			for(BigInteger id : allViewColIds)
				  	   			{
				  	   				if(!sColumnIds.contains(id))
				  	   				{
				  	   					remainingSequence.add(id);
				  	   				}
				  	   			}
				  	   		}
		   	   		   		if(remainingSequence.size() > 0) {
		   	   		   			finalMap.addAll(getColAlignInfo(remainingSequence));
		   	   		   		}
		   	   		   		HashMap rowDescRefMp = new HashMap();
			   	   		  	rowDescRefMp.put("field", "rowDescription");
			   	   		  	rowDescRefMp.put("header", "Row Description");
			   	   		  	rowDescRefMp.put("columnName", "rowDescription");
			   	   		  	rowDescRefMp.put("align", "left");
			   	   		  	rowDescRefMp.put("width", "150px");
			   	   		  	rowDescRefMp.put("colId", "rowDescription");
			   	   		  	rowDescRefMp.put("dataType", "STRING");
				   	   		finalMap.add(rowDescRefMp);
				   	   		HashMap adjTypeRefMp = new HashMap();
				   	   		adjTypeRefMp.put("field", "adjustmentType");
				   	   		adjTypeRefMp.put("header", "Adjustment Type");
				   	   		adjTypeRefMp.put("columnName", "adjustmentType");
				   	   		adjTypeRefMp.put("align", "left");
				   	   		adjTypeRefMp.put("width", "150px");
				   	   		adjTypeRefMp.put("colId", "adjustmentType");
				   	   		adjTypeRefMp.put("dataType", "STRING");
				   	   		finalMap.add(adjTypeRefMp);
   	   				}
   	   	   		} 
   	   			else
   	   	   		{
   	   				if("reconciled".equalsIgnoreCase(status)){
   	   			   			List<BigInteger> tColumnIds = ruleConditionsRepository.fetchTargetColumnIdsByRuleId(ruleId);
   	   		   				log.info("Source Column Ids: "+ tColumnIds+" for Source View Id: "+viewId);
   	   		   				if(tColumnIds.size()>0)
   	   		   				{
   	   		   					finalMap.addAll(getColAlignInfo(tColumnIds));
   	   		   				}
		   	   		   		if(allViewColIds.size()>0)
				  	   		{
				  	   			for(BigInteger id : allViewColIds)
				  	   			{
				  	   				if(!tColumnIds.contains(id))
				  	   				{
				  	   					remainingSequence.add(id);
				  	   				}
				  	   			}
				  	   		}
		   	   		   		if(remainingSequence.size() > 0) {
		   	   		   			finalMap.addAll(getColAlignInfo(remainingSequence));
		   	   		   		}
		   	   		   		
		   	   		   		HashMap rowDescRefMp = new HashMap();
			   	   		  	rowDescRefMp.put("field", "rowDescription");
			   	   		  	rowDescRefMp.put("header", "Row Description");
			   	   		  	rowDescRefMp.put("columnName", "rowDescription");
			   	   		  	rowDescRefMp.put("align", "left");
			   	   		  	rowDescRefMp.put("width", "150px");
			   	   		  	rowDescRefMp.put("colId", "");
			   	   		  	rowDescRefMp.put("dataType", "STRING");
				   	   		finalMap.add(rowDescRefMp);
				   	   		HashMap adjTypeRefMp = new HashMap();
				   	   		adjTypeRefMp.put("field", "adjustmentType");
				   	   		adjTypeRefMp.put("header", "Adjustment Type");
				   	   		adjTypeRefMp.put("columnName", "Adjustment Type");
				   	   		adjTypeRefMp.put("align", "left");
				   	   		adjTypeRefMp.put("width", "150px");
				   	   		adjTypeRefMp.put("colId", "");
				   	   		adjTypeRefMp.put("dataType", "STRING");
				   	   		finalMap.add(adjTypeRefMp);
   	   				}
   	   	   		}
			}
   			
   		}
   	}
   	else
   	{
   		log.info("No Rule Ids found for the group id: "+ groupId);
   	}
   	return finalMap;
   }

   public List<HashMap> getColAlignInfo(List<BigInteger> columnIds)
   {
	   	List<HashMap> finalMap = new ArrayList<HashMap>();
		for(BigInteger id : columnIds)
		{
			HashMap hm = new HashMap();
			DataViewsColumns dvc = dataViewsColumnsRepository.findOne(id.longValue());
			if(dvc != null)
			{
				String columnName = "";
				if("File Template".equalsIgnoreCase(dvc.getRefDvType()))
				{
		    		FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dvc.getRefDvColumn()));
		    		if(ftl != null)
		    		{
		    			columnName = ftl.getColumnAlias();
		    		}
				}
				else if("Data View".equalsIgnoreCase(dvc.getRefDvType()) || dvc.getRefDvType() == null)
				{
					columnName = dvc.getColumnName();
				}
					/*hm.put("field", dvc.getColumnName());*/
					hm.put("field", columnName);
					hm.put("header", dvc.getColumnName());
					if("DECIMAL".equalsIgnoreCase(dvc.getColDataType()))
					{
						hm.put("align", "right");
					}
					else
					{
						hm.put("align", "left");
					}
					hm.put("columnName", columnName);
					hm.put("width", "150px");
					hm.put("colId", dvc.getId());
					hm.put("dataType", dvc.getColDataType());
				finalMap.add(hm);
			}
		}
		return finalMap;
   }
   
   public List<HashMap> getColAlignInfoForAcc(List<BigInteger> columnIds)
   {
	   	List<HashMap> finalMap = new ArrayList<HashMap>();
		for(BigInteger id : columnIds)
		{
			HashMap hm = new HashMap();
			DataViewsColumns dvc = dataViewsColumnsRepository.findOne(id.longValue());
			if(dvc != null)
			{
				String columnName = "";
				if("File Template".equalsIgnoreCase(dvc.getRefDvType()))
				{
		    		FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dvc.getRefDvColumn()));
		    		if(ftl != null)
		    		{
		    			columnName = ftl.getColumnAlias();
		    		}
				}
				else if("Data View".equalsIgnoreCase(dvc.getRefDvType()) || dvc.getRefDvType() == null)
				{
					columnName = dvc.getColumnName();
				}
					hm.put("field", dvc.getColumnName());
					hm.put("header", dvc.getColumnName());
					if("DECIMAL".equalsIgnoreCase(dvc.getColDataType()))
					{
						hm.put("align", "right");
					}
					else
					{
						hm.put("align", "left");
					}
					hm.put("columnName", columnName);
					hm.put("width", "150px");
					hm.put("colId", dvc.getId());
					hm.put("dataType", dvc.getColDataType());
				finalMap.add(hm);
			}
		}
		return finalMap;
   }
   /*Service for getting distinct column values for the column*/
   
   public List<String> getDistColumnValues(List<BigInteger> idStr, String columnAlias, String viewName) throws SQLException
   {
	   	String idsString=idStr.toString();
	   	idsString=idsString.replace("[", "");
	   	idsString=idsString.replace("]", "");
	   	List<String> distctValues = new ArrayList<String>();

	   	if(idStr!=null && !(idStr.isEmpty())){
	   		// Connection to JDBC
	   		Connection conn = null;
	   		Statement stmt = null;
	   		ResultSet result = null; 
	       	try{
				DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
				conn = ds.getConnection();
	        	stmt = conn.createStatement();
	     	    result=stmt.executeQuery("SELECT distinct(`"+columnAlias+"`) from `"+viewName.toLowerCase()+"` WHERE scrIds IN ("+idsString+")");
	     	    while(result.next()){
	     	    	distctValues.add(result.getString(1));
	     	    }
	       	}catch(Exception e)
	       	{
	       		log.info("Exception e: "+e);
	       	}
	       	finally
	       	{
	    		if(result != null)
	    			result.close();	
	    		if(stmt != null)
	    			stmt.close();
				if(conn != null)
					conn.close();
	       	}
       	}
	   	return distctValues;
   }
   
   public int getDistColValueCount(List<BigInteger> idStr, String viewName, String columnAlias, String columnValue) throws SQLException
   {
	   	String idsString=idStr.toString();
	   	idsString=idsString.replace("[", "");
	   	idsString=idsString.replace("]", "");
	   	int count = 0;
	   	if(idStr!=null && !(idStr.isEmpty())){
	   		// Connection to JDBC
	   		Connection conn = null;
	   		Statement stmt = null;
	   		ResultSet result = null; 
	       	try{
				DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
				conn = ds.getConnection();
				stmt = conn.createStatement();
	     	    result=stmt.executeQuery("SELECT count(*) from `"+viewName.toLowerCase()+"` WHERE scrIds IN ("+idsString+") AND `"+columnAlias+"` = '"+columnValue+"'");
	     	    while(result.next()){
	     	    	count = count + result.getInt(1);
	     	    }
	       	}catch(Exception e)
	       	{
	       		log.info("Exception e: "+e);
	       	}
	       	finally{
	    		if(result != null)
	    			result.close();	
	    		if(stmt != null)
	    			stmt.close();
				if(conn != null)
					conn.close();
	       	}
      	}
	   	return count;
   }
   /*Service for getting data view's column set information to display in Side Bar*/
   public List<HashMap> getViewColumnSetWithStatus(String sourceOrTarget, Long viewId, Long groupId, Long tenantId, List<BigInteger> idStr) throws SQLException
   {
		log.info("In Service for getting column set information for the view id: "+viewId);
	   	DataViews dv = dataViewsRepository.findOne(viewId);
	   	String viewName = "";
	   	if(dv != null)
	   	{
	   		viewName = viewName + dv.getDataViewName();
	   	}
	   	List<HashMap> finalMap = new ArrayList<HashMap>();
		if("source".equalsIgnoreCase(sourceOrTarget))
		{
	   		HashMap<BigInteger, String> seqCols = reconciliationResultService.getRecSequenceColumns(viewId, groupId,tenantId, "source");
	       	if(seqCols.size()>0)
	       	{
	       		for(Map.Entry<BigInteger, String> entry : seqCols.entrySet())
	       		{
	       			log.info("Id: " + entry.getKey()+", Column Alias: " + entry.getValue());
	       			List<HashMap> colValuesMap = new ArrayList<HashMap>();
	           		HashMap colMap = new HashMap();
	           		colMap.put("id", entry.getKey());
	           		DataViewsColumns dvc = dataViewsColumnsRepository.findOne(Long.parseLong(entry.getKey().toString()));
	           		if(dvc != null)
	           		{
	           			colMap.put("columnName", dvc.getColumnName());
	           		}
	           		log.info("Column Field Name: "+ dvc.getColumnName());
	           		List<String> entity = getDistColumnValues(idStr, entry.getValue(), viewName);
	           		if(entity.size()<=15)
	           		{
	               		log.info("Distinct Values Size: "+entity.size() +", Column "+ dvc.getColumnName());
	               		log.info("Distinct Values: "+entity);
	           			for(String colValue : entity)
	           			{
	           				HashMap colValueMp = new HashMap();
	           				int count = getDistColValueCount(idStr, viewName, entry.getValue(), colValue);
	           				colValueMp.put("name", colValue);
	           				colValueMp.put("count", count);
	           				colValuesMap.add(colValueMp);
	           			}
	               		colMap.put("columnValuesSet", colValuesMap);
	               		finalMap.add(colMap);
	           		}
	           		else
	           		{
	           			log.info("Column "+ entry.getValue() +" has "+entity.size()+" size");
	           		}
	       		}
				return finalMap;
			}
	       	else
	       	{
	       		return null;
	       	}
	}
	else if("target".equalsIgnoreCase(sourceOrTarget))
	{
	 	HashMap<BigInteger, String> seqCols = reconciliationResultService.getRecSequenceColumns(viewId, groupId,tenantId, "target");
	   	if(seqCols.size()>0)
	   	{
	   		for(Map.Entry<BigInteger, String> entry : seqCols.entrySet())
	   		{
	   			log.info("Id: " + entry.getKey()+", Column Alias: " + entry.getValue());
	   			List<HashMap> colValuesMap = new ArrayList<HashMap>();
	       		HashMap colMap = new HashMap();
	       		colMap.put("id", entry.getKey());
           		DataViewsColumns dvc = dataViewsColumnsRepository.findOne(Long.parseLong(entry.getKey().toString()));
           		if(dvc != null)
           		{
           			colMap.put("columnName", dvc.getColumnName());
           		}
	       		List<String> entity = getDistColumnValues(idStr, entry.getValue(), viewName);
	       		if(entity.size()<=15)
	       		{
	           		log.info("Distinct Values Size: "+entity.size() +", Column "+ dvc.getColumnName());
	       			log.info("Distinct Values: "+entity);
	       			for(String colValue : entity)
	       			{
	       				HashMap colValueMp = new HashMap();
	       				int count = getDistColValueCount(idStr, viewName, entry.getValue(), colValue);
	       				colValueMp.put("name", colValue);
	       				colValueMp.put("count", count);
	       				colValuesMap.add(colValueMp);
	       			}
	           		colMap.put("columnValuesSet", colValuesMap);
	           		finalMap.add(colMap);
	       		}
	       		else
	       		{
	       			log.info("Column "+ entry.getValue() +" has "+entity.size()+" size");
	       		}
	   		}
			return finalMap;
	   		}
	   	else 
	   	{
	   		return null;
	   	}
		}
	else
	{
		return null;
	}
   }
   
   public List<String> getViewColumnHeadersInSequenceForApproval(Long viewId, Long groupId, Long tenantId, String sourceOrTarget)
   {
	   	log.info("In service for getting column headers in sequence");
	   	List<String> colNames = new ArrayList<String>();
	   	List<BigInteger> ruleIds = ruleGroupDetailsRepository.fetchRuleIdsByGroupAndTenantId(groupId, tenantId);
	   	log.info("Rule Ids "+ ruleIds+" for the group id "+ groupId);
	   	if(ruleIds.size()>0)
	   	{
	   		if("source".equalsIgnoreCase(sourceOrTarget))
	   		{
	   			log.info("In Source : "+ viewId);
	   			List<BigInteger> ids = rulesRepository.fetchIdsBySourceViewIdAndIds(tenantId, viewId, ruleIds);
	   			log.info("Rule Ids "+ ids +" tagged to source view id"+ viewId);
	   			if(ids.size()>0)
	   			{
	   				List<BigInteger> sColumnIds = ruleConditionsRepository.fetchSourceColumnIdsByRuleIds(ids);
	   				sColumnIds.remove(null);
	   				log.info("Source Column Ids: "+ sColumnIds+" for Source View Id: "+viewId);
	   				if(sColumnIds.size()>0)
	   				{
	   	    			List<String> dvc = dataViewsColumnsRepository.fetchFileTemplateLineIdsByIds(sColumnIds);
	   	    			List<String> seqColumns = new ArrayList<String>();
	   	    	    	if(dvc.size()>0)
	   	    	    	{
	   	    	    		List<Long> idsAsLong = new ArrayList<Long>();
	   	    	    		for(String idString : dvc)
	   	    	    		{
	   	    	    			idsAsLong.add(Long.parseLong(idString));
	   	    	    		}
	   	    	    		seqColumns = fileTemplateLinesRepository.fetchColumnAliasByIds(idsAsLong);
	   	    	    		log.info("Sequence Columns "+ seqColumns);
	   	    	    		colNames.addAll(seqColumns);
	   	    	    	}
	   	    	    	else
	   	    	    	{
	   	    	    			seqColumns=dataViewsColumnsRepository.findColumnName(sColumnIds);
	   	    	    			log.info("seqColumns :"+seqColumns);
	   	    	    			colNames.addAll(seqColumns);
	   	    	    	}
	   				}
	   			}
	   		}
	   		else if("target".equalsIgnoreCase(sourceOrTarget))
	   		{
	   			log.info("In Target : "+ viewId);
	   			List<BigInteger> ids = rulesRepository.fetchIdsByTargetViewIdAndIds(tenantId, viewId, ruleIds);
	   			log.info("Rule Ids "+ ids + " which are tagged to target view id : "+ ids);
	   			if(ids.size()>0)
	   			{
	   				List<BigInteger> tColumnIds = ruleConditionsRepository.fetchTargetColumnIdsByRuleIds(ids);
	   				tColumnIds.remove(null);
	   				log.info("Target view id "+viewId+"Target Column Ids: "+ tColumnIds);
	   				if(tColumnIds.size()>0)
	   				{
	   					List<String> dvc = dataViewsColumnsRepository.fetchFileTemplateLineIdsByIds(tColumnIds);
	   					List<String> seqColumns = new ArrayList<String>();
	   					if(dvc.size()>0)
	   					{
	   						List<Long> idsAsLong = new ArrayList<Long>();
	   						for(String idString : dvc)
	   						{
	   							idsAsLong.add(Long.parseLong(idString));
	   						}
	   						seqColumns = fileTemplateLinesRepository.fetchColumnAliasByIds(idsAsLong);
	   						log.info("Target View Id"+viewId+"Sequence Columns "+ seqColumns);
	   						colNames.addAll(seqColumns);
	   					}
	   					else
	   					{
	   							seqColumns=dataViewsColumnsRepository.findColumnName(tColumnIds);
	   							log.info("seqColumns :"+seqColumns);
	   							colNames.addAll(seqColumns);
	   					}
	   				}
	   			}
	   		}
	   	}
	   	else
	   	{
	   		log.info("No Rule Ids found for the group id: "+ groupId);
	   	}
	   	return colNames;
	   }

   /**
    * author ravali
    * @param columnIds
    * @param headerList
    * @return
    */
   public List<HashMap> getColAlignInfoForApproval(List<BigInteger> columnIds,List<String> headerList)
   {
	   		List<HashMap> finalMap = new ArrayList<HashMap>();
			for(BigInteger id : columnIds)
			{
				HashMap hm = new HashMap();
				DataViewsColumns dvc = dataViewsColumnsRepository.findOne(id.longValue());
				if(dvc != null)
				{
					for(String header:headerList)
					{
						log.info("header :"+header.replaceAll("[0-9]", "").replaceAll("_", "").split("(?=[A-Z])")[0]);
						log.info("dvc.getColumnName() :"+dvc.getColumnName().split(" ")[0]);
			        if(dvc.getColumnName().split(" ")[0].equalsIgnoreCase(header.replaceAll("[0-9]", "").replaceAll("_", "").split("(?=[A-Z])")[0]))
			        {
			        	log.info("in if");
					hm.put("field", header.replaceAll("[0-9]", "").replaceAll("_", ""));
					hm.put("header", dvc.getColumnName());
					if("DECIMAL".equalsIgnoreCase(dvc.getColDataType()))
					{
						hm.put("align", "right");
					}
					else
					{
						hm.put("align", "left");
					}
					hm.put("width", "150px");
					finalMap.add(hm);
					}
				}
				}
			}
			return finalMap;
   }
   
 /**
  * ravali
  * @param viewId
  * @param groupId
  * @param tenantId
  * @param sourceOrTarget
  * @param headerList
  * @return
  */
   public List<HashMap> getAppActOrRecColsAlignInfo(Long viewId, Long groupId, Long tenantId, String sourceOrTarget,List<String> headerList)
   {
	   	log.info("In service for getting column headers in sequence");
	   	List<HashMap> finalMap = new ArrayList<HashMap>();
	   	List<BigInteger> ruleIds = ruleGroupDetailsRepository.fetchRuleIdsByGroupAndTenantId(groupId, tenantId);
	   	log.info("Rule Ids "+ ruleIds+" for the group id "+ groupId);
	   	List<BigInteger> allViewColIds = dataViewsColumnsRepository.fetchIdsByDataViewId(viewId);
	   	log.info("All View Column Ids: "+ allViewColIds);
	   	List<String> sysColumns = new ArrayList<String>();
	   	sysColumns.add("Status");
	   	List<BigInteger> remainingSequence = new ArrayList<BigInteger>();
	   	if(ruleIds.size()>0)
	   	{
	   		if("source".equalsIgnoreCase(sourceOrTarget))
	   		{
		   		
	   			log.info("In Source : "+ viewId);
	   			List<BigInteger> ids = rulesRepository.fetchIdsBySourceViewIdAndIds(tenantId, viewId, ruleIds);
	   			log.info("Rule Ids "+ ids +" tagged to source view id"+ viewId);
	   			if(ids.size()>0)
	   			{
	   				List<BigInteger> sColumnIds = ruleConditionsRepository.fetchSourceColumnIdsByRuleIds(ids);
	   				log.info("Source Column Ids: "+ sColumnIds+" for Source View Id: "+viewId);
	   				if(sColumnIds.size()>0)
	   				{
	   					finalMap.addAll(reconciliationResultService.getColAlignInfoApp(sColumnIds));
	   				}
	   			}
	   		}
	      		else if("target".equalsIgnoreCase(sourceOrTarget))
	      		{
	   	   
	      			log.info("In Target : "+ viewId);
	      			List<BigInteger> ids = rulesRepository.fetchIdsByTargetViewIdAndIds(tenantId, viewId, ruleIds);
	      			log.info("Rule Ids "+ ids + " which are tagged to target view id : "+ ids);
	      			if(ids.size()>0)
	      			{
	      				List<BigInteger> tColumnIds = ruleConditionsRepository.fetchTargetColumnIdsByRuleIds(ids);
	      				log.info("Target view id "+viewId+"Target Column Ids: "+ tColumnIds);
	      				if(tColumnIds.size()>0)
	      				{
	      					finalMap.addAll(reconciliationResultService.getColAlignInfoApp(tColumnIds));
	      				}
	      			
	      			}
	      		}
	   	}
			return finalMap;
	   }
   /**
    * ravali setting alias name from file templates
    * @param viewId
    * @param groupId
    * @param tenantId
    * @param sourceOrTarget
    * @return
    */
   public List<HashMap> getColAlignInfoApp(List<BigInteger> columnIds)
   {
	   List<HashMap> finalMap = new ArrayList<HashMap>();
	   for(BigInteger id : columnIds)
	   {
		   HashMap hm = new HashMap();
		   DataViewsColumns dvc = dataViewsColumnsRepository.findOne(id.longValue());
		   if(dvc != null)
		   {
			   if(dvc.getRefDvColumn()!=null)
			   {
				   FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dvc.getRefDvColumn().toString()));
				   if(ftl != null)
					   hm.put("field", ftl.getColumnAlias());
			   }
			   else
				   hm.put("field", dvc.getColumnName());
			   hm.put("header", dvc.getColumnName());
			   if("DECIMAL".equalsIgnoreCase(dvc.getColDataType()))
			   {
				   hm.put("align", "right");
			   }
			   else
			   {
				   hm.put("align", "left");
			   }
			   hm.put("width", "150px");
			   finalMap.add(hm);
		   }
	   }
	   return finalMap;
   }
   
  /** Reconciliation Work Queue New Forms **/
   
   /**
    * Author: Shiva
    * Purpose: Fetching Batch Names based on tenant id and rule group id
    * Params: tenantId, ruleGroupid
 * @throws SQLException 
    **/
   public List<String> getBatchNames(Long tenantId, Long groupId) throws SQLException
   {
	   log.info("Fetching Batch Names for the tenant id: "+ tenantId + ", rule group id: "+ groupId);
	   List<String> batchNames = new ArrayList<String>();
   	   Connection conn = null;
   	   Statement stmt = null;
   	   ResultSet result = null;   	   
	   try{
		   DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
		   conn = ds.getConnection();
 	      log.info("Connected database successfully...");
	      stmt = conn.createStatement();
	      log.info("BatchesQuery: select distinct(recon_job_reference) from v_recon_job_refereces WHERE tenant_id = "+ tenantId +" AND rule_group_id = "+groupId+" order by recon_job_reference asc");
	      result = stmt.executeQuery("select distinct(recon_job_reference) from v_recon_job_refereces WHERE tenant_id = "+ tenantId +" AND rule_group_id = "+groupId+" order by recon_job_reference asc");
	 	  while(result.next()){
	 		 batchNames.add(result.getString(1));
	 	  }
	   }
	   catch(Exception e)
	   {
		   log.info("Un able to connect to the database");
	   }
	   finally
	   {
	   		if(result != null)
				result.close();	
			if(stmt != null)
				stmt.close();
			if(conn != null)
				conn.close();
	   }
	   log.info("Batch Names: "+ batchNames);
   	   return batchNames;
   }
   /**
    * Author: Shiva
    * Description: Fetching data view original ids within ranges
 * @throws SQLException 
    * **/
   public List<BigInteger> getViewOriginalIds(Long viewId, String rangeFrom, String rangeTo, String transDateColumn) throws SQLException /*throws SQLException*/
   {
	   log.info("Fetching total original ids for the view id "+ viewId+" between "+ rangeFrom + " and "+ rangeTo);
	   List<BigInteger> viewOriginalIds = new ArrayList<BigInteger>();
	   Connection conn = null;
	   Statement stmt = null;
	   ResultSet result = null; 
	   
	   try{
		   DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
		   conn = ds.getConnection();
    	   stmt = conn.createStatement();
     	   DataViews dv=dataViewsRepository.findOne(viewId.longValue());
     	   if(dv!= null)
     	   {
     		   String viewName = dv.getDataViewName();
/*     		   log.info("Query: "+"select scrIds from "+schemaName+"."+viewName.toLowerCase()+" where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' order by "+transDateColumn+" desc");
        	   result=stmt.executeQuery("select scrIds from "+schemaName+"."+viewName.toLowerCase()+" where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' order by "+transDateColumn+" desc");
*/     		   log.info("Query: "+"select scrIds from `"+viewName.toLowerCase()+"` where Date(fileDate) between '"+rangeFrom+"' AND '"+rangeTo+"'");
			   result=stmt.executeQuery("select scrIds from `"+viewName.toLowerCase()+"` where Date(fileDate) between '"+rangeFrom+"' AND '"+rangeTo+"'");
			   stmt.setFetchSize(500);
			   while(result.next()){
        		   viewOriginalIds.add(new BigInteger((result.getString(1))));
        	   }  
			   log.info("viewOriginalIds size:"+viewOriginalIds.size());
     	   }
     	   else
     	   {
     		   log.info("View doen't not exist for the view id: "+viewId);
     	   }
	   }
	   catch(SQLException se){
		   log.info("Error while executing query: "+se);
       }
	   catch(Exception e)
	   {
		   log.info("Exception while getting databse properties");
	   }
	   finally{
	   		if(result != null)
	   			result.close();	
	   		if(stmt != null)
	   			stmt.close();
			if(conn != null)
				conn.close();
			}
   	//log.info("View ID: "+ viewId+", Row Ids Size: "+viewOriginalIds.size());
   	return viewOriginalIds;
   }
   
   public List<BigInteger> getTargetIds(Long viewId) throws SQLException /*throws SQLException*/
   {
	   log.info("Fetching total original ids for the view id "+ viewId);
	   List<BigInteger> viewOriginalIds = new ArrayList<BigInteger>();
	   Connection conn = null;
	   Statement stmt = null;
	   ResultSet result = null; 
	   
	   try{
			DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
			conn = ds.getConnection();
    	   stmt = conn.createStatement();
     	   DataViews dv=dataViewsRepository.findOne(viewId.longValue());
     	   if(dv!= null)
     	   {
     		   String viewName = dv.getDataViewName();
/*     		   log.info("Query: "+"select scrIds from "+schemaName+"."+viewName.toLowerCase()+" where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' order by "+transDateColumn+" desc");
        	   result=stmt.executeQuery("select scrIds from "+schemaName+"."+viewName.toLowerCase()+" where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' order by "+transDateColumn+" desc");
*/     		   log.info("Query: "+"select scrIds from `"+viewName.toLowerCase()+"`");
			   result=stmt.executeQuery("select scrIds from `"+viewName.toLowerCase()+"`");
			   stmt.setFetchSize(500);
			   while(result.next()){
        		   viewOriginalIds.add(new BigInteger((result.getString(1))));
        	   }  
			   log.info("viewOriginalIds size:"+viewOriginalIds.size());
     	   }
     	   else
     	   {
     		   log.info("View doen't not exist for the view id: "+viewId);
     	   }
	   }
	   catch(SQLException se){
		   log.info("Error while executing query: "+se);
       }
	   catch(Exception e)
	   {
		   log.info("Exception while getting databse properties");
	   }
	   finally{
	   		if(result != null)
	   			result.close();	
	   		if(stmt != null)
	   			stmt.close();
			if(conn != null)
				conn.close();
			}
   	//log.info("View ID: "+ viewId+", Row Ids Size: "+viewOriginalIds.size());
   	return viewOriginalIds;
   }
   
   public Map<String, List<BigInteger>> getUnReconMap(Long dataViewId, Long tenantId,Long groupId,String rangeFrom, String rangeTo, String transDateColumn) throws ClassNotFoundException, SQLException{
	   	Map<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
		List<BigInteger> viewOriginalIds = getViewOriginalIds(dataViewId, rangeFrom, rangeTo,transDateColumn);
		List<BigInteger> reconciled = new ArrayList<BigInteger>();
	   	finalMap.put("reconciled", reconciled);
	   	finalMap.put("unReconciled", viewOriginalIds);
	   	finalMap.put("totalIds", viewOriginalIds);
		log.info("Source View ID: "+dataViewId+", total ids: "+viewOriginalIds.size()+", View Original Ids: "+viewOriginalIds.size());
	   	return finalMap;
	   }
   
/*   public List<HashMap> getUnReconData(Long viewId, String rangeFrom, String rangeTo, String transDateColumn, String amountQualifier, Long tenantId) throws SQLException, ParseException, ClassNotFoundException
   {
	   List<BigInteger> viewOriginalIds = getViewOriginalIds(viewId, rangeFrom, rangeTo,transDateColumn);
	   String currencyCodeColName = getTransDateQualifier(new BigInteger(viewId.toString()), "CURRENCYCODE");
	   DataViews dv = dataViewsRepository.findOne(viewId);
	   List<HashMap> finalList = new ArrayList<HashMap>();
	   Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	   String currencyFormat = props.getProperty("currencyFormat");
	   if(dv != null)
	   {
		   List<String> currenciesRec = getDistColumnValues(viewOriginalIds,currencyCodeColName,dv.getDataViewName());
		   String currencySymbol = "";
		   if(currenciesRec.size()==1)
		   {
			   currencySymbol = currencySymbol+getCurrencySymbol(currenciesRec.get(0));
		   }
		   else if(currenciesRec.size()>1)
		   {
			   currencySymbol = currencySymbol+"*";
		   }
		   HashMap recMap = new HashMap();
		   recMap.put("name", "Others");
		   HashMap recAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, amountQualifier,viewOriginalIds);
		   recMap.put("tAmount", currencySymbol+" "+reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
		   recMap.put("tCount", recAmountCount.get("totalCount"));
		  // recMap.put("tdCount", viewOriginalIds.size());
		   
		   recMap.put("rAmount", 0.0);
		   recMap.put("rCount", 0);
		 //  recMap.put("rdCount", 0);
		   
		   recMap.put("uAmount", currencySymbol+" "+reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
		   recMap.put("uCount", recAmountCount.get("totalCount"));
		 //  recMap.put("udCount", viewOriginalIds.size());
		   
		   finalList.add(recMap);
	   }

	   return finalList;
   }*/
   
/*   public List<HashMap> getUnReconDataTarget(Long viewId, String rangeFrom, String rangeTo, String transDateColumn, String amountQualifier, Long tenantId) throws SQLException, ParseException, ClassNotFoundException
   {
	   List<BigInteger> viewOriginalIds = getTargetIds(viewId);
	   String currencyCodeColName = getTransDateQualifier(new BigInteger(viewId.toString()), "CURRENCYCODE");
	   DataViews dv = dataViewsRepository.findOne(viewId);
	   List<HashMap> finalList = new ArrayList<HashMap>();
	   Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	   String currencyFormat = props.getProperty("currencyFormat");
	   if(dv != null)
	   {
		   List<String> currenciesRec = getDistColumnValues(viewOriginalIds,currencyCodeColName,dv.getDataViewName());
		   String currencySymbol = "";
		   if(currenciesRec.size()==1)
		   {
			   currencySymbol = currencySymbol+getCurrencySymbol(currenciesRec.get(0));
		   }
		   else if(currenciesRec.size()>1)
		   {
			   currencySymbol = currencySymbol+"*";
		   }
		   HashMap recMap = new HashMap();
		   recMap.put("name", "Others");
		   HashMap recAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, amountQualifier,viewOriginalIds);
		   recMap.put("tAmount", currencySymbol+" "+reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
		   recMap.put("tCount", recAmountCount.get("totalCount"));
		   
		   recMap.put("rAmount", 0.0);
		   recMap.put("rCount", 0);
		   
		   recMap.put("uAmount", currencySymbol+" "+reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
		   recMap.put("uCount", recAmountCount.get("totalCount"));
		   
		   finalList.add(recMap);
	   }

	   return finalList;
   }*/
   
   /**
    * Author: Shiva
    * Purpose: Fetching rule's grouped list
    * @throws ClassNotFoundException 
 * @throws ParseException 
    * **/
 /*  public List<HashMap> getGroupedRulesList(List<BigInteger> ruleIds, String rangeFrom, String rangeTo, Long viewId, Long tenantId, Long groupId, String qualifier, String jobReference) throws ClassNotFoundException, ParseException
   {
	   log.info("Fetching rules grouped list for the rules: "+ ruleIds+", View Id: "+ viewId);
	   List<HashMap> finalList = new ArrayList<HashMap>();
	   Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	   String currencyFormat = props.getProperty("currencyFormat");
	   DataViews dv = dataViewsRepository.findOne(viewId);
	   try {
		   if(dv != null)
		   {
			   String transDateColumn = reconciliationResultService.getTransDateQualifier(new BigInteger(viewId.toString()), "TRANSDATE");
			   List<BigInteger> viewOriginalIds = getViewOriginalIds(viewId, rangeFrom, rangeTo,transDateColumn);
			   List<BigInteger> othersRecIds = new ArrayList<BigInteger>();
			   if(viewOriginalIds.size()>0)
			   {
				   String currencyCodeColName = getTransDateQualifier(new BigInteger(viewId.toString()), "CURRENCYCODE"); 
		 	    
				   List<BigInteger> unRecIds = new ArrayList<BigInteger>();
				   //HashMap others = new HashMap();
				   HashMap othersMap = new HashMap();
				   List<BigInteger> manualRecIds = new ArrayList<BigInteger>();
				   for(BigInteger ruleId: ruleIds)
				   {
					   List<BigInteger> recIds = new ArrayList<BigInteger>();
					   HashMap total = new HashMap();
					   HashMap recMap = new HashMap();
					   HashMap unRecon = new HashMap();
					   List<Long> ruleIdSingle = new ArrayList<Long>();
					   ruleIdSingle.add(ruleId.longValue());
					   recIds = reconciliationResultRepository.fetchReconciledIdsWithOutJobRefWithStatusReconciledForSource(tenantId, ruleIdSingle, groupId, viewOriginalIds,viewId);
					   if(ruleId.longValue() == 0L)
					   {
						   manualRecIds.addAll(recIds);
						   othersRecIds.addAll(recIds);
					   }
					   else
					   {
						   othersRecIds.addAll(recIds);
						   Rules rule = rulesRepository.findOne(ruleId.longValue());
						   HashMap reconciled = new HashMap();
						   if(rule != null)
						   {
							   recMap.put("id", ruleId);
							   recMap.put("name", rule.getRuleCode());
						   }
						   String currencySymbol = "";
						   List<String> currenciesRec = getDistColumnValues(recIds,currencyCodeColName,dv.getDataViewName());
						   if(currenciesRec.size()==1)
						   {
							   currencySymbol = currencySymbol+getCurrencySymbol(currenciesRec.get(0));
						   }
						   else if(currenciesRec.size()>1)
						   {
							   currencySymbol = currencySymbol+"*";
						   }
						   HashMap recAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, qualifier,recIds);
						   
						   recMap.put("tAmount", currencySymbol+" "+reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
						   recMap.put("tCount", recAmountCount.get("totalCount"));
						  // recMap.put("tdCount", recIds.size());
						   
						   recMap.put("rAmount", currencySymbol+" "+reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
						   recMap.put("rCount", recAmountCount.get("totalCount"));
						   //recMap.put("rdCount", recIds.size());
						   
						   recMap.put("uAmount", 0.0);
						   recMap.put("uCount", 0);
						 //  recMap.put("udCount", 0);
						   
						   finalList.add(recMap);
					   }
				   }
				   //Others
				   for(BigInteger id : viewOriginalIds)
				   {
					   if(!othersRecIds.contains(id))
					   {
						   unRecIds.add(id);
					   }
				   }
				   log.info("ManualUnReconciledSize: "+unRecIds.size());
				   HashMap othersTotal = new HashMap();
				   HashMap othersRec = new HashMap();
				   HashMap othersUnRec = new HashMap();
				   List<BigInteger> allOtherIds = new ArrayList<BigInteger>();
				   allOtherIds.addAll(manualRecIds);
				   allOtherIds.addAll(unRecIds);
				   
				   HashMap totalRecAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, qualifier,allOtherIds);
				   HashMap recAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, qualifier,manualRecIds);
				   HashMap unRecAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, qualifier,unRecIds);
				   
				   String currencySymbolRec = "";
				   List<String> currenciesRec = getDistColumnValues(manualRecIds,currencyCodeColName,dv.getDataViewName());
				   if(currenciesRec.size()==1)
				   {
					   currencySymbolRec = currencySymbolRec+getCurrencySymbol(currenciesRec.get(0));
				   }
				   else if(currenciesRec.size()>1)
				   {
					   currencySymbolRec = currencySymbolRec+"*";
				   }
				   
				   String currencySymbolTotal = "";
				   List<String> currenciesTotal = getDistColumnValues(viewOriginalIds,currencyCodeColName,dv.getDataViewName());
				   if(currenciesTotal.size()==1)
				   {
					   currencySymbolTotal = currencySymbolTotal+getCurrencySymbol(currenciesTotal.get(0));
				   }
				   else if(currenciesTotal.size()>1)
				   {
					   currencySymbolTotal = currencySymbolTotal+"*";
				   }
				   
				   String currencySymbolUnRec = "";
				   List<String> currenciesUnRec = getDistColumnValues(unRecIds,currencyCodeColName,dv.getDataViewName());
				   if(currenciesUnRec.size()==1)
				   {
					   currencySymbolUnRec = currencySymbolUnRec+getCurrencySymbol(currenciesUnRec.get(0));
				   }
				   else if(currenciesUnRec.size()>1)
				   {
					   currencySymbolUnRec = currencySymbolUnRec+"*";
				   }
				   
				   othersMap.put("name", "Manual");
				   othersMap.put("id", 0);			   
				   othersMap.put("tAmount", currencySymbolTotal + " "+reconciliationResultService.getAmountInFormat(totalRecAmountCount.get("totalAmount").toString(),currencyFormat));
				   othersMap.put("tCount", totalRecAmountCount.get("totalCount"));
				   //othersMap.put("tdCount", allOtherIds.size());
				   
				   othersMap.put("rAmount", currencySymbolRec + " "+reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
				   othersMap.put("rCount", recAmountCount.get("totalCount"));
				  // othersMap.put("trCount", manualRecIds.size());
				   
				   othersMap.put("uAmount", currencySymbolUnRec+ " "+ reconciliationResultService.getAmountInFormat(unRecAmountCount.get("totalAmount").toString(),currencyFormat));
				   othersMap.put("uCount", unRecAmountCount.get("totalCount"));
				  // othersMap.put("tuCount", unRecIds.size());
				   
				   finalList.add(othersMap);
			   }
		   }
	   }catch (SQLException e) {
			e.printStackTrace();
	   }
	   return finalList;
   }*/
   
 /*  public List<HashMap> getGroupedRulesListForTarget(List<BigInteger> ruleIds, String rangeFrom, String rangeTo, Long viewId, Long tenantId, Long groupId, String qualifier, String jobReference) throws ClassNotFoundException, ParseException
   {
	   log.info("Fetching rules grouped list for the rules: "+ ruleIds+", View Id: "+ viewId);
	   List<HashMap> finalList = new ArrayList<HashMap>();
	   Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	   String currencyFormat = props.getProperty("currencyFormat");
	   DataViews dv = dataViewsRepository.findOne(viewId);
	   try {
		   if(dv != null)
		   {
			   String transDateColumn = reconciliationResultService.getTransDateQualifier(new BigInteger(viewId.toString()), "TRANSDATE");
			   List<BigInteger> viewOriginalIds = getTargetIds(viewId);
			   List<BigInteger> othersRecIds = new ArrayList<BigInteger>();
			   if(viewOriginalIds.size()>0)
			   {
				   String currencyCodeColName = getTransDateQualifier(new BigInteger(viewId.toString()), "CURRENCYCODE"); 
		 	    
				   List<BigInteger> unRecIds = new ArrayList<BigInteger>();
				   //HashMap others = new HashMap();
				   HashMap othersMap = new HashMap();
				   List<BigInteger> manualRecIds = new ArrayList<BigInteger>();
				   for(BigInteger ruleId: ruleIds)
				   {
					   List<BigInteger> recIds = new ArrayList<BigInteger>();
					   HashMap total = new HashMap();
					   HashMap recMap = new HashMap();
					   HashMap unRecon = new HashMap();
					   List<Long> ruleIdSingle = new ArrayList<Long>();
					   ruleIdSingle.add(ruleId.longValue());
					   recIds = reconciliationResultRepository.fetchReconciledIdsWithOutJobRefWithStatusReconciledForTarget(tenantId, ruleIdSingle, groupId, viewOriginalIds, viewId);
					   if(ruleId.longValue() == 0L)
					   {
						   manualRecIds.addAll(recIds);
						   othersRecIds.addAll(recIds);
					   }
					   else
					   {
						   othersRecIds.addAll(recIds);
						   Rules rule = rulesRepository.findOne(ruleId.longValue());
						   HashMap reconciled = new HashMap();
						   if(rule != null)
						   {
							   recMap.put("id", ruleId);
							   recMap.put("name", rule.getRuleCode());
						   }
						   String currencySymbol = "";
						   List<String> currenciesRec = getDistColumnValues(recIds,currencyCodeColName,dv.getDataViewName());
						   if(currenciesRec.size()==1)
						   {
							   currencySymbol = currencySymbol+getCurrencySymbol(currenciesRec.get(0));
						   }
						   else if(currenciesRec.size()>1)
						   {
							   currencySymbol = currencySymbol+"*";
						   }
						   HashMap recAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, qualifier,recIds);
						   
						   recMap.put("tAmount", currencySymbol+" "+reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
						   recMap.put("tCount", recAmountCount.get("totalCount"));
						   
						   recMap.put("rAmount", currencySymbol+" "+reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
						   recMap.put("rCount", recAmountCount.get("totalCount"));
						   
						   recMap.put("uAmount", 0.0);
						   recMap.put("uCount", 0);
						   
						   finalList.add(recMap);
					   }
				   }
				   //Others
				   for(BigInteger id : viewOriginalIds)
				   {
					   if(!othersRecIds.contains(id))
					   {
						   unRecIds.add(id);
					   }
				   }
				   log.info("ManualUnReconciledSize: "+unRecIds.size());
				   HashMap othersTotal = new HashMap();
				   HashMap othersRec = new HashMap();
				   HashMap othersUnRec = new HashMap();
				   List<BigInteger> allOtherIds = new ArrayList<BigInteger>();
				   allOtherIds.addAll(manualRecIds);
				   allOtherIds.addAll(unRecIds);
				   
				   HashMap totalRecAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, qualifier,allOtherIds);
				   HashMap recAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, qualifier,manualRecIds);
				   HashMap unRecAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, qualifier,unRecIds);
				   
				   String currencySymbolRec = "";
				   List<String> currenciesRec = getDistColumnValues(manualRecIds,currencyCodeColName,dv.getDataViewName());
				   if(currenciesRec.size()==1)
				   {
					   currencySymbolRec = currencySymbolRec+getCurrencySymbol(currenciesRec.get(0));
				   }
				   else if(currenciesRec.size()>1)
				   {
					   currencySymbolRec = currencySymbolRec+"*";
				   }
				   
				   String currencySymbolTotal = "";
				   List<String> currenciesTotal = getDistColumnValues(viewOriginalIds,currencyCodeColName,dv.getDataViewName());
				   if(currenciesTotal.size()==1)
				   {
					   currencySymbolTotal = currencySymbolTotal+getCurrencySymbol(currenciesTotal.get(0));
				   }
				   else if(currenciesTotal.size()>1)
				   {
					   currencySymbolTotal = currencySymbolTotal+"*";
				   }
				   
				   String currencySymbolUnRec = "";
				   List<String> currenciesUnRec = getDistColumnValues(unRecIds,currencyCodeColName,dv.getDataViewName());
				   if(currenciesUnRec.size()==1)
				   {
					   currencySymbolUnRec = currencySymbolUnRec+getCurrencySymbol(currenciesUnRec.get(0));
				   }
				   else if(currenciesUnRec.size()>1)
				   {
					   currencySymbolUnRec = currencySymbolUnRec+"*";
				   }
				   
				   othersMap.put("name", "Manual");
				   othersMap.put("id", 0);			   
				   othersMap.put("tAmount", currencySymbolTotal + " "+reconciliationResultService.getAmountInFormat(totalRecAmountCount.get("totalAmount").toString(),currencyFormat));
				   othersMap.put("tCount", totalRecAmountCount.get("totalCount"));
				   
				   othersMap.put("rAmount", currencySymbolRec + " "+reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
				   othersMap.put("rCount", recAmountCount.get("totalCount"));
				   
				   othersMap.put("uAmount", currencySymbolUnRec+ " "+ reconciliationResultService.getAmountInFormat(unRecAmountCount.get("totalAmount").toString(),currencyFormat));
				   othersMap.put("uCount", unRecAmountCount.get("totalCount"));
				   
				   finalList.add(othersMap);
			   }
		   }
	   }catch (SQLException e) {
			e.printStackTrace();
	   }
	   return finalList;
   }*/
   
	public String getViewColumnQualifier(BigInteger dataViewId, String qualifierCode){
    	DataViewsColumns dvc = dataViewsColumnsRepository.findByDataViewIdAndQualifier(dataViewId.longValue(),qualifierCode);
    	String qualifier = "";
    	if(dvc != null)
    	{
			if("File Template".equalsIgnoreCase(dvc.getRefDvType()))
			{
	    		FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dvc.getRefDvColumn()));
	    		if(ftl != null)
	    		{
	    			qualifier = ftl.getColumnAlias();
	    		}
			}
			else if("Data View".equalsIgnoreCase(dvc.getRefDvType()) || dvc.getRefDvType() == null)
			{
				qualifier = dvc.getColumnName();
			}
    	}
    	else
    	{
    		log.info("There is no Transdate Qualifier for the view id : "+ dataViewId);
    	}
    	return qualifier;
	}
   
	public String getTransDateQualifier(BigInteger dataViewId, String qualifierCode) throws ClassNotFoundException{
    	DataViewsColumns dvc = dataViewsColumnsRepository.findByDataViewIdAndQualifier(dataViewId.longValue(),qualifierCode);
    	String qualifier = "";
    	if(dvc != null)
    	{
			if("File Template".equalsIgnoreCase(dvc.getRefDvType()))
			{
	    		FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dvc.getRefDvColumn()));
	    		if(ftl != null)
	    		{
	    			qualifier = ftl.getColumnAlias();
	    		}
			}
			else if("Data View".equalsIgnoreCase(dvc.getRefDvType()) || dvc.getRefDvType() == null)
			{
				qualifier = dvc.getColumnName();
			}
    	}
    	else
    	{
    		log.info("There is no Transdate Qualifier for the view id : "+ dataViewId);
    	}
    	return qualifier;
	}
	
	public List<String> getDistinctColumnValues(Long viewId, String rangeFrom, String rangeTo, String transDateQualifier) throws SQLException
	{
		   log.info("Fetching distinct transdates for the view id "+ viewId+" between "+ rangeFrom + " and "+ rangeTo +", qualifier: "+ transDateQualifier);
		   List<String> transDates = new ArrayList<String>();
		   Connection conn = null;
		   Statement stmt = null;
		   ResultSet result = null; 
		   
		   try{
				DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
				conn = ds.getConnection();
	    	   stmt = conn.createStatement();
	     	   DataViews dv=dataViewsRepository.findOne(viewId.longValue());
	     	   
	     	   if(dv!= null)
	     	   {
	     		   String viewName = dv.getDataViewName();
	     		   log.info("select distinct(`"+transDateQualifier+"`) FROM `"+viewName.toLowerCase() + "` where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' order by `"+ transDateQualifier+"` desc");
	        	   result=stmt.executeQuery("select distinct(`"+transDateQualifier+"`) FROM `"+viewName.toLowerCase() + "` where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' order by `"+ transDateQualifier+"` desc");
	        	   while(result.next()){
	        		   transDates.add((result.getString(1)));
	        	   }  
	     	   }
	     	   else
	     	   {
	     		   log.info("View doen't not exist for the view id: "+viewId);
	     	   }
		   }
		   catch(SQLException se){
			   log.info("Error while executing query: "+se);
	       }
		   catch(Exception e)
		   {
			   log.info("Exception while getting databse properties");
		   }
		   finally{
		   		if(result != null)
		   			result.close();	
		   		if(stmt != null)
		   			stmt.close();
				if(conn != null)
					conn.close();
				}
	   	log.info("View ID: "+ viewId+", TransDates Size: "+transDates.size());
	   	return transDates;
	}
	
	public List<String> getDistinctDates(Long viewId, String periodFactor, String rangeFrom, String rangeTo, String transDateQualifier) throws SQLException
	{
		List<String> distinctDates = new ArrayList<String>();
		if("fileDate".equalsIgnoreCase(periodFactor))
		{
			distinctDates = getDistinctTransDates(viewId, rangeFrom, rangeTo, transDateQualifier);
		}
		else if("dateQualifier".equalsIgnoreCase(periodFactor))
		{
			distinctDates = getDatesByDateQualifier(viewId, rangeFrom, rangeTo, transDateQualifier);
		}
		return distinctDates;
	}
	
	public List<String> getDatesByDateQualifier(Long viewId, String rangeFrom, String rangeTo, String transDateQualifier) throws SQLException
	{
		   log.info("Fetching distinct transdates for the view id "+ viewId+" between "+ rangeFrom + " and "+ rangeTo +", qualifier: "+ transDateQualifier);
		   List<String> transDates = new ArrayList<String>();
		   Connection conn = null;
		   Statement stmt = null;
		   ResultSet result = null; 
		   try{
				DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
				conn = ds.getConnection();

	    	   stmt = conn.createStatement();
	     	   DataViews dv=dataViewsRepository.findOne(viewId.longValue());
	     	   if(dv!= null)
	     	   {
	     		   String viewName = dv.getDataViewName();
	     		   log.info("SELECT DATE(`"+transDateQualifier+"`) FROM `"+viewName.toLowerCase()+"` where `"+transDateQualifier+"` between '"+rangeFrom+"' AND '"+rangeTo+"' group by DATE(`"+transDateQualifier+"`) ORDER BY DATE(`"+transDateQualifier+"`) DESC");
	     		   //log.info("select distinct("+transDateQualifier+") FROM "+ schemaName+"."+viewName.toLowerCase() + " where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' order by "+ transDateQualifier+" desc");
	        	   result=stmt.executeQuery("SELECT DATE(`"+transDateQualifier+"`) FROM `"+viewName.toLowerCase()+"` where `"+transDateQualifier+"` between '"+rangeFrom+"' AND '"+rangeTo+"' group by DATE(`"+transDateQualifier+"`) ORDER BY DATE(`"+transDateQualifier+"`) DESC");
	        	   while(result.next()){
	        		   transDates.add((result.getString(1)));
	        	   }
	     	   }
	     	   else
	     	   {
	     		   log.info("View doen't not exist for the view id: "+viewId);
	     	   }
		   }
		   catch(SQLException se){
			   log.info("Error while executing query: "+se);
	       }
		   catch(Exception e)
		   {
			   log.info("Exception while getting databse properties");
		   }
		   finally{
		   		if(result != null)
		   			result.close();	
		   		if(stmt != null)
		   			stmt.close();
				if(conn != null)
					conn.close();
				}
	   	log.info("View ID: "+ viewId+", TransDates Size: "+transDates.size());
	   	log.info("Distinct Trans Dates: "+ transDates);
	   	return transDates;
	}
	
	public List<String> getDistinctTransDates(Long viewId, String rangeFrom, String rangeTo, String transDateQualifier) throws SQLException
	{
		   log.info("Fetching distinct transdates for the view id "+ viewId+" between "+ rangeFrom + " and "+ rangeTo +", qualifier: "+ transDateQualifier);
		   List<String> transDates = new ArrayList<String>();
		   Connection conn = null;
		   Statement stmt = null;
		   ResultSet result = null; 
		   try{
				DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
				conn = ds.getConnection();
	    	   stmt = conn.createStatement();
	     	   DataViews dv=dataViewsRepository.findOne(viewId.longValue());
	     	   if(dv!= null)
	     	   {
	     		   String viewName = dv.getDataViewName();
	     		   log.info("SELECT DATE(fileDate) FROM `"+viewName.toLowerCase()+"` where Date(fileDate )between '"+rangeFrom+"' AND '"+rangeTo+"' group by DATE(fileDate) ORDER BY DATE(fileDate) DESC");
	     		   //log.info("select distinct("+transDateQualifier+") FROM "+ schemaName+"."+viewName.toLowerCase() + " where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' order by "+ transDateQualifier+" desc");
	        	   result=stmt.executeQuery("SELECT DATE(fileDate) FROM `"+viewName.toLowerCase()+"` where Date(fileDate) between '"+rangeFrom+"' AND '"+rangeTo+"' group by DATE(fileDate) ORDER BY DATE(fileDate) DESC");
	        	   while(result.next()){
	        		   transDates.add((result.getString(1)));
	        	   }
	     	   }
	     	   else
	     	   {
	     		   log.info("View doen't not exist for the view id: "+viewId);
	     	   }
		   }
		   catch(SQLException se){
			   log.info("Error while executing query: "+se);
	       }
		   catch(Exception e)
		   {
			   log.info("Exception while getting databse properties");
		   }
		   finally{
		   		if(result != null)
		   			result.close();	
		   		if(stmt != null)
		   			stmt.close();
				if(conn != null)
					conn.close();
				}
	   	log.info("View ID: "+ viewId+", TransDates Size: "+transDates.size());
	   	log.info("Distinct Trans Dates: "+ transDates);
	   	return transDates;
	}
   
   /**
    * Author: Shiva
    * Purpose: Fetching batch's grouped list
    * @throws ClassNotFoundException 
 * @throws ParseException 
    * **/
 /*  public List<HashMap> getGroupedBatchesList(List<String> batches, String rangeFrom, String rangeTo, Long viewId, Long tenantId, Long groupId, String qualifier, String jobReference) throws ClassNotFoundException, ParseException
   {
	   //log.info("Fetching rules grouped list for the rules: "+ batches+", View Id: "+ viewId);
	   List<HashMap> finalList = new ArrayList<HashMap>();
	   Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	   String currencyFormat = props.getProperty("currencyFormat");
	   DataViews dv = dataViewsRepository.findOne(viewId);
	   try {
		   if(dv != null)
		   {
			   String currencyCodeColName = getTransDateQualifier(new BigInteger(viewId.toString()), "CURRENCYCODE");
			   String transDateColumn = reconciliationResultService.getTransDateQualifier(new BigInteger(viewId.toString()), "TRANSDATE");
			   List<BigInteger> viewOriginalIds = getViewOriginalIds(viewId, rangeFrom, rangeTo,transDateColumn);
			   List<BigInteger> allRecIds = new ArrayList<BigInteger>();
			   if(viewOriginalIds.size()>0)
			   {
				   List<BigInteger> unRecIds = new ArrayList<BigInteger>();
				   HashMap others = new HashMap();
				   HashMap totalAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, qualifier,viewOriginalIds);
				   for(String batch: batches)
				   {
					   HashMap total = new HashMap();
					   HashMap recMap = new HashMap();
					   List<BigInteger> recIds = reconciliationResultRepository.fetchReconciledIdswithJobReferenceForSource(tenantId, groupId, viewOriginalIds, batch, viewId);
					   allRecIds.addAll(recIds);
					   HashMap reconciled = new HashMap();
					   HashMap unReconciled = new HashMap();
					   recMap.put("name", batch);
					   
					   String currencySymbolRec = "";
					   
					   List<String> currenciesRec = getDistColumnValues(recIds,currencyCodeColName,dv.getDataViewName());
					   if(currenciesRec.size()==1)
					   {
						   currencySymbolRec = currencySymbolRec+getCurrencySymbol(currenciesRec.get(0));
					   }
					   else if(currenciesRec.size()>1)
					   {
						   currencySymbolRec = currencySymbolRec+"*";
					   }

					   HashMap recAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, qualifier,recIds);
					   
					   recMap.put("tAmount", currencySymbolRec+" "+reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
					   recMap.put("tCount", recAmountCount.get("totalCount"));
					 //  recMap.put("tdCount", recIds.size());

					   recMap.put("rAmount", currencySymbolRec+" "+reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
					   recMap.put("rCount", recAmountCount.get("totalCount"));
					//   recMap.put("rdCount", recIds.size());
					   
					   recMap.put("uAmount", 0.0);
					   recMap.put("uCount", 0);
					//   recMap.put("udCount", 0);
					   
					   finalList.add(recMap);
				   }
				   //Others
				   for(BigInteger id : viewOriginalIds)
				   {
					   if(!allRecIds.contains(id))
					   {
						   unRecIds.add(id);
					   }
				   }
				   if(unRecIds.size()>0)
				   {
					   HashMap othersTotal = new HashMap();
					   HashMap othersUnRec = new HashMap();
					   HashMap othersRec = new HashMap();
					   
					   String currencySymbolOthers = "";
					   
					   List<String> currenciesOthers = getDistColumnValues(unRecIds,currencyCodeColName,dv.getDataViewName());
					   if(currenciesOthers.size()==1)
					   {
						   currencySymbolOthers = currencySymbolOthers+getCurrencySymbol(currenciesOthers.get(0));
					   }
					   else if(currenciesOthers.size()>1)
					   {
						   currencySymbolOthers = currencySymbolOthers+"*";
					   }
					   
					   HashMap unRecAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, qualifier,unRecIds);

					   others.put("name", "Others");
					   others.put("tAmount", currencySymbolOthers+" "+reconciliationResultService.getAmountInFormat(unRecAmountCount.get("totalAmount").toString(),currencyFormat));
					   others.put("tCount", unRecAmountCount.get("totalCount"));
					//   others.put("tCount", unRecIds.size());
					   
					   others.put("rAmount", 0.0);
					   others.put("rCount", 0);
					//   others.put("rCount", 0);
					   
					   others.put("uAmount", currencySymbolOthers+" "+reconciliationResultService.getAmountInFormat(unRecAmountCount.get("totalAmount").toString(),currencyFormat));
					   others.put("uCount", unRecAmountCount.get("totalCount"));
					//   others.put("uCount", unRecIds.size());

				   }
				   finalList.add(others);
			   }
		   }

	   }catch (SQLException e) {
			e.printStackTrace();
	   }
	   return finalList;
   }*/
   
 /*  public List<HashMap> getGroupedBatchesListForTarget(List<String> batches, String rangeFrom, String rangeTo, Long viewId, Long tenantId, Long groupId, String qualifier, String jobReference) throws ClassNotFoundException, ParseException
   {
	   //log.info("Fetching rules grouped list for the rules: "+ batches+", View Id: "+ viewId);
	   List<HashMap> finalList = new ArrayList<HashMap>();
	   Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	   String currencyFormat = props.getProperty("currencyFormat");
	   DataViews dv = dataViewsRepository.findOne(viewId);
	   try {
		   if(dv != null)
		   {
			   String currencyCodeColName = getTransDateQualifier(new BigInteger(viewId.toString()), "CURRENCYCODE"); 
			   String transDateColumn = reconciliationResultService.getTransDateQualifier(new BigInteger(viewId.toString()), "TRANSDATE");
			   List<BigInteger> viewOriginalIds = getTargetIds(viewId);
			   List<BigInteger> allRecIds = new ArrayList<BigInteger>();
			   if(viewOriginalIds.size()>0)
			   {
				   List<BigInteger> unRecIds = new ArrayList<BigInteger>();
				   HashMap others = new HashMap();
				   HashMap totalAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, qualifier,viewOriginalIds);
				   for(String batch: batches)
				   {
					   HashMap total = new HashMap();
					   HashMap recMap = new HashMap();
					   List<BigInteger> recIds = reconciliationResultRepository.fetchReconciledIdswithJobReferenceForTarget(tenantId, groupId, viewOriginalIds, batch, viewId);
					   allRecIds.addAll(recIds);
					   HashMap reconciled = new HashMap();
					   HashMap unReconciled = new HashMap();
					   recMap.put("name", batch);
					   
					   String currencySymbolRec = "";
					   
					   List<String> currenciesRec = getDistColumnValues(recIds,currencyCodeColName,dv.getDataViewName());
					   if(currenciesRec.size()==1)
					   {
						   currencySymbolRec = currencySymbolRec+getCurrencySymbol(currenciesRec.get(0));
					   }
					   else if(currenciesRec.size()>1)
					   {
						   currencySymbolRec = currencySymbolRec+"*";
					   }

					   HashMap recAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, qualifier,recIds);
					   
					   recMap.put("tAmount", currencySymbolRec+" "+reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
					   recMap.put("tCount", recAmountCount.get("totalCount"));

					   recMap.put("rAmount", currencySymbolRec+" "+reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
					   recMap.put("rCount", recAmountCount.get("totalCount"));
					   
					   recMap.put("uAmount", 0.0);
					   recMap.put("uCount", 0);
					   
					   finalList.add(recMap);
				   }
				   //Others
				   for(BigInteger id : viewOriginalIds)
				   {
					   if(!allRecIds.contains(id))
					   {
						   unRecIds.add(id);
					   }
				   }
				   if(unRecIds.size()>0)
				   {
					   HashMap othersTotal = new HashMap();
					   HashMap othersUnRec = new HashMap();
					   HashMap othersRec = new HashMap();
					   
					   String currencySymbolOthers = "";
					   
					   List<String> currenciesOthers = getDistColumnValues(unRecIds,currencyCodeColName,dv.getDataViewName());
					   if(currenciesOthers.size()==1)
					   {
						   currencySymbolOthers = currencySymbolOthers+getCurrencySymbol(currenciesOthers.get(0));
					   }
					   else if(currenciesOthers.size()>1)
					   {
						   currencySymbolOthers = currencySymbolOthers+"*";
					   }
					   
					   HashMap unRecAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, qualifier,unRecIds);

					   others.put("name", "Others");
					   others.put("tAmount", currencySymbolOthers+" "+reconciliationResultService.getAmountInFormat(unRecAmountCount.get("totalAmount").toString(),currencyFormat));
					   others.put("tCount", unRecAmountCount.get("totalCount"));
					   
					   others.put("rAmount", 0.0);
					   others.put("rCount", 0);
					   
					   others.put("uAmount", currencySymbolOthers+" "+reconciliationResultService.getAmountInFormat(unRecAmountCount.get("totalAmount").toString(),currencyFormat));
					   others.put("uCount", unRecAmountCount.get("totalCount"));

				   }
				   finalList.add(others);
			   }
		   }

	   }catch (SQLException e) {
			e.printStackTrace();
	   }
	   return finalList;
   }*/
   
   @Transactional
   public List<BigInteger> getOriginalIdsByDateQualifier(Long viewId, String transDateQualifier, String rangeFrom, String rangeTo) throws SQLException
   {
	   List<BigInteger> viewOriginalIds = new ArrayList<BigInteger>();
	   Connection conn = null;
	   Statement stmt = null;
	   ResultSet result = null; 
	   try{
			DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
			conn = ds.getConnection();
    	   stmt = conn.createStatement();
     	   DataViews dv=dataViewsRepository.findOne(viewId.longValue());
     	   if(dv!= null)
     	   {
     		   String viewName = dv.getDataViewName();
         	   String query = "SELECT scrIds FROM `"+viewName.toLowerCase()+"` where Date(`"+transDateQualifier+"`) between '"+rangeFrom+"' AND '"+rangeTo+"'";
         	   result=stmt.executeQuery(query);
        	   while(result.next()){
        		   viewOriginalIds.add(new BigInteger((result.getString(1))));
        	   }  
     	   }
     	   else
     	   {
     		   log.info("View doen't not exist for the view id: "+viewId);
     	   }
	   }
	   catch(SQLException se){
		   log.info("Error while executing query: "+se);
       }
	   catch(Exception e)
	   {
		   log.info("Exception while getting databse properties");
	   }
	   finally{
	   		if(result != null)
	   			result.close();	
	   		if(stmt != null)
	   			stmt.close();
			if(conn != null)
				conn.close();
	   }
   		return viewOriginalIds;
   }

   @Transactional
   public List<BigInteger> getOriginalIdsByTransDatesAndColValue(Long viewId, String rangeFrom, String rangeTo, String columnName, String columnValue, String dataType, String transDateQualifier, List<String> values) throws SQLException
   {
	   List<BigInteger> viewOriginalIds = new ArrayList<BigInteger>();
	   Connection conn = null;
	   Statement stmt = null;
	   ResultSet result = null; 
	   try{
			DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
			conn = ds.getConnection();
    	   stmt = conn.createStatement();
     	   DataViews dv=dataViewsRepository.findOne(viewId.longValue());
     	   if(dv!= null)
     	   {
     		   String viewName = dv.getDataViewName();
         	   String query = "";
         	   String valueIn = "";
         	   String dateString = values.toString();
         	   dateString = dateString.replace("[", "");
         	   dateString = dateString.replace("]", "");
         	   dateString = dateString.replace(",","|");
         	   dateString = dateString.replace(" ", "");
         	   if("DATE".equalsIgnoreCase(dataType))
         	   {
         		  query = "select scrIds from `"+viewName.toLowerCase()+"` where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' and `"+columnName +"` LIKE '%"+columnValue+"%' AND `"+transDateQualifier+"` REGEXP '"+dateString+"'";
         	   }
         	   else if("string".equalsIgnoreCase(dataType) || "VARCHAR".equalsIgnoreCase(dataType))
         	   {
         		  query = "select scrIds from `"+viewName.toLowerCase()+"` where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' and `"+columnName+"` = '"+columnValue+"' AND `"+transDateQualifier+"` REGEXP '"+dateString+"'";
         	   }
         	   else if("integer".equalsIgnoreCase(dataType) || "DECIMAL".equalsIgnoreCase(dataType))
         	   {
         		  query = "select scrIds from `"+viewName.toLowerCase()+"` where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' and `"+columnName+"` = "+columnValue+" AND `"+transDateQualifier+"` REGEXP '"+dateString+"'";
         	   }
         	   result=stmt.executeQuery(query);
        	   while(result.next()){
        		   viewOriginalIds.add(new BigInteger((result.getString(1))));
        	   }  
     	   }
     	   else
     	   {
     		   log.info("View doen't not exist for the view id: "+viewId);
     	   }
	   }
	   catch(SQLException se){
		   log.info("Error while executing query: "+se);
       }
	   catch(Exception e)
	   {
		   log.info("Exception while getting databse properties");
	   }
	   finally{
	   		if(result != null)
	   			result.close();	
	   		if(stmt != null)
	   			stmt.close();
			if(conn != null)
				conn.close();
	   }
   		return viewOriginalIds;
   }

   
   @Transactional
   public List<BigInteger> getOriginalIdsByColumnValuesNTransDate(Long viewId, String rangeFrom, String rangeTo, String qualifier, List<String> values, String dataType, String transDateQualifier, String transDate) throws SQLException
   {
	   List<BigInteger> viewOriginalIds = new ArrayList<BigInteger>();
	   Connection conn = null;
	   Statement stmt = null;
	   ResultSet result = null; 
	   try{
			DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
			conn = ds.getConnection();
    	   stmt = conn.createStatement();
     	   DataViews dv=dataViewsRepository.findOne(viewId.longValue());
     	   if(dv!= null)
     	   {
     		   String viewName = dv.getDataViewName();
         	   String query = "";
         	   String valueIn = "";
         	   if("DATE".equalsIgnoreCase(dataType))
         	   {
         			String dateString = values.toString();
         			dateString = dateString.replace("[", "");
         			dateString = dateString.replace("]", "");
         			dateString = dateString.replace(",","|");
         			dateString = dateString.replace(" ", "");
         		   ////SELECT scrIds FROM agree_application_2712.accounting_2_data_view_9 where fileDate between '2018-01-04 00:00:00' AND '2018-01-05 00:00:00' and Date_46  like '%2014-01-03%' and Date_46 REGEXP '2014-01-03|2014-01-01|2014-01-02|2014-01-04';
         		   query = "SELECT scrIds FROM `"+viewName.toLowerCase()+"` where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' and `"+transDateQualifier+"` LIKE '%"+transDate+"%' AND `"+qualifier+"` REGEXP '"+dateString+"'";
         	   }
         	   else if("string".equalsIgnoreCase(dataType) || "VARCHAR".equalsIgnoreCase(dataType))
         	   {
				   for(int i=0; i<values.size(); i++)
				   {
					   if(i == values.size()-1)
					   {
						   valueIn = valueIn + "'"+values.get(i).trim()+"'";
					   }
					   else
					   {
						   valueIn = valueIn + "'"+values.get(i).trim()+"',";
					   }
				   }
				   query = "select scrIds from `"+viewName.toLowerCase()+"` where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' and `"+transDateQualifier+"` LIKE '%"+transDate+"%' AND `"+qualifier +"` in ("+valueIn+")";
         	   }
         	   else if("integer".equalsIgnoreCase(dataType) || "DECIMAL".equalsIgnoreCase(dataType))
        	   {
				   for(int i=0; i<values.size(); i++)
				   {
					   if(i == values.size()-1)
					   {
						   valueIn = valueIn + ""+values.get(i).trim()+"";
					   }
					   else
					   {
						   valueIn = valueIn + ""+values.get(i).trim()+",";
					   }
				   }
				   query = "select scrIds from `"+viewName.toLowerCase()+"` where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' and `"+transDateQualifier+"` LIKE '%"+transDate+"%' AND `"+qualifier +"` in ("+valueIn+")";
        	   }
         	   log.info("Query:>> "+ query);
         	   result=stmt.executeQuery(query);
        	   while(result.next()){
        		   viewOriginalIds.add(new BigInteger((result.getString(1))));
        	   }  
     	   }
     	   else
     	   {
     		   log.info("View doen't not exist for the view id: "+viewId);
     	   }
	   }
	   catch(SQLException se){
		   log.info("Error while executing query: "+se);
       }
	   catch(Exception e)
	   {
		   log.info("Exception while getting databse properties");
	   }
	   finally{
	   		if(result != null)
	   			result.close();	
	   		if(stmt != null)
	   			stmt.close();
			if(conn != null)
				conn.close();
	   }
   		return viewOriginalIds;
   }
   
   @Transactional
   public List<BigInteger> getOriginalIdsByColumnAndTransDate(Long viewId, String rangeFrom, String rangeTo, String qualifier, String qualifierValue, String dataType, String transDateQualifier, String transDate) throws SQLException
   {
	   List<BigInteger> viewOriginalIds = new ArrayList<BigInteger>();
	   Connection conn = null;
	   Statement stmt = null;
	   ResultSet result = null; 
	   
	   try{
			DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
			conn = ds.getConnection();
    	   stmt = conn.createStatement();
     	   DataViews dv=dataViewsRepository.findOne(viewId.longValue());
     	   
     	   if(dv!= null)
     	   {
     		   String viewName = dv.getDataViewName();
         	   String query = "";
         	   if("DATE".equalsIgnoreCase(dataType))
         	   {
         		   //SELECT scrIds FROM agree_application_2712.accounting_2_data_view_9 where fileDate between '2018-01-04 00:00:00' AND '2018-01-05 00:00:00' and Date_46  like '%2014-01-03%' and Date_46 REGEXP '2014-01-03|2014-01-01|2014-01-02|2014-01-04';
         		   query = "SELECT scrIds FROM `"+viewName.toLowerCase()+"` where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' and `"+transDateQualifier+ "` LIKE '%"+transDate+"%'"+ " AND `"+qualifier+"` REGEXP "+"'"+qualifierValue+"'";
         	   }
         	   else if("string".equalsIgnoreCase(dataType) || "VARCHAR".equalsIgnoreCase(dataType))
         	   {
         		   query = "select scrIds from `"+viewName.toLowerCase()+"` where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' and `"+transDateQualifier+ "` LIKE '%"+transDate+"%'"+ " AND `"+qualifier +"` = '"+qualifierValue+"'";
         	   }
         	   else if("integer".equalsIgnoreCase(dataType) || "DECIMAL".equalsIgnoreCase(dataType))
         	   {
         		   query = "select scrIds from `"+viewName.toLowerCase()+"` where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' and `"+transDateQualifier+ "` LIKE '%"+transDate+"%'"+ " AND `"+qualifier +"` = "+qualifierValue+"";
         	   }
         	  // log.info("TotalIds Size: "+ query);
         	   result=stmt.executeQuery(query);
        	   while(result.next()){
        		   viewOriginalIds.add(new BigInteger((result.getString(1))));
        	   }  
     	   }
     	   else
     	   {
     		   log.info("View doen't not exist for the view id: "+viewId);
     	   }
	   }
	   catch(SQLException se){
		   log.info("Error while executing query: "+se);
       }
	   catch(Exception e)
	   {
		   log.info("Exception while getting databse properties");
	   }
	   finally{
	   		if(result != null)
	   			result.close();	
	   		if(stmt != null)
	   			stmt.close();
			if(conn != null)
				conn.close();
			}
   	return viewOriginalIds;

   }


   @Transactional
   public List<BigInteger> getOriginalIdsByTransDate(Long viewId, String rangeFrom, String rangeTo, String qualifier, String transDate, String dataType, String periodFactor) throws SQLException
   {
	   List<BigInteger> viewOriginalIds = new ArrayList<BigInteger>();
	   Connection conn = null;
	   Statement stmt = null;
	   ResultSet result = null; 
	   
	   try{
			DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
			conn = ds.getConnection();
		   stmt = conn.createStatement();
     	   DataViews dv=dataViewsRepository.findOne(viewId.longValue());
     	   if(dv!= null)
     	   {
     		   String viewName = dv.getDataViewName();
         	   String query = "";
         	   if("fileDate".equalsIgnoreCase(periodFactor))
         	   {
             	   if("DATE".equalsIgnoreCase(dataType))
             	   {
             		   query = "SELECT scrIds FROM `"+viewName.toLowerCase()+"` where Date(fileDate) between '"+rangeFrom+"' AND '"+rangeTo+"' and Date(`"+qualifier+"`) REGEXP '"+transDate+"'";
             	   }
             	   else if("string".equalsIgnoreCase(dataType) || "VARCHAR".equalsIgnoreCase(dataType))
             	   {
             		   log.info("TotalIdsQuery: select scrIds from `"+viewName.toLowerCase()+"` where Date(fileDate) between '"+rangeFrom+"' AND '"+rangeTo+"' and `"+qualifier +"` = '"+transDate+"'");
             		   query = "select scrIds from `"+viewName.toLowerCase()+"` where Date(fileDate) between '"+rangeFrom+"' AND '"+rangeTo+"' and `"+qualifier +"` = '"+transDate+"'";
             	   }
             	   else if("integer".equalsIgnoreCase(dataType) || "DECIMAL".equalsIgnoreCase(dataType))
             	   {
             		   query = "select scrIds from `"+viewName.toLowerCase()+"` where Date(fileDate) between '"+rangeFrom+"' AND '"+rangeTo+"' and `"+qualifier +"` = "+transDate+"";
             	   }
         	   }
         	   else if("dateQualifier".equalsIgnoreCase(periodFactor))
         	   {
         		   String dateQualifier = getTransDateQualifier(new BigInteger(viewId.toString()), "TRANSDATE"); 
         		   if(dateQualifier.length()>0)
         		   {
                 	   if("DATE".equalsIgnoreCase(dataType))
                 	   {
                 		   query = "SELECT scrIds FROM `"+viewName.toLowerCase()+"` where Date(`"+dateQualifier+"`) between '"+rangeFrom+"' AND '"+rangeTo+"' and Date(`"+qualifier+"`) REGEXP '"+transDate+"'";
                 	   }
                 	   else if("string".equalsIgnoreCase(dataType) || "VARCHAR".equalsIgnoreCase(dataType))
                 	   {
                 		   query = "select scrIds from `"+viewName.toLowerCase()+"` where Date(`"+dateQualifier+"`) between '"+rangeFrom+"' AND '"+rangeTo+"' and `"+qualifier +"` = '"+transDate+"'";
                 	   }
                 	   else if("integer".equalsIgnoreCase(dataType) || "DECIMAL".equalsIgnoreCase(dataType))
                 	   {
                 		   query = "select scrIds from `"+viewName.toLowerCase()+"` where Date(`"+dateQualifier+"`) between '"+rangeFrom+"' AND '"+rangeTo+"' and `"+qualifier +"` = "+transDate+"";
                 	   }
         		   }
         	   }

         	   result=stmt.executeQuery(query);
        	   while(result.next()){
        		   viewOriginalIds.add(new BigInteger((result.getString(1))));
        	   }  
     	   }
     	   else
     	   {
     		   log.info("View doen't not exist for the view id: "+viewId);
     	   }
	   }
	   catch(SQLException se){
		   log.info("Error while executing query: "+se);
       }
	   catch(Exception e)
	   {
		   log.info("Exception while getting databse properties");
	   }
	   finally{
	   		if(result != null)
	   			result.close();	
	   		if(stmt != null)
	   			stmt.close();
			if(conn != null)
				conn.close();
			}
   	return viewOriginalIds;
   }
   
   @Transactional
   public List<BigInteger> getOriginalIdsByTransDateWithCurrency(Long viewId, String rangeFrom, String rangeTo, String qualifier, String transDate, String dataType, String currencyQualifier, String currencyCode) throws SQLException
   {
	   List<BigInteger> viewOriginalIds = new ArrayList<BigInteger>();
	   Connection conn = null;
	   Statement stmt = null;
	   ResultSet result = null; 
	   
	   try{
		   DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
		   conn = ds.getConnection();
    	   stmt = conn.createStatement();
     	   DataViews dv=dataViewsRepository.findOne(viewId.longValue());
     	   
     	   if(dv!= null)
     	   {
     		   String viewName = dv.getDataViewName();
         	   String query = "";
         	   if("string".equalsIgnoreCase(dataType))
         	   {
         		   query = "select scrIds from `"+viewName.toLowerCase()+"` where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' and `"+qualifier +"` = '"+transDate+"' AND `"+currencyQualifier+"` = '"+currencyCode.trim()+"'";
         	   }
         	   else if("integer".equalsIgnoreCase(dataType))
         	   {
         		  query = "select scrIds from `"+viewName.toLowerCase()+"` where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' and `"+qualifier +"` = '"+transDate+"' AND `"+currencyQualifier+"` = '"+currencyCode.trim()+"'";
         	   }
        	   result=stmt.executeQuery(query);
        	   while(result.next()){
        		   viewOriginalIds.add(new BigInteger((result.getString(1))));
        	   }  
     	   }
     	   else
     	   {
     		   log.info("View doen't not exist for the view id: "+viewId);
     	   }
	   }
	   catch(SQLException se){
		   log.info("Error while executing query: "+se);
       }
	   catch(Exception e)
	   {
		   log.info("Exception while getting databse properties");
	   }
	   finally{
	   		if(result != null)
	   			result.close();	
	   		if(stmt != null)
	   			stmt.close();
			if(conn != null)
				conn.close();
			}
   	return viewOriginalIds;
   }
   
   public List<BigInteger> getTargetIdsByTransDates(Long viewId,String qualifier, List<String> transDates) throws SQLException
   {
	   //	log.info("Fetching reconciled and unreconciled ids for the trans dates");
	   	
		String dateString = transDates.toString();
		dateString = dateString.replace("[", "");
		dateString = dateString.replace("]", "");
		dateString = dateString.replace(",","|");
		dateString = dateString.replace(" ", "");
	   	
		List<BigInteger> viewOriginalIds = new ArrayList<BigInteger>();
		Connection conn = null;
		Statement stmt = null;
		ResultSet result = null; 
	   
		try{
			DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
			conn = ds.getConnection();			
			stmt = conn.createStatement();
     	   	DataViews dv=dataViewsRepository.findOne(viewId.longValue());
     	   	if(dv!= null)
     	   	{
     	   		String viewName = dv.getDataViewName();
     	   		result=stmt.executeQuery("SELECT scrIds FROM `"+viewName.toLowerCase()+"` where `"+qualifier+"` REGEXP '"+dateString+"'");
     	   		stmt.setFetchSize(500);
     	   		while(result.next()){
     	   			viewOriginalIds.add(new BigInteger((result.getString(1))));
     	   		}  
     	   	}
     	   	else
     	   	{
     	   		log.info("View doen't not exist for the view id: "+viewId);
     	   	}
		}
		catch(SQLException se){
			log.info("Error while executing query: "+se);
		}
		catch(Exception e)
		{
			log.info("Exception while getting databse properties");
		}
		finally{
			if(result != null)
				result.close();	
	   		if(stmt != null)
	   			stmt.close();
			if(conn != null)
				conn.close();
		}
		return viewOriginalIds;
   }
   public List<BigInteger> getOriginalIdsForDateQualifier(Long viewId, String rangeFrom, String rangeTo, String qualifier, List<String> transDates) throws SQLException
   {
		String dateString = transDates.toString();
		dateString = dateString.replace("[", "");
		dateString = dateString.replace("]", "");
		dateString = dateString.replace(",","|");
		dateString = dateString.replace(" ", "");
	   	
		List<BigInteger> viewOriginalIds = new ArrayList<BigInteger>();
		Connection conn = null;
		Statement stmt = null;
		ResultSet result = null; 
	   
		try{
			DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
			conn = ds.getConnection();
			stmt = conn.createStatement();
     	   	DataViews dv=dataViewsRepository.findOne(viewId.longValue());
     	   	if(dv!= null)
     	   	{
     	   		String viewName = dv.getDataViewName();
     	   		result=stmt.executeQuery("SELECT scrIds FROM `"+viewName.toLowerCase()+"` where Date(`"+qualifier+"`) between '"+rangeFrom+"' AND '"+rangeTo+"' AND Date(`"+qualifier+"`) REGEXP '"+dateString+"'");
     	   		stmt.setFetchSize(500);
     	   		while(result.next()){
     	   			viewOriginalIds.add(new BigInteger((result.getString(1))));
     	   		}  
     	   	}
     	   	else
     	   	{
     	   		log.info("View doen't not exist for the view id: "+viewId);
     	   	}
		}
		catch(SQLException se){
			log.info("Error while executing query: "+se);
		}
		catch(Exception e)
		{
			log.info("Exception while getting databse properties");
		}
		finally{
			if(result != null)
				result.close();	
	   		if(stmt != null)
	   			stmt.close();
			if(conn != null)
				conn.close();
		}
		return viewOriginalIds;
   }
   
   public List<BigInteger> getOriginalIdsByTransDates(Long viewId, String rangeFrom, String rangeTo, String qualifier, List<String> transDates) throws SQLException
   {
		String dateString = transDates.toString();
		dateString = dateString.replace("[", "");
		dateString = dateString.replace("]", "");
		dateString = dateString.replace(",","|");
		dateString = dateString.replace(" ", "");
	   	
		List<BigInteger> viewOriginalIds = new ArrayList<BigInteger>();
		Connection conn = null;
		Statement stmt = null;
		ResultSet result = null; 
	   
		try{
			DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
			conn = ds.getConnection();
			stmt = conn.createStatement();
     	   	DataViews dv=dataViewsRepository.findOne(viewId.longValue());
     	   
     	   	if(dv!= null)
     	   	{
     	   		String viewName = dv.getDataViewName();
     	   		result=stmt.executeQuery("SELECT scrIds FROM `"+viewName.toLowerCase()+"` where Date(`"+qualifier+"`) between '"+rangeFrom+"' AND '"+rangeTo+"' AND Date(`"+qualifier+"`) REGEXP '"+dateString+"'");
     	   		stmt.setFetchSize(500);
     	   		while(result.next()){
     	   			viewOriginalIds.add(new BigInteger((result.getString(1))));
     	   		}  
     	   	}
     	   	else
     	   	{
     	   		log.info("View doen't not exist for the view id: "+viewId);
     	   	}
		}
		catch(SQLException se){
			log.info("Error while executing query: "+se);
		}
		catch(Exception e)
		{
			log.info("Exception while getting databse properties");
		}
		finally{
			if(result != null)
				result.close();	
	   		if(stmt != null)
	   			stmt.close();
			if(conn != null)
				conn.close();
		}
		return viewOriginalIds;
   }
   
   public Map<String, List<BigInteger>> getUnRecIdsForSource(Long tenantId,Long groupId, Long viewId, String rangeFrom, String rangeTo, String transDateQualifier, List<String> transDates, String periodFactor) throws SQLException, ClassNotFoundException
   {
	   log.info("Fetching Reconciled, Un-Reconciled With Days...");
	   Map<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
	   List<BigInteger> reconciledIds = new ArrayList<BigInteger>();
	   List<BigInteger> suggestedIds = new ArrayList<BigInteger>();
	   List<BigInteger> unReconciledIds = new ArrayList<BigInteger>();
	   List<BigInteger> totalOriginalIds = new ArrayList<BigInteger>();
	   HashMap stotalIdsMap = getTotalByPeriodFactorForDays(viewId, periodFactor, rangeFrom, rangeTo,transDates);
	   totalOriginalIds = (List<BigInteger>) stotalIdsMap.get("totalIds");
	   if(totalOriginalIds.size()>0)
	   {
		   reconciledIds = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForSource(tenantId, groupId, totalOriginalIds, viewId);
		   suggestedIds = reconciliationDuplicateResultRepository.fetchReconciledIdswithStatusUnreconciledForSource(tenantId, groupId, totalOriginalIds, viewId);
		   for(BigInteger id: totalOriginalIds)
		   {
			   if(!reconciledIds.contains(id))
			   {
				   unReconciledIds.add(id);
			   }
		   }
		   unReconciledIds.removeAll(suggestedIds);
	   }
	   	finalMap.put("reconciled", reconciledIds);
	   	finalMap.put("unReconciled", unReconciledIds);
	   	finalMap.put("totalIds", totalOriginalIds);
	   	log.info("reconciled: "+ reconciledIds.size() + "unReconciled: "+ unReconciledIds.size() +"total: "+ totalOriginalIds.size());
	   return finalMap;
   }
   
   public Map<String, List<BigInteger>> getSourceRecNUnRecIdsByDays(Long tenantId,Long groupId, Long viewId, String rangeFrom, String rangeTo, String transDateQualifier, List<String> transDates, String jobReference) throws SQLException
   {
	   log.info("Fetching Reconciled, Un-Reconciled With Days...");
	   Map<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
	   List<BigInteger> reconciledIds = new ArrayList<BigInteger>();
	   List<BigInteger> unReconciledIds = new ArrayList<BigInteger>();
	   
	   List<BigInteger> totalOriginalIds = getOriginalIdsByTransDates(viewId, rangeFrom, rangeTo, transDateQualifier, transDates);
	   if(totalOriginalIds.size()>0)
	   {
			   reconciledIds = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForSource(tenantId, groupId, totalOriginalIds, viewId);
		   for(BigInteger id: totalOriginalIds)
		   {
			   if(!reconciledIds.contains(id))
			   {
				   unReconciledIds.add(id);
			   }
		   }
	   }
	   	finalMap.put("reconciled", reconciledIds);
	   	finalMap.put("unReconciled", unReconciledIds);
	   	finalMap.put("totalIds", totalOriginalIds);
	   	log.info("reconciled: "+ reconciledIds.size() + "unReconciled: "+ unReconciledIds.size() +"total: "+ totalOriginalIds.size());
	   return finalMap;
   }
   
   public Map<String, List<BigInteger>> getUnRecIdsForTarget(Long tenantId,Long groupId, Long viewId, String rangeFrom, String rangeTo, String transDateQualifier, List<String> transDates, String periodFactor) throws SQLException, ClassNotFoundException
   {
	   log.info("Fetch rec unrec for days");
	   Map<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
	   List<BigInteger> reconciledIds = new ArrayList<BigInteger>();
	   List<BigInteger> unReconciledIds = new ArrayList<BigInteger>();
	   List<BigInteger> suggestedIds = new ArrayList<BigInteger>();
	   List<BigInteger> totalOriginalIds = new ArrayList<BigInteger>();
	   HashMap stotalIdsMap = getTotalByPeriodFactor(viewId, periodFactor, rangeFrom, rangeTo);
	   if("Success".equalsIgnoreCase(stotalIdsMap.get("status").toString()))
	   {
		   totalOriginalIds = (List<BigInteger>) stotalIdsMap.get("totalIds");
	   }
	   if(totalOriginalIds.size()>0)
	   {
		   reconciledIds = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForTarget(tenantId, groupId, totalOriginalIds, viewId);
		   suggestedIds = reconciliationDuplicateResultRepository.fetchReconciledIdswithStatusUnreconciledForTarget(tenantId, groupId, totalOriginalIds, viewId);
		   for(BigInteger id: totalOriginalIds)
		   {
			   if(!reconciledIds.contains(id))
			   {
				   unReconciledIds.add(id);
			   }
		   }
		   unReconciledIds.removeAll(suggestedIds);
	   }
	   	finalMap.put("reconciled", reconciledIds);
	   	finalMap.put("unReconciled", unReconciledIds);
	   	finalMap.put("totalIds", totalOriginalIds);
	   	log.info("reconciled: "+ reconciledIds.size() + "unReconciled: "+ unReconciledIds.size() +"total: "+ totalOriginalIds.size());
	   return finalMap;
   }
   public Map<String, List<BigInteger>> getTargetRecNUnRecIdsByDays(Long tenantId,Long groupId, Long viewId, String rangeFrom, String rangeTo, String transDateQualifier, List<String> transDates, String jobReference) throws SQLException
   {
	   log.info("Fetch rec unrec for days");
	   Map<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
	   List<BigInteger> reconciledIds = new ArrayList<BigInteger>();
	   List<BigInteger> unReconciledIds = new ArrayList<BigInteger>();
	   List<BigInteger> totalOriginalIds = getTargetIdsByTransDates(viewId, transDateQualifier, transDates);
	   if(totalOriginalIds.size()>0)
	   {
			   reconciledIds = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForTarget(tenantId, groupId, totalOriginalIds, viewId);
		   for(BigInteger id: totalOriginalIds)
		   {
			   if(!reconciledIds.contains(id))
			   {
				   unReconciledIds.add(id);
			   }
		   }
	   }
	   	finalMap.put("reconciled", reconciledIds);
	   	finalMap.put("unReconciled", unReconciledIds);
	   	finalMap.put("totalIds", totalOriginalIds);
	   	log.info("reconciled: "+ reconciledIds.size() + "unReconciled: "+ unReconciledIds.size() +"total: "+ totalOriginalIds.size());
	   return finalMap;
   }
   
   /**
    * Author: Shiva
    * Purpose: Fetching column values grouped list
    * @throws ClassNotFoundException 
    * @throws SQLException 
 * @throws ParseException 
    * **/
/*   public List<HashMap> getGroupColumnValuesListForTarget(List<String> colValues, String rangeFrom, String rangeTo, Long viewId, Long tenantId, Long groupId, String amountQualifier, Long colId, String jobReference) throws ClassNotFoundException, SQLException, ParseException
   {
	   List<HashMap> finalList = new ArrayList<HashMap>();
	   Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	   String currencyFormat = props.getProperty("currencyFormat");
	   
	   DataViewsColumns dvc = dataViewsColumnsRepository.findOne(colId);
	   String columnName = "";
	   String dataType = "";
	   String currencyCodeColName = getTransDateQualifier(new BigInteger(viewId.toString()), "CURRENCYCODE"); 
	   DataViews dv = dataViewsRepository.findOne(viewId);
	   if(dv != null)
	   {
		   if(dvc != null)
		   {
			   if("VARCHAR".equals(dvc.getColDataType()) || "DATE".equalsIgnoreCase(dvc.getColDataType()))
			   {
				   dataType = dataType+"string";
			   }
			   else if("INTEGER".equalsIgnoreCase(dvc.getColDataType()) || "DECIMAL".equalsIgnoreCase(dvc.getColDataType()))
			   {
				   dataType = dataType+"integer";
			   }   
			   if("File Template".equalsIgnoreCase(dvc.getRefDvType()))
			   {
				   FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dvc.getRefDvColumn().toString()));
				   if(ftl != null)
				   {
					   columnName = columnName + ftl.getColumnAlias();
				   }
			   }
			   else if("Data View".equalsIgnoreCase(dvc.getRefDvType()) || dvc.getRefDvType() == null)
			   {
				   columnName = columnName + dvc.getColumnName();
			   }
		   }
		   for(String colValue: colValues)
		   {
			   HashMap colValuMP = new HashMap();
			   colValuMP.put("name", colValue);
			   List<BigInteger> totalOriginalIds = getOriginalIdsByTransDate(viewId, rangeFrom, rangeTo, columnName, colValue, dataType,"fileDate");
			   List<BigInteger> unRecIds = new ArrayList<BigInteger>();
			   if(totalOriginalIds.size()>0)
			   {
				   List<BigInteger> recIds = new ArrayList<BigInteger>();
				   recIds = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForTarget(tenantId, groupId, totalOriginalIds, viewId);
				   for(BigInteger id: totalOriginalIds)
				   {
					   if(!recIds.contains(id))
					   {
						   unRecIds.add(id);
					   }
				   }
				   HashMap total = new HashMap();
				   HashMap recon = new HashMap();
				   HashMap unRecon = new HashMap();
				   String currencySymbolRec = "";
				   List<String> currenciesRec = getDistColumnValues(recIds,currencyCodeColName,dv.getDataViewName());
				   if(currenciesRec.size()==1)
				   {
					   currencySymbolRec = currencySymbolRec+getCurrencySymbol(currenciesRec.get(0));
				   }
				   else if(currenciesRec.size()>1)
				   {
					   currencySymbolRec = currencySymbolRec+"*";
				   }
				   String currencySymbolUnRec = "";
				   List<String> currenciesUnRec = getDistColumnValues(unRecIds,currencyCodeColName,dv.getDataViewName());
				   if(currenciesUnRec.size()==1)
				   {
					   currencySymbolUnRec = currencySymbolUnRec+getCurrencySymbol(currenciesUnRec.get(0));
				   }
				   else if(currenciesUnRec.size()>1)
				   {
					   currencySymbolUnRec = currencySymbolUnRec+"*";
				   }
				   String currencySymbolTot = "";
				   List<String> currenciesTot = getDistColumnValues(totalOriginalIds,currencyCodeColName,dv.getDataViewName());
				   if(currenciesTot.size()==1)
				   {
					   currencySymbolTot = currencySymbolTot+getCurrencySymbol(currenciesTot.get(0));
				   }
				   else if(currenciesTot.size()>1)
				   {
					   currencySymbolTot = currencySymbolTot+"*";
				   }
				   HashMap totalAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, amountQualifier,totalOriginalIds);

				   colValuMP.put("tAmount", currencySymbolTot + " " + reconciliationResultService.getAmountInFormat(totalAmountCount.get("totalAmount").toString(),currencyFormat));
				   colValuMP.put("tCount", totalAmountCount.get("totalCount"));
				   
				   HashMap recAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, amountQualifier,recIds);

				   colValuMP.put("rAmount", currencySymbolRec + " " + reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
				   colValuMP.put("rCount", recAmountCount.get("totalCount"));
				   
				   HashMap unRecAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, amountQualifier,unRecIds);

				   colValuMP.put("uAmount", currencySymbolUnRec + " " + reconciliationResultService.getAmountInFormat(unRecAmountCount.get("totalAmount").toString(),currencyFormat));
				   colValuMP.put("uCount", unRecAmountCount.get("totalCount"));
			   }
			   finalList.add(colValuMP);
		   }
	   }
	   log.info("Grouped by trans date size: "+finalList.size());
	   return finalList;
   }*/
   
/*   public List<HashMap> getGroupColumnValuesList(List<String> colValues, String rangeFrom, String rangeTo, Long viewId, Long tenantId, Long groupId, String amountQualifier, Long colId, String jobReference) throws ClassNotFoundException, SQLException, ParseException
   {
	   List<HashMap> finalList = new ArrayList<HashMap>();
	   Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	   String currencyFormat = props.getProperty("currencyFormat");	   
	   DataViewsColumns dvc = dataViewsColumnsRepository.findOne(colId);
	   String columnName = "";
	   String dataType = "";
	   String currencyCodeColName = getTransDateQualifier(new BigInteger(viewId.toString()), "CURRENCYCODE"); 
	   DataViews dv = dataViewsRepository.findOne(viewId);
	   if(dv != null)
	   {
		   if(dvc != null)
		   {
				   if("VARCHAR".equals(dvc.getColDataType()) || "DATE".equalsIgnoreCase(dvc.getColDataType()))
				   {
					   dataType = dataType+"string";
				   }
				   else if("INTEGER".equalsIgnoreCase(dvc.getColDataType()) || "DECIMAL".equalsIgnoreCase(dvc.getColDataType()))
				   {
					   dataType = dataType+"integer";
				   }
				   
				   if("File Template".equalsIgnoreCase(dvc.getRefDvType()))
				   {
					   FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dvc.getRefDvColumn().toString()));
					   if(ftl != null)
					   {
						   columnName = columnName + ftl.getColumnAlias();
					   }
				   }
				   else if("Data View".equalsIgnoreCase(dvc.getRefDvType()) || dvc.getRefDvType() == null)
				   {
					   columnName = columnName + dvc.getColumnName();
				   }
		   }
		   for(String colValue: colValues)
		   {
			   HashMap colValuMP = new HashMap();
			   colValuMP.put("name", colValue);
			   List<BigInteger> totalOriginalIds = getOriginalIdsByTransDate(viewId, rangeFrom, rangeTo, columnName, colValue, dataType, "fileDate");
			   
			   List<BigInteger> unRecIds = new ArrayList<BigInteger>();
			   if(totalOriginalIds.size()>0)
			   {
				   List<BigInteger> recIds = new ArrayList<BigInteger>();
				   recIds = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForSource(tenantId, groupId, totalOriginalIds, viewId);
				   for(BigInteger id: totalOriginalIds)
				   {
					   if(!recIds.contains(id))
					   {
						   unRecIds.add(id);
					   }
				   }
				   
				   HashMap total = new HashMap();
				   HashMap recon = new HashMap();
				   HashMap unRecon = new HashMap();
				   
				   String currencySymbolRec = "";
				   
				   List<String> currenciesRec = getDistColumnValues(recIds,currencyCodeColName,dv.getDataViewName());
				   if(currenciesRec.size()==1)
				   {
					   currencySymbolRec = currencySymbolRec+getCurrencySymbol(currenciesRec.get(0));
				   }
				   else if(currenciesRec.size()>1)
				   {
					   currencySymbolRec = currencySymbolRec+"*";
				   }
				   
				   String currencySymbolUnRec = "";
				   
				   List<String> currenciesUnRec = getDistColumnValues(unRecIds,currencyCodeColName,dv.getDataViewName());
				   if(currenciesUnRec.size()==1)
				   {
					   currencySymbolUnRec = currencySymbolUnRec+getCurrencySymbol(currenciesUnRec.get(0));
				   }
				   else if(currenciesUnRec.size()>1)
				   {
					   currencySymbolUnRec = currencySymbolUnRec+"*";
				   }
				   
				   String currencySymbolTot = "";
				   
				   List<String> currenciesTot = getDistColumnValues(totalOriginalIds,currencyCodeColName,dv.getDataViewName());
				   if(currenciesTot.size()==1)
				   {
					   currencySymbolTot = currencySymbolTot+getCurrencySymbol(currenciesTot.get(0));
				   }
				   else if(currenciesTot.size()>1)
				   {
					   currencySymbolTot = currencySymbolTot+"*";
				   }
				   
				   HashMap totalAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, amountQualifier,totalOriginalIds);

				   colValuMP.put("tAmount", currencySymbolTot + " " + reconciliationResultService.getAmountInFormat(totalAmountCount.get("totalAmount").toString(),currencyFormat));
				   colValuMP.put("tCount", totalAmountCount.get("totalCount"));
				//   colValuMP.put("tdCount", totalOriginalIds.size());
				   
				   HashMap recAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, amountQualifier,recIds);

				   colValuMP.put("rAmount", currencySymbolRec + " " + reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
				   colValuMP.put("rCount", recAmountCount.get("totalCount"));
				//   colValuMP.put("rdCount", recIds.size());
				   
				   HashMap unRecAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, amountQualifier,unRecIds);

				   colValuMP.put("uAmount", currencySymbolUnRec + " " + reconciliationResultService.getAmountInFormat(unRecAmountCount.get("totalAmount").toString(),currencyFormat));
				   colValuMP.put("uCount", unRecAmountCount.get("totalCount"));
				//   colValuMP.put("udCount", unRecIds.size());
			   }
			   finalList.add(colValuMP);
		   }

	   }
	   log.info("Grouped by trans date size: "+finalList.size());
	   return finalList;
   }*/
   
   /**
    * Author: Shiva
    * Purpose: Fetching trans date's grouped list
    * @throws ClassNotFoundException 
    * @throws SQLException 
 * @throws ParseException 
 * @throws java.text.ParseException 
    * **/
 /*  public List<HashMap> getGroupedTransDatesList(List<String> transDates, String rangeFrom, String rangeTo, Long viewId, Long tenantId, Long groupId, String qualifier, String amountQualifier, String jobReference) throws ClassNotFoundException, SQLException, ParseException, java.text.ParseException
   {
	   //log.info("Fetching grouped list for the transdates: "+ transDates+", View Id: "+ viewId);
	   List<HashMap> finalList = new ArrayList<HashMap>();
	   Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	   String currencyFormat = props.getProperty("currencyFormat");
	   
	   String currencyCodeColName = getTransDateQualifier(new BigInteger(viewId.toString()), "CURRENCYCODE"); 
	   DataViews dv = dataViewsRepository.findOne(viewId);
	   
	   if(dv != null)
	   {
		   for(String transDate: transDates)
		   {
			   DateFormat df = new SimpleDateFormat("yyyy-MM-dd");
			   HashMap transDateMp = new HashMap();
			   Date date= df.parse(transDate);
			   df = new SimpleDateFormat("dd-MMM-yy");
			   transDateMp.put("name", df.format(date));
			   
			   List<BigInteger> totalOriginalIds = getOriginalIdsByTransDate(viewId, rangeFrom, rangeTo, qualifier, transDate, "DATE","fileDate");
			   List<BigInteger> unRecIds = new ArrayList<BigInteger>();
			   if(totalOriginalIds.size()>0)
			   {
				   List<BigInteger> recIds = new ArrayList<BigInteger>();
				   recIds = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForSource(tenantId, groupId, totalOriginalIds,viewId);

				   for(BigInteger id: totalOriginalIds)
				   {
					   if(!recIds.contains(id))
					   {
						   unRecIds.add(id);
					   }
				   }
				   
				   HashMap total = new HashMap();
				   HashMap recon = new HashMap();
				   HashMap unRecon = new HashMap();

				   String currencySymbolRec = "";
				   
				   List<String> currenciesRec = getDistColumnValues(recIds,currencyCodeColName,dv.getDataViewName());
				   if(currenciesRec.size()==1)
				   {
					   currencySymbolRec = currencySymbolRec+getCurrencySymbol(currenciesRec.get(0));
				   }
				   else if(currenciesRec.size()>1)
				   {
					   currencySymbolRec = currencySymbolRec+"*";
				   }
				   
				   String currencySymbolUnRec = "";
				   
				   List<String> currenciesUnRec = getDistColumnValues(unRecIds,currencyCodeColName,dv.getDataViewName());
				   if(currenciesUnRec.size()==1)
				   {
					   currencySymbolUnRec = currencySymbolUnRec+getCurrencySymbol(currenciesUnRec.get(0));
				   }
				   else if(currenciesUnRec.size()>1)
				   {
					   currencySymbolUnRec = currencySymbolUnRec+"*";
				   }
				   
				   String currencySymbolTot = "";
				   
				   List<String> currenciesTot = getDistColumnValues(totalOriginalIds,currencyCodeColName,dv.getDataViewName());
				   if(currenciesTot.size()==1)
				   {
					   currencySymbolTot = currencySymbolTot+getCurrencySymbol(currenciesTot.get(0));
				   }
				   else if(currenciesTot.size()>1)
				   {
					   currencySymbolTot = currencySymbolTot+"*";
				   }
				   
				   HashMap totalAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, amountQualifier,totalOriginalIds);

				   transDateMp.put("tAmount", currencySymbolTot + " " + reconciliationResultService.getAmountInFormat(totalAmountCount.get("totalAmount").toString(),currencyFormat));
				   transDateMp.put("tCount", totalAmountCount.get("totalCount"));
				//   transDateMp.put("tdCount", totalOriginalIds.size());
				   
				   HashMap recAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, amountQualifier,recIds);
				   
				   transDateMp.put("rAmount", currencySymbolRec + " " + reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
				   transDateMp.put("rCount", recAmountCount.get("totalCount"));
				//   transDateMp.put("rdCount", recIds.size());
				   
				   HashMap unRecAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, amountQualifier,unRecIds);
				   transDateMp.put("uAmount", currencySymbolUnRec + " " + reconciliationResultService.getAmountInFormat(unRecAmountCount.get("totalAmount").toString(),currencyFormat));
				   transDateMp.put("uCount", unRecAmountCount.get("totalCount"));
				//   transDateMp.put("udCount", unRecIds.size());
			   }
			   finalList.add(transDateMp);
		   }
	   }
	  
	   log.info("Grouped by trans date size: "+finalList.size());
	   return finalList;
   }*/

/*   public List<HashMap> getGroupedTransDatesListForTarget(List<String> transDates, String rangeFrom, String rangeTo, Long viewId, Long tenantId, Long groupId, String qualifier, String amountQualifier, String jobReference) throws ClassNotFoundException, SQLException, ParseException, java.text.ParseException
   {
	   //log.info("Fetching grouped list for the transdates: "+ transDates+", View Id: "+ viewId);
	   List<HashMap> finalList = new ArrayList<HashMap>();
	   Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	   String currencyFormat = props.getProperty("currencyFormat");
	   
	   String currencyCodeColName = getTransDateQualifier(new BigInteger(viewId.toString()), "CURRENCYCODE"); 
	   DataViews dv = dataViewsRepository.findOne(viewId);
	   
	   if(dv != null)
	   {
		   for(String transDate: transDates)
		   {
			   DateFormat df = new SimpleDateFormat("yyyy-MM-dd");
			   HashMap transDateMp = new HashMap();
			   Date date= df.parse(transDate);
			   df = new SimpleDateFormat("dd-MMM-yy");
			   transDateMp.put("name", df.format(date));
			   
			   List<BigInteger> totalOriginalIds = getOriginalIdsByTransDate(viewId, rangeFrom, rangeTo, qualifier, transDate, "DATE","fileDate");
			   List<BigInteger> unRecIds = new ArrayList<BigInteger>();
			   if(totalOriginalIds.size()>0)
			   {
				   List<BigInteger> recIds = new ArrayList<BigInteger>();
				   recIds = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForTarget(tenantId, groupId, totalOriginalIds,viewId);
				   for(BigInteger id: totalOriginalIds)
				   {
					   if(!recIds.contains(id))
					   {
						   unRecIds.add(id);
					   }
				   }
				   
				   HashMap total = new HashMap();
				   HashMap recon = new HashMap();
				   HashMap unRecon = new HashMap();

				   String currencySymbolRec = "";
				   
				   List<String> currenciesRec = getDistColumnValues(recIds,currencyCodeColName,dv.getDataViewName());
				   if(currenciesRec.size()==1)
				   {
					   currencySymbolRec = currencySymbolRec+getCurrencySymbol(currenciesRec.get(0));
				   }
				   else if(currenciesRec.size()>1)
				   {
					   currencySymbolRec = currencySymbolRec+"*";
				   }
				   
				   String currencySymbolUnRec = "";
				   
				   List<String> currenciesUnRec = getDistColumnValues(unRecIds,currencyCodeColName,dv.getDataViewName());
				   if(currenciesUnRec.size()==1)
				   {
					   currencySymbolUnRec = currencySymbolUnRec+getCurrencySymbol(currenciesUnRec.get(0));
				   }
				   else if(currenciesUnRec.size()>1)
				   {
					   currencySymbolUnRec = currencySymbolUnRec+"*";
				   }
				   
				   String currencySymbolTot = "";
				   
				   List<String> currenciesTot = getDistColumnValues(totalOriginalIds,currencyCodeColName,dv.getDataViewName());
				   if(currenciesTot.size()==1)
				   {
					   currencySymbolTot = currencySymbolTot+getCurrencySymbol(currenciesTot.get(0));
				   }
				   else if(currenciesTot.size()>1)
				   {
					   currencySymbolTot = currencySymbolTot+"*";
				   }
				   
				   HashMap totalAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, amountQualifier,totalOriginalIds);

				   transDateMp.put("tAmount", currencySymbolTot + " " + reconciliationResultService.getAmountInFormat(totalAmountCount.get("totalAmount").toString(),currencyFormat));
				   transDateMp.put("tCount", totalAmountCount.get("totalCount"));
				   
				   HashMap recAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, amountQualifier,recIds);
				   
				   transDateMp.put("rAmount", currencySymbolRec + " " + reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
				   transDateMp.put("rCount", recAmountCount.get("totalCount"));
				   
				   HashMap unRecAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, amountQualifier,unRecIds);
				   transDateMp.put("uAmount", currencySymbolUnRec + " " + reconciliationResultService.getAmountInFormat(unRecAmountCount.get("totalAmount").toString(),currencyFormat));
				   transDateMp.put("uCount", unRecAmountCount.get("totalCount"));
			   }
			   finalList.add(transDateMp);
		   }
	   }
	  
	   log.info("Grouped by trans date size: "+finalList.size());
	   return finalList;
   }*/
   
   /**
    * Author: Shiva
    * Purpose: Fetching process grouped list
    * @throws ClassNotFoundException 
    * @throws SQLException 
 * @throws ParseException 
    * **/
 /*  public List<HashMap> getGroupedProcessList(List<BigInteger> sourceIds, String rangeFrom, String rangeTo, Long tenantId, Long groupId, String jobReference) throws ClassNotFoundException, SQLException, ParseException
   {
	   log.info("Fetching grouped list for process tenant id: "+ tenantId+", group id: "+ groupId);
	   List<Long> ruleIds = ruleGroupDetailsRepository.fetchByRuleGroupIdAndTenantId(groupId, tenantId);
	   Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	   String currencyFormat = props.getProperty("currencyFormat");
	   List<HashMap> finalList = new ArrayList<HashMap>();
	   for(BigInteger viewId : sourceIds)
	   {
		   String qualifier = reconciliationResultService.getQualifier(viewId);
		   String currencyCodeColName = getTransDateQualifier(new BigInteger(viewId.toString()), "CURRENCYCODE"); 
		   if(qualifier.length()>0)
		   {
			   HashMap sourceMap = new HashMap();
			   String transDateColumn = reconciliationResultService.getTransDateQualifier(new BigInteger(viewId.toString()), "TRANSDATE");
			   List<BigInteger> totalOriginalIds = getViewOriginalIds(viewId.longValue(), rangeFrom, rangeTo,transDateColumn);
			   List<BigInteger> unRecIds = new ArrayList<BigInteger>();
			   if(totalOriginalIds.size()>0)
			   {
				   List<BigInteger> recIds = new ArrayList<BigInteger>();
				   recIds = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForSource(tenantId,groupId, totalOriginalIds, viewId.longValue());
				   for(BigInteger id : totalOriginalIds)
				   {
					   if(!recIds.contains(id))
					   {
						   unRecIds.add(id);
					   }
				   }
				   HashMap total = new HashMap();
				   HashMap reconciled = new HashMap();
				   HashMap unReconciled = new HashMap();
				   DataViews dv = dataViewsRepository.findOne(viewId.longValue());
				   if(dv != null)
				   {
					   sourceMap.put("id", viewId);
					   sourceMap.put("name", dv.getDataViewDispName());
					   log.info("Reconciled: "+ recIds.size());
					   log.info("Un-Reconciled: "+ unRecIds.size());
					   log.info("Total: "+ totalOriginalIds.size());
					   String currencySymbolRec = "";
					   List<String> currenciesRec = getDistColumnValues(recIds,currencyCodeColName,dv.getDataViewName());
					   if(currenciesRec.size()==1)
					   {
						   currencySymbolRec = currencySymbolRec+getCurrencySymbol(currenciesRec.get(0));
					   }
					   else if(currenciesRec.size()>1)
					   {
						   currencySymbolRec = currencySymbolRec+"*";
					   }
					   String currencySymbolUnRec = "";
					   List<String> currenciesUnRec = getDistColumnValues(unRecIds,currencyCodeColName,dv.getDataViewName());
					   if(currenciesUnRec.size()==1)
					   {
						   currencySymbolUnRec = currencySymbolUnRec+getCurrencySymbol(currenciesUnRec.get(0));
					   }
					   else if(currenciesUnRec.size()>1)
					   {
						   currencySymbolUnRec = currencySymbolUnRec+"*";
					   }
					   String currencySymbolTot = "";
					   List<String> currenciesTot = getDistColumnValues(totalOriginalIds,currencyCodeColName,dv.getDataViewName());
					   if(currenciesTot.size()==1)
					   {
						   currencySymbolTot = currencySymbolTot+getCurrencySymbol(currenciesTot.get(0));
					   }
					   else if(currenciesTot.size()>1)
					   {
						   currencySymbolTot = currencySymbolTot+"*";
					   }
					   HashMap totalCountNAmount = reconciliationResultService.getCountNAmountForDVId(viewId, tenantId, qualifier,totalOriginalIds);

					   sourceMap.put("tAmount", currencySymbolTot + " " + reconciliationResultService.getAmountInFormat(totalCountNAmount.get("totalAmount").toString(),currencyFormat));
					   sourceMap.put("tCount", totalCountNAmount.get("totalCount"));
				//	   sourceMap.put("tdCount", totalOriginalIds.size());
					   HashMap reconCountNAmount = reconciliationResultService.getCountNAmountForDVId(viewId, tenantId, qualifier,recIds);

					   sourceMap.put("rAmount", currencySymbolRec + " " + reconciliationResultService.getAmountInFormat(reconCountNAmount.get("totalAmount").toString(),currencyFormat));
					   sourceMap.put("rCount", reconCountNAmount.get("totalCount"));
				//	   sourceMap.put("rdCount", recIds.size());
					   HashMap unRecCountNAmount = reconciliationResultService.getCountNAmountForDVId(viewId, tenantId, qualifier,unRecIds);

					   sourceMap.put("uAmount", currencySymbolUnRec + " " +reconciliationResultService.getAmountInFormat(unRecCountNAmount.get("totalAmount").toString(),currencyFormat));
					   sourceMap.put("uCount", unRecCountNAmount.get("totalCount"));
					   sourceMap.put("udCount", unRecIds.size());
					   finalList.add(sourceMap);
				   }
			   }
		   }
	   }
	   log.info("Final Process List: "+ finalList);
	   return finalList;
   }*/
   
/*   public List<HashMap> getGroupedProcessListForTarget(List<BigInteger> sourceIds, String rangeFrom, String rangeTo, Long tenantId, Long groupId, String jobReference) throws ClassNotFoundException, SQLException, ParseException
   {
	   log.info("Fetching grouped list for process tenant id: "+ tenantId+", group id: "+ groupId);
	   List<Long> ruleIds = ruleGroupDetailsRepository.fetchByRuleGroupIdAndTenantId(groupId, tenantId);
	   Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	   String currencyFormat = props.getProperty("currencyFormat");
	   List<HashMap> finalList = new ArrayList<HashMap>();
	   for(BigInteger viewId : sourceIds)
	   {
		   String qualifier = reconciliationResultService.getQualifier(viewId);
		   String currencyCodeColName = getTransDateQualifier(new BigInteger(viewId.toString()), "CURRENCYCODE"); 
		   if(qualifier.length()>0)
		   {
			   HashMap sourceMap = new HashMap();
			   String transDateColumn = reconciliationResultService.getTransDateQualifier(new BigInteger(viewId.toString()), "TRANSDATE");
			   List<BigInteger> totalOriginalIds = getViewOriginalIds(viewId.longValue(), rangeFrom, rangeTo,transDateColumn);
			   List<BigInteger> unRecIds = new ArrayList<BigInteger>();
			   if(totalOriginalIds.size()>0)
			   {
				   List<BigInteger> recIds = new ArrayList<BigInteger>();
				   recIds = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForTarget(tenantId,groupId, totalOriginalIds, viewId.longValue());
				   for(BigInteger id : totalOriginalIds)
				   {
					   if(!recIds.contains(id))
					   {
						   unRecIds.add(id);
					   }
				   }
				   HashMap total = new HashMap();
				   HashMap reconciled = new HashMap();
				   HashMap unReconciled = new HashMap();
				   DataViews dv = dataViewsRepository.findOne(viewId.longValue());
				   if(dv != null)
				   {
					   sourceMap.put("id", viewId);
					   sourceMap.put("name", dv.getDataViewDispName());
					   log.info("Reconciled: "+ recIds.size());
					   log.info("Un-Reconciled: "+ unRecIds.size());
					   log.info("Total: "+ totalOriginalIds.size());
					   String currencySymbolRec = "";
					   List<String> currenciesRec = getDistColumnValues(recIds,currencyCodeColName,dv.getDataViewName());
					   if(currenciesRec.size()==1)
					   {
						   currencySymbolRec = currencySymbolRec+getCurrencySymbol(currenciesRec.get(0));
					   }
					   else if(currenciesRec.size()>1)
					   {
						   currencySymbolRec = currencySymbolRec+"*";
					   }
					   String currencySymbolUnRec = "";
					   List<String> currenciesUnRec = getDistColumnValues(unRecIds,currencyCodeColName,dv.getDataViewName());
					   if(currenciesUnRec.size()==1)
					   {
						   currencySymbolUnRec = currencySymbolUnRec+getCurrencySymbol(currenciesUnRec.get(0));
					   }
					   else if(currenciesUnRec.size()>1)
					   {
						   currencySymbolUnRec = currencySymbolUnRec+"*";
					   }
					   String currencySymbolTot = "";
					   List<String> currenciesTot = getDistColumnValues(totalOriginalIds,currencyCodeColName,dv.getDataViewName());
					   if(currenciesTot.size()==1)
					   {
						   currencySymbolTot = currencySymbolTot+getCurrencySymbol(currenciesTot.get(0));
					   }
					   else if(currenciesTot.size()>1)
					   {
						   currencySymbolTot = currencySymbolTot+"*";
					   }
					   HashMap totalCountNAmount = reconciliationResultService.getCountNAmountForDVId(viewId, tenantId, qualifier,totalOriginalIds);

					   sourceMap.put("tAmount", currencySymbolTot + " " + reconciliationResultService.getAmountInFormat(totalCountNAmount.get("totalAmount").toString(),currencyFormat));
					   sourceMap.put("tCount", totalCountNAmount.get("totalCount"));
					   HashMap reconCountNAmount = reconciliationResultService.getCountNAmountForDVId(viewId, tenantId, qualifier,recIds);

					   sourceMap.put("rAmount", currencySymbolRec + " " + reconciliationResultService.getAmountInFormat(reconCountNAmount.get("totalAmount").toString(),currencyFormat));
					   sourceMap.put("rCount", reconCountNAmount.get("totalCount"));
					   HashMap unRecCountNAmount = reconciliationResultService.getCountNAmountForDVId(viewId, tenantId, qualifier,unRecIds);

					   sourceMap.put("uAmount", currencySymbolUnRec + " " +reconciliationResultService.getAmountInFormat(unRecCountNAmount.get("totalAmount").toString(),currencyFormat));
					   sourceMap.put("uCount", unRecCountNAmount.get("totalCount"));
					   finalList.add(sourceMap);
				   }
			   }
		   }
	   }
	   log.info("Final Process List: "+ finalList);
	   return finalList;
   }*/
   
   
   /* Getting Reconciled, Un-Reconciled Ids for Source*/
   public Map<String, List<BigInteger>> getSourceRecNUnRecIdsWithRange(Long dataViewId, Long tenantId, List<BigInteger> srcTotalIds, Long groupId) throws ClassNotFoundException{
	   	List<Long> ruleIds = rulesRepository.fetchIdsByViewId(dataViewId, tenantId);
	   	Map<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
	   	List<BigInteger> reconciledIds = new ArrayList<BigInteger>();
	   	List<BigInteger> sourceUnreconciledIds = new ArrayList<BigInteger>();
	   	if(ruleIds.size()>0)
	   	{
	   		reconciledIds = reconciliationResultRepository.fetchOriginalRowIdsByTenantIdAndRuleIdsAndSourceViewId(tenantId, ruleIds, dataViewId, groupId);
	   	}
	   	if(srcTotalIds.size()>0)
	   	{
				for(BigInteger id : srcTotalIds)
				{
					if(!reconciledIds.contains(id))
					{
						sourceUnreconciledIds.add(id);
					}
				}
	   	}
	   	finalMap.put("reconciled", reconciledIds);
	   	finalMap.put("unReconciled", sourceUnreconciledIds);
	   	log.info("Source View ID: "+dataViewId+", Total Size: "+srcTotalIds.size());
	   	log.info("Source View ID: "+dataViewId+", Reconciled Size: "+reconciledIds.size());
	   	log.info("Source View ID: "+dataViewId+", UnReconciled Size: "+sourceUnreconciledIds.size());
	   	return finalMap;
   }
   
   /* Getting Reconciled Map<String, List<Long>> and UnReconciled Id's for Source*/
   public Map<String, List<BigInteger>> getSourceRecNUnRecIdsByBatches(Long dataViewId, Long tenantId, List<BigInteger> srcTotalIds, Long groupId, List<String> batches) throws ClassNotFoundException{
	   	Map<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
	   	List<BigInteger> reconciledIds = new ArrayList<BigInteger>();
	   	List<BigInteger> unReconciled = new ArrayList<BigInteger>();
	   	if(srcTotalIds.size()>0)
	   	{
		   	if(batches.size()>0)
		   	{
		   		reconciledIds = reconciliationResultRepository.fetchReconciledIdswittBatchesForSource(tenantId, groupId, srcTotalIds, batches, dataViewId);
		   	}

	   		for(BigInteger id: srcTotalIds)
	   		{
	   			if(!reconciledIds.contains(id))
	   			{
	   				unReconciled.add(id);
	   			}
	   		}
	   	}
	   	finalMap.put("reconciled", reconciledIds);
	   	finalMap.put("unReconciled", unReconciled);
	   	log.info("Source View ID: "+dataViewId+", Reconciled Size: "+reconciledIds.size());
		return finalMap;
   }
   
   /* Getting Reconciled Map<String, List<Long>> and UnReconciled Id's for Source*/
   public Map<String, List<BigInteger>> getTargetRecNUnRecIdsByBatches(Long dataViewId, Long tenantId, List<BigInteger> srcTotalIds, Long groupId, List<String> batches) throws ClassNotFoundException{
	   	Map<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
	   	List<BigInteger> reconciledIds = new ArrayList<BigInteger>();
	   	if(batches.size()>0 && srcTotalIds.size()>0)
	   	{
	   		reconciledIds = reconciliationResultRepository.fetchReconciledIdswithBatchesForTarget(tenantId, groupId, srcTotalIds, batches);
	   	}
	   	finalMap.put("reconciled", reconciledIds);
	   	log.info("Source View ID: "+dataViewId+", Reconciled Size: "+reconciledIds.size());
			return finalMap;
   }
   
	public String getQualifierColName(Long columnId) throws ClassNotFoundException{
    	DataViewsColumns dvc = dataViewsColumnsRepository.findOne(columnId);
    	String qualifier = "";
    	if(dvc != null)
    	{
			if("File Template".equalsIgnoreCase(dvc.getRefDvType()))
			{
	    		FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dvc.getRefDvColumn()));
	    		if(ftl != null)
	    		{
	    			qualifier = ftl.getColumnAlias();
	    		}
			}
			else if("Data View".equalsIgnoreCase(dvc.getRefDvType()) || dvc.getRefDvType() == null)
			{
				qualifier = dvc.getColumnName();
			}
    	}
    	else
    	{
    		log.info("There is no Qualifier column found for the column id: "+ columnId);
    	}
    	return qualifier;
	}

	
   public List<BigInteger> fetchTargetIds(Long sViewId, Long tViewId, List<Long> rowIds, FormConfig formConf) throws SQLException, ClassNotFoundException, ParseException
   {
	   log.info("Fetching custo filter target row ids...");
		String dateRange = "";
		String dateOperator = "";
		String amountOperator = "";
		
		if(formConf != null)
		{
			String jsonStr = formConf.getValue();
			JSONParser parser = new JSONParser();
			JSONArray json = (JSONArray) parser.parse(jsonStr);
			Iterator i = json.iterator();
			while (i.hasNext()) {
				JSONObject slide = (JSONObject) i.next();
				String parameter = (String)slide.get("parameter");
				if(parameter.equalsIgnoreCase("TRANSDATE"))
				{
					dateRange = dateRange + slide.get("value");
					dateOperator = dateOperator + slide.get("operator");
				}
				else if(parameter.equalsIgnoreCase("AMOUNT"))
				{
					amountOperator = amountOperator+slide.get("operator");
				}
				else if(parameter.equalsIgnoreCase("CURRENCYCODE"))
				{
					//currencySId = currencySId + Long.parseLong(slide.get("sColId").toString());
					//currencyTId = currencyTId + Long.parseLong(slide.get("tColId").toString());
				}
				/*else if(parameter.equalsIgnoreCase("KEY COMPONENT"))
				{
					kcSId = kcSId + Long.parseLong(slide.get("sColId").toString());
					kcTId = kcTId + Long.parseLong(slide.get("tColId").toString());
				}*/
		    }
		}
		log.info("Date Operator: "+dateOperator+", Date Range: "+dateRange+", Amount Operator: "+ amountOperator);
	   
	   List<BigInteger> targetRowIds = new ArrayList<BigInteger>();
	   List<BigInteger> finalTargetRowIds = new ArrayList<BigInteger>();
	   
	   String[] dateRangeArray = dateRange.split("\\,");
	   int dateBack = Integer.parseInt(dateRangeArray[0]);
	   int dateForward = Integer.parseInt(dateRangeArray[1]);
	   
	   // Converting original row ids list as string
	   String rowIdsAsString = rowIds.toString();
	   rowIdsAsString = rowIdsAsString.replace("[", "");
	   rowIdsAsString = rowIdsAsString.replace("]", "");
	   
	   Connection conn = null;
	   Statement stmt = null;
	   ResultSet currencyRS = null;
	   ResultSet providerRS = null;
	   ResultSet amountRS = null;
	   ResultSet dateRS = null;
	   ResultSet firstFilterRS = null;
	   ResultSet totalSumRS = null;
	   try{
		   DataViews sourceView = dataViewsRepository.findOne(sViewId.longValue());
		   DataViews targetView = dataViewsRepository.findOne(tViewId.longValue());
		   if(sourceView != null && targetView != null)
		   {
			   DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
			   conn = ds.getConnection();
	    	   stmt = conn.createStatement();
	    	   
	    	   DataViewsColumns amountDVCSource = dataViewsColumnsRepository.findByDataViewIdAndQualifier(sViewId, "AMOUNT");
	    	   DataViewsColumns currencyDVCSource = dataViewsColumnsRepository.findByDataViewIdAndQualifier(sViewId, "CURRENCYCODE");
	    	   DataViewsColumns proDVCSource = dataViewsColumnsRepository.findByDataViewIdAndQualifier(sViewId, "GROUPBY_COLUMN");
	    	   DataViewsColumns trnsDtDVCSource = dataViewsColumnsRepository.findByDataViewIdAndQualifier(sViewId, "TRANSDATE");
	    	   
	    	   DataViewsColumns amountDVCTarget = dataViewsColumnsRepository.findByDataViewIdAndQualifier(tViewId, "AMOUNT");
	    	   DataViewsColumns currencyDVCTarget = dataViewsColumnsRepository.findByDataViewIdAndQualifier(tViewId, "CURRENCYCODE");
	    	   DataViewsColumns proDVCTarget = dataViewsColumnsRepository.findByDataViewIdAndQualifier(tViewId, "GROUPBY_COLUMN");
	    	   DataViewsColumns trnsDtDVCTarget = dataViewsColumnsRepository.findByDataViewIdAndQualifier(tViewId, "TRANSDATE");
	    	   
	    	   String currencyProviderDateQuery = "";
	    	   // Building query for Currency Code
	    	   String whereString = "";
	    	   if(currencyDVCSource != null && currencyDVCTarget != null)
	    	   {
	    		   List<String> currencyCodes = new ArrayList<String>();
	    		   String sColName = getQualifierColName(currencyDVCSource.getId());
	    		   String tColName = getQualifierColName(currencyDVCTarget.getId());
	    		   if(sColName.length()>0 && tColName.length()>0)
	    		   {
	    			   String currencyCode = " AND " + tColName + " IN (";
	    			   currencyRS = stmt.executeQuery("select distinct(`" + sColName + "`) from `"+sourceView.getDataViewName().toLowerCase() + "` where scrIds in ("+rowIdsAsString+")");
	    			   while(currencyRS.next()){
	    				   currencyCodes.add(currencyRS.getString(1));
	    			   }
	    			   if(currencyCodes.size()>0)
	    			   {
	    				   for(int i=0; i<currencyCodes.size(); i++)
	    				   {
	    					   if(i == currencyCodes.size()-1)
	    					   {
	    						   currencyCode = currencyCode + "'"+currencyCodes.get(i).trim()+"')";
	    					   }
	    					   else
	    					   {
	    						   currencyCode = currencyCode + "'"+currencyCodes.get(i).trim()+"',";
	    					   }
	    				   }
	    			   }
	    			   whereString = whereString + currencyCode;
	    		   }
	    	   }
	    	   // Building query for provider name
	    	   if(proDVCSource != null && proDVCTarget != null)
	    	   {
	    		   List<String> providerNames = new ArrayList<String>();
	    		   String sProviderName = getQualifierColName(proDVCSource.getId());
	    		   String tProviderName = getQualifierColName(proDVCTarget.getId());
	    		   if(sProviderName.length()>0 && tProviderName.length()>0)
	    		   {
	    			   String providerName = " AND " + tProviderName + " IN (";
	    			   providerRS = stmt.executeQuery("select distinct(`" + sProviderName + "`) from `"+sourceView.getDataViewName().toLowerCase() + "` where scrIds in ("+rowIdsAsString+")");
	    			   while(providerRS.next()){
	    				   providerNames.add(providerRS.getString(1));
	    			   }
	    			   if(providerNames.size()>0)
	    			   {
	    				   for(int i=0; i<providerNames.size(); i++)
	    				   {
	    					   if(i == providerNames.size()-1)
	    					   {
	    						   providerName = providerName + "'"+providerNames.get(i).trim()+"')";
	    					   }
	    					   else
	    					   {
	    						   providerName = providerName + "'"+providerNames.get(i).trim()+"',";
	    					   }
	    				   }
	    			   }
	    			   //log.info("Provider Name Query: "+ providerName);
	    			   whereString = whereString + providerName;
	    		   }
	    	   }
	    	   // Building query for trans date
	    	   if(trnsDtDVCSource != null && trnsDtDVCTarget != null)
	    	   {
	    		   List<String> transDates = new ArrayList<String>();
	    		   String sDateName = getQualifierColName(trnsDtDVCSource.getId());
	    		   String tDateName = getQualifierColName(trnsDtDVCTarget.getId());
	    		   if(sDateName.length()>0 && tDateName.length()>0)
	    		   {
	    			   dateRS = stmt.executeQuery("select distinct(`" + sDateName + "`) from `"+sourceView.getDataViewName().toLowerCase() + "` where scrIds in ("+rowIdsAsString+")");
	    			   while(dateRS.next()){
	    				   transDates.add(dateRS.getString(1));
	    			   }
	    			   log.info("Distinct Trans Date: "+transDates);
	    			   String dateQuery = "";
	    			   if(transDates.size()>0)//dateOperator
	    			   {
	    				   for(int i=0; i<transDates.size(); i++)
	    				   {
	    					   String date = transDates.get(i).toString().trim();
	    					   LocalDate localDate = LocalDate.parse(date.trim());
	    					   LocalDate dateMinus = localDate.plusDays(dateBack);
	    					   LocalDate datePlus = localDate.plusDays(dateForward);
/*	    					   LocalDate dateMinus = localDate.plusDays(-5);
	    					   LocalDate datePlus = localDate.plusDays(10);*/
	    					   if(i == transDates.size()-1)
	    					   {
	    						   /*dateQuery = dateQuery +"("+ tDateName +" BETWEEN '"+dateMinus+"' AND '"+datePlus+"')";*/
	    						   dateQuery = dateQuery +"("+ tDateName +" "+dateOperator+" '"+dateMinus+"' AND '"+datePlus+"')";
	    					   }
	    					   else
	    					   {
	    						   /*dateQuery = dateQuery +"("+ tDateName +" BETWEEN '"+dateMinus+"' AND '"+datePlus+"') OR ";*/
	    						   dateQuery = dateQuery +"("+ tDateName +" "+dateOperator+" '"+dateMinus+"' AND '"+datePlus+"') OR ";
	    					   }
	    				   }
	    				   dateQuery = " AND ("+dateQuery+")";
	    			   }
	    			   whereString = whereString + dateQuery;
	    		   }
	    	   }
	    	   log.info("FinalWhereString: "+ whereString);
	    	   if(whereString.length()>0)
	    	   {
	    		   if(amountDVCSource != null && amountDVCTarget != null)
	    		   {
		    		   String sAmountQualifier = getQualifierColName(amountDVCSource.getId());
		    		   String tAmountQualifier = getQualifierColName(amountDVCTarget.getId());
	    			   if(sAmountQualifier.length()>0 && tAmountQualifier.length()>0)
	    			   {
	    				   Double totalAmount = 0.0;
			    		   firstFilterRS = stmt.executeQuery("select distinct(scrIds) from `"+targetView.getDataViewName().toLowerCase() + "` where 1=1 "+whereString);
		        		   while(firstFilterRS.next()){
		        			   targetRowIds.add(new BigInteger(firstFilterRS.getString(1)));
		        		   }
			    		   totalSumRS = stmt.executeQuery("select SUM(`"+ sAmountQualifier +"`) from `"+sourceView.getDataViewName().toLowerCase() + "` where scrIds in ("+rowIdsAsString+")");
		        		   while(totalSumRS.next()){
		        			   totalAmount = totalAmount + Double.parseDouble(totalSumRS.getString(1));
		        		   }
		        		  // log.info("Target Row Ids Before Amount: "+ targetRowIds);
		        		   if(targetRowIds.size()>0)
		        		   {
		        			   for(BigInteger id : targetRowIds)
		        			   {
		        				   Double amount = 0.0;
		        				   ResultSet rs = stmt.executeQuery("SELECT `"+tAmountQualifier+"` from `"+targetView.getDataViewName().toLowerCase() + "` where scrIds = "+id);
		        				   while(rs.next())
		        				   {
		        					   amount = amount + Double.parseDouble(rs.getString(1));
		        				   }
		        				   if(amount <= totalAmount)
		        				   {
		        					   finalTargetRowIds.add(id);
		        				   }
		        				   rs.close();
		        			   }
		        		   }
	    			   }
	    		   }
	    	   }
		   }
	   }
	   catch(SQLException se){
		   log.info("Error while executing query: "+se);
       }
	   finally{
	   		if(providerRS != null)
	   			providerRS.close();
	   		if(currencyRS != null)
	   			currencyRS.close();
	   		if(amountRS != null)
	   			amountRS.close();
	   		if(firstFilterRS != null)
	   			firstFilterRS.close();
	   		if(totalSumRS != null)
	   			totalSumRS.close();
	   		if(stmt != null)
	   			stmt.close();
			if(conn != null)
				conn.close();
			}
	   log.info("Final Total Target Ids: "+ finalTargetRowIds);
	   return finalTargetRowIds;
   }
   //*********************************************************************//
   //Fetching reconciled UnReconciled Ids within range for Source
   public Map<String, List<BigInteger>> getRecUnRecWithRangeSource(List<BigInteger> totalIds, String jobReference, Long tenantId, Long groupId, Long dataViewId){
	   log.info("Fetching reconciled, un-reconciled...");
	   	Map<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
	   	List<BigInteger> reconciled = new ArrayList<BigInteger>();
	   	List<BigInteger> unReconciled = new ArrayList<BigInteger>();
	   	if(totalIds.size()>0)
	   	{
	   		log.info("Without Job Reference");
	   		reconciled = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForSource(tenantId, groupId, totalIds,dataViewId);

	   		for(BigInteger id: totalIds)
	   		{
	   			if(!reconciled.contains(id))
	   			{
	   				unReconciled.add(id);
	   			}
	   		}
	   	}
	   	finalMap.put("reconciled", reconciled);
	   	finalMap.put("unReconciled", unReconciled);
	   	finalMap.put("totalIds", totalIds);
	   	log.info("Reconciled: "+ reconciled.size()+", UnReconciled: "+ unReconciled.size()+", Total: "+totalIds.size());
	   	return finalMap;
  }

   //Fetching reconciled UnReconciled Ids within range for Source
   public Map<String, List<BigInteger>> getRecUnRecGroupByColumnValuesForSource(Long viewId, Long columnId, String rangeFrom, String rangeTo, List<String> colValues, String jobReference, Long tenantId, Long groupId, String periodFactor, String typeOfRecData) throws SQLException{
	   	log.info("Fetching reconciled, un-reconciled group by column name for source...");
	   	List<BigInteger> totalIds = getTotalIdsGroupByColumnValues(columnId, viewId, rangeFrom, rangeTo, colValues, periodFactor);	   	
	   	Map<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
	   	List<BigInteger> reconciled = new ArrayList<BigInteger>();
	   	List<BigInteger> unReconciled = new ArrayList<BigInteger>();
		List<BigInteger> suggestedIds = new ArrayList<BigInteger>();
	   	if(totalIds.size()>0)
	   	{
	   		log.info("Without Job Reference");
	   		if("suggestion".equalsIgnoreCase(typeOfRecData))
	   		{
	   			reconciled = reconciliationDuplicateResultRepository.fetchReconciledIdswithStatusUnreconciledForSource(tenantId, groupId, totalIds, viewId);
	   			suggestedIds.addAll(reconciled);
	   		}
	   		else
	   		{
	   			reconciled = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForSource(tenantId, groupId, totalIds, viewId);
	   		}
	   		for(BigInteger id: totalIds)
	   		{
	   			if(!reconciled.contains(id))
	   			{
	   				unReconciled.add(id);
	   			}
	   		}
	   		unReconciled.removeAll(suggestedIds);
	   	}
	   	finalMap.put("reconciled", reconciled);
	   	finalMap.put("unReconciled", unReconciled);
	   	finalMap.put("totalIds", totalIds);
	   	log.info("Reconciled: "+ reconciled.size()+", UnReconciled: "+ unReconciled.size()+", Total: "+totalIds.size());
	   	return finalMap;
  }
   
   public Map<String, List<BigInteger>> getRecUnRecGroupByColumnValuesForTarget(Long viewId, Long columnId, String rangeFrom, String rangeTo, List<String> colValues, String jobReference, Long tenantId, Long groupId, String typeOfRecData) throws SQLException, ClassNotFoundException{
	   	log.info("Fetching reconciled, un-reconciled group by column name for source...");
	   	List<BigInteger> totalIds = new ArrayList<BigInteger>();
	    HashMap stotalIdsMap = getTotalByPeriodFactor(viewId, "fileDate", rangeFrom, rangeTo);
	   	Map<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
	   	List<BigInteger> reconciled = new ArrayList<BigInteger>();
	   	List<BigInteger> unReconciled = new ArrayList<BigInteger>();
	   	List<BigInteger> suggestedIds = new ArrayList<BigInteger>();
	    if("Success".equalsIgnoreCase(stotalIdsMap.get("status").toString()))
		{
	    	totalIds = (List<BigInteger>) stotalIdsMap.get("totalIds");
		}
	   	if(totalIds.size()>0)
	   	{
		   	log.info("Without Job Reference");
		   	if("suggestion".equalsIgnoreCase(typeOfRecData))
		   	{
		   		reconciled = reconciliationDuplicateResultRepository.fetchReconciledIdswithStatusUnreconciledForTarget(tenantId, groupId, totalIds, viewId);
		   		suggestedIds.addAll(reconciled);
		   	}
		   	else
		   	{
		   		reconciled = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForTarget(tenantId, groupId, totalIds, viewId);	
		   	}
		   	
	   		for(BigInteger id: totalIds)
	   		{
	   			if(!reconciled.contains(id))
	   			{
	   				unReconciled.add(id);
	   			}
	   		}
	   		unReconciled.removeAll(suggestedIds);
	   	}
	   	finalMap.put("reconciled", reconciled);
	   	finalMap.put("unReconciled", unReconciled);
	   	finalMap.put("totalIds", totalIds);
	   	log.info("Reconciled: "+ reconciled.size()+", UnReconciled: "+ unReconciled.size()+", Total: "+totalIds.size());
	   	return finalMap;
 }
 
   //Fetching reconciled UnReconciled Ids within range for Target
   public Map<String, List<BigInteger>> getRecUnRecWithRangeTarget(List<BigInteger> totalIds, String jobReference, Long tenantId, Long groupId, Long viewId){
	   log.info("Fetching reconciled, un-reconciled for the view id...");
	   	Map<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
	   	List<BigInteger> reconciled = new ArrayList<BigInteger>();
	   	List<BigInteger> unReconciled = new ArrayList<BigInteger>();
	   	if(totalIds.size()>0)
	   	{
		   	log.info("Without Job Reference");
		   	reconciled = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForTarget(tenantId, groupId, totalIds,viewId);
	   		for(BigInteger id: totalIds)
	   		{
	   			if(!reconciled.contains(id))
	   			{
	   				unReconciled.add(id);
	   			}
	   		}
	   	}
	   	finalMap.put("reconciled", reconciled);
	   	finalMap.put("unReconciled", unReconciled);
	   	finalMap.put("totalIds", totalIds);
	   	log.info("Reconciled: "+ reconciled.size()+", UnReconciled: "+ unReconciled.size()+", Total: "+totalIds.size());
	   	return finalMap;
  }
   
   //Fetching reconciled UnReconciled Ids within range for Target
   public Map<String, List<BigInteger>> getRecUnRecWithRangeTargetData(List<BigInteger> totalIds, List<String> jobReference, Long tenantId, Long groupId, Long dataViewId){
	   log.info("Fetching reconciled, un-reconciled for the view id...");
	   	Map<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
	   	List<BigInteger> reconciled = new ArrayList<BigInteger>();
	   	List<BigInteger> unReconciled = new ArrayList<BigInteger>();
	   	if(totalIds.size()>0)
	   	{
		   	reconciled =reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForTarget(tenantId,groupId,totalIds,dataViewId);
	   		for(BigInteger id: totalIds)
	   		{
	   			if(!reconciled.contains(id))
	   			{
	   				unReconciled.add(id);
	   			}
	   		}
	   	}
	   	finalMap.put("reconciled", reconciled);
	   	finalMap.put("unReconciled", unReconciled);
	   	finalMap.put("totalIds", totalIds);
	   	log.info("Reconciled: "+ reconciled.size()+", UnReconciled: "+ unReconciled.size()+", Total: "+totalIds.size());
	   	return finalMap;
  }

   /* Getting Reconciled Map<String, List<Long>> and UnReconciled Id's for Source*/
   public Map<String, List<BigInteger>> getSourceRecNUnRecIdsByRules(Long dataViewId, Long tenantId, List<BigInteger> srcTotalIds, Long groupId, List<Long> ruleIds) throws ClassNotFoundException{
   	Map<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
	List<BigInteger> reconciledIds = new ArrayList<BigInteger>();
	List<BigInteger> unReconciledIds = new ArrayList<BigInteger>();
   	if(srcTotalIds.size()>0)
   	{
   	   	if(ruleIds.size()>0)
   	   	{
   	   	  	reconciledIds = reconciliationResultRepository.fetchReconciledIdsWithOutJobRefWithStatusReconciledForSource(tenantId,ruleIds,groupId, srcTotalIds, dataViewId);
   	   	}
   	   	for(BigInteger id : srcTotalIds)
   	   	{
   	   		if(!reconciledIds.contains(id))
   	   		{
   	   			unReconciledIds.add(id);
   	   		}
   	   	}
   	}
	finalMap.put("reconciled", reconciledIds);
	finalMap.put("unReconciled", unReconciledIds);
	log.info("Source View ID: "+dataViewId+", Reconciled Size: "+reconciledIds.size());
   	return finalMap;
   }
   
   
   public Map<String, List<BigInteger>> getTargetRecNUnRecIdsByRules(Long dataViewId, Long tenantId, List<BigInteger> srcTotalIds, Long groupId, List<Long> ruleIds, String jobReference) throws ClassNotFoundException{
	   	Map<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
	   	List<BigInteger> reconciledIds = new ArrayList<BigInteger>();
	   	List<BigInteger> unReconIds = new ArrayList<BigInteger>();
	   	if(srcTotalIds.size()>0)
	   	{
		   	if(ruleIds.size()>0)
		   	{
			   reconciledIds = reconciliationResultRepository.fetchReconciledIdsWithOutJobRefWithStatusReconciledForTarget(tenantId, ruleIds, groupId, srcTotalIds,dataViewId);
		   	}

		   	for(BigInteger id : srcTotalIds)
		   	{
		   		if(!reconciledIds.contains(id))
		   		{
		   			unReconIds.add(id);
		   		}
		   	}
	   	}
	   	finalMap.put("reconciled", reconciledIds);
	   	finalMap.put("unReconciled", unReconIds);
		finalMap.put("totalIds", srcTotalIds);
	   	log.info("Target View ID: "+dataViewId+", Reconciled Size: "+reconciledIds.size());
	   	return finalMap;
	   }
   
   public HashMap getCountAndAmountRecordWise(Long viewId, List<Long> rowIds, String amountQualifier) throws SQLException
   {
	   log.info("Fetching count and amounts based on view and rowids...");
	   HashMap finalMap = new HashMap();
		   	String idsString = rowIds.toString();
		   	idsString=idsString.replace("[", "");
		   	idsString=idsString.replace("]", "");
		   Connection conn = null;
		   Statement stmt = null;
		   ResultSet result = null; 
		   
	    	Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	    	String currencyFormat = props.getProperty("currencyFormat");
		   
		   try{
				DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
				conn = ds.getConnection();
	    	   stmt = conn.createStatement();
	     	   DataViews dv=dataViewsRepository.findOne(viewId.longValue());
	     	   String amount = "";
	     	   if(dv!= null)
	     	   {
	     		   String viewName = dv.getDataViewName();
	     		   log.info("Query: select sum(`"+amountQualifier+"`) from `"+viewName.toLowerCase()+"` where scrIds in ("+idsString+")");
	        	   result=stmt.executeQuery("select sum(`"+amountQualifier+"`) from `"+viewName.toLowerCase()+"` where scrIds in ("+idsString+")");
	        	   while(result.next()){
	        		   amount = amount+result.getString(1);
	        	   }  
	     	   }
	     	   else
	     	   {
	     		   log.info("View doen't not exist for the view id: "+viewId);
	     	   }
	     	 // String amountInCurrency = reconciliationResultService.getAmountInFormat(amount.replace(",", ""),currencyFormat);
	     	  Double amountDouble = Double.parseDouble(amount);
	     	  finalMap.put("amount", amountDouble);
	     	  finalMap.put("amountQualifier", amountQualifier);
	     	  finalMap.put("count", rowIds.size());
		   }
		   catch(SQLException se){
			   log.info("Error while executing query: "+se);
	       }
		   catch(Exception e)
		   {
			   log.info("Exception while getting databse properties");
		   }
		   finally{
		   		if(result != null)
		   			result.close();	
		   		if(stmt != null)
		   			stmt.close();
				if(conn != null)
					conn.close();
				}

	   return finalMap;
   }
   
   public String getDataViewColumnName(Long columnId)
   {
	   log.info("Fetching columnName based on column id: "+ columnId);
	   String columnName = "";
	   DataViewsColumns dvc = dataViewsColumnsRepository.findOne(columnId);
	   if(dvc != null)
	   {
			if("File Template".equalsIgnoreCase(dvc.getRefDvType()))
			{
				FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dvc.getRefDvColumn().toString()));
				if(ftl != null)
				{
					columnName = columnName+ftl.getColumnAlias();
				}
			}
			else if("Data View".equalsIgnoreCase(dvc.getRefDvType()) || dvc.getRefDvType() == null)
			{
				columnName = columnName+dvc.getColumnName();
			}
	   }
	   return columnName;
   }

  public List<BigInteger> fetchTotalIdsByColmnNameNColValues(Long viewId, String dataViewColName, String rangeFrom, String rangeTo, List<String> colValues, Long colId) throws SQLException
  {
	 log.info("Fetching total ids based on column name and column values within range...");
	 List<BigInteger> totalIds = new ArrayList<BigInteger>();
	 HashMap columnMap = accountingDataService.getDataViewColumnNameByColumnId(colId);
	 String dataType = "";
	 if(columnMap.get("columnName").toString().length()>0 && columnMap.get("dataType") != null)
	 {
		 dataType = dataType + columnMap.get("dataType");
	 }
 	   String dateString = colValues.toString();
 	   String inValues = "";
	 if("DATE".equalsIgnoreCase(dataType))
	 {
   	   dateString = dateString.replace("[", "");
   	   dateString = dateString.replace("]", "");
   	   dateString = dateString.replace(",","|");
   	   dateString = dateString.replace(" ", "");
	 }
	 else if("STRING".equalsIgnoreCase(dataType) || "VARCHAR".equalsIgnoreCase(dataType))
	 {
		  for(int i=0; i<colValues.size(); i++)
		  {
			  if(i==colValues.size()-1)
			  {
				  inValues = inValues + "'"+colValues.get(i).trim()+"'";
			  }
			  else
			  {
				  inValues = inValues + "'"+colValues.get(i).trim()+"',";
			  }
		  }
	 }
	 else if("INTEGER".equalsIgnoreCase(dataType) || "DECIMAL".equalsIgnoreCase(dataType))
	 {
		  for(int i=0; i<colValues.size(); i++)
		  {
			  if(i==colValues.size()-1)
			  {
				  inValues = inValues +colValues.get(i).trim();
			  }
			  else
			  {
				  inValues = inValues +colValues.get(i).trim()+",";
			  }
		  }
	 }

	 Connection conn = null;
	 Statement stmt = null;
	 ResultSet result = null; 
	 try{
		 	DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
		 	conn = ds.getConnection();
		   stmt = conn.createStatement();
    	   DataViews dv=dataViewsRepository.findOne(viewId.longValue());
    	   String amount = "";
    	   if(dv!= null)
    	   {
    		   String viewName = dv.getDataViewName();
    		   if("DATE".equalsIgnoreCase(dataType))
    		   {
    			   log.info("SELECT scrIds FROM `"+viewName.toLowerCase()+"` where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' AND `"+dataViewColName+"` REGEXP '"+dateString+"'");
    			   result=stmt.executeQuery("SELECT scrIds FROM `"+viewName.toLowerCase()+"` where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' AND `"+dataViewColName+"` REGEXP '"+dateString+"'");
    		   }
    		   else{
    			   log.info("select scrIds from `"+viewName.toLowerCase()+"` where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' AND `"+dataViewColName+"` IN ("+inValues+")");
    	       	   result=stmt.executeQuery("select scrIds from `"+viewName.toLowerCase()+"` where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' AND `"+dataViewColName+"` IN ("+inValues+")");
    		   }
 	       	   while(result.next()){
	       		   totalIds.add(new BigInteger(result.getString(1)));
	       	   }  
    	   }
    	   else
    	   {
    		   log.info("View doen't not exist for the view id: "+viewId);
    	   }
	   }
	   catch(SQLException se){
		   log.info("Error while executing query: "+se);
      }
	   catch(Exception e)
	   {
		   log.info("Exception while getting databse properties");
	   }
	   finally{
	   		if(result != null)
	   			result.close();	
	   		if(stmt != null)
	   			stmt.close();
			if(conn != null)
				conn.close();
			}
	 
	 return totalIds;
  }
  
  public List<BigInteger> getTargetIdsGroupByColumnValues(Long columnId, Long viewId, List<String> colValues) throws SQLException
  {
	  log.info("Fetching recon unreconciled ids for source group by columna name...");
	  List<BigInteger> totalIds = new ArrayList<BigInteger>();
	  
	  DataViewsColumns dvc = dataViewsColumnsRepository.findOne(columnId);
	  String columnName = "";
	  String dataType = "";
	  if(dvc != null)
	  {
		  if("VARCHAR".equals(dvc.getColDataType()) || "string".equals(dvc.getColDataType()))
		  {
			  dataType = dataType+"string";
		  }
		  else if("INTEGER".equalsIgnoreCase(dvc.getColDataType()) || "DECIMAL".equalsIgnoreCase(dvc.getColDataType()))
		  {
			  dataType = dataType+"integer";
		  }
		  else if("DATE".equalsIgnoreCase(dvc.getColDataType()))
		  {
			  dataType = dataType+"date";
		  }
		  if("File Template".equalsIgnoreCase(dvc.getRefDvType()))
		  {
				FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dvc.getRefDvColumn().toString()));
				if(ftl != null)
				{
					columnName = columnName + ftl.getColumnAlias();
				}
		  }
		  else if("Data View".equalsIgnoreCase(dvc.getRefDvType()) || dvc.getRefDvType() == null)
		  {
			columnName = columnName + dvc.getColumnName();
		  }
		  String colValStr = "";
		  if("string".equalsIgnoreCase(dataType))
		  {
			  if(colValues.size()>0)
			  {
				  for(int i=0; i<colValues.size(); i++)
				  {
					  if(i==colValues.size()-1)
					  {
						  colValStr = colValStr + "'"+colValues.get(i).trim()+"'";
					  }
					  else
					  {
						  colValStr = colValStr + "'"+colValues.get(i).trim()+"',";
					  }
				  }
			  }
		  }
		  else if("integer".equalsIgnoreCase(dataType))
		  {
			  if(colValues.size()>0)
			  {
				  for(int i=0; i<colValues.size(); i++)
				  {
					  if(i==colValues.size()-1)
					  {
						  colValStr = colValStr +colValues.get(i).trim();
					  }
					  else
					  {
						  colValStr = colValStr +colValues.get(i).trim()+",";
					  }
				  }
			  }
		  }
		  else if("DATE".equalsIgnoreCase(dataType))
		  {
			  	colValStr = colValues.toString();
			  	colValStr = colValStr.replace("[", "");
			  	colValStr = colValStr.replace("]", "");
			  	colValStr = colValStr.replace(",","|");
			  	colValStr = colValStr.replace(" ", "");
		  }
		  Connection conn = null;
		  Statement stmt = null;
		  ResultSet result = null; 
		  try{
				DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
				conn = ds.getConnection();
			   stmt = conn.createStatement();
			   DataViews dv=dataViewsRepository.findOne(viewId.longValue());
			   if(dv!= null)
			   {
				   String viewName = dv.getDataViewName();
				   if("DATE".equalsIgnoreCase(dataType))
				   {
					   log.info("SELECT scrIds FROM `"+viewName.toLowerCase()+"` where `"+columnName+"` REGEXP '"+colValStr+"'");
					   result=stmt.executeQuery("SELECT scrIds FROM `"+viewName.toLowerCase()+"` where `"+columnName+"` REGEXP '"+colValStr+"'");
				   }
				   else
				   {
					   log.info("SELECT scrIds from `"+viewName.toLowerCase()+"` WHERE `"+columnName+"` IN ("+colValStr+")");
				       result=stmt.executeQuery("SELECT scrIds from `"+viewName.toLowerCase()+"` WHERE `"+columnName+"` IN ("+colValStr+")");					   
				   }
				   stmt.setFetchSize(500);
			       while(result.next()){
			    	   totalIds.add(new BigInteger(result.getString(1)));
			       }  
			   }
			   else
			   {
				   log.info("View doen't not exist for the view id: "+viewId);
			   }
		  }
		  catch(SQLException se){
			   log.info("Error while executing query: "+se);
		  }
		  catch(Exception e)
		  {
			  log.info("Exception while getting databse properties");
		  }
		  finally{	
			  if(result != null)
				  result.close();	
			  if(stmt != null)
				  stmt.close();
			  if(conn != null)
				  conn.close();
		  }
	  }
	  log.info("TotalIds Size: "+ totalIds.size());
	  return totalIds;
  }
  
  public List<BigInteger> getTotalIdsGroupByColumnValues(Long columnId, Long viewId, String rangeFrom, String rangeTo, List<String> colValues, String periodFactor) throws SQLException
  {
	  log.info("Fetching recon unreconciled ids for source group by columna name...");
	  List<BigInteger> totalIds = new ArrayList<BigInteger>();
	  
	  DataViewsColumns dvc = dataViewsColumnsRepository.findOne(columnId);
	  String columnName = "";
	  String dataType = "";
	  if(dvc != null)
	  {
		  if("VARCHAR".equals(dvc.getColDataType()) || "string".equals(dvc.getColDataType()))
		  {
			  dataType = dataType+"string";
		  }
		  else if("INTEGER".equalsIgnoreCase(dvc.getColDataType()) || "DECIMAL".equalsIgnoreCase(dvc.getColDataType()))
		  {
			  dataType = dataType+"integer";
		  }
		  else if("DATE".equalsIgnoreCase(dvc.getColDataType()))
		  {
			  dataType = dataType+"date";
		  }
		  if("File Template".equalsIgnoreCase(dvc.getRefDvType()))
		  {
				FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dvc.getRefDvColumn().toString()));
				if(ftl != null)
				{
					columnName = columnName + ftl.getColumnAlias();
				}
		  }
		  else if("Data View".equalsIgnoreCase(dvc.getRefDvType()) || dvc.getRefDvType() == null)
		  {
			columnName = columnName + dvc.getColumnName();
		  }
		  String colValStr = "";
		  if("string".equalsIgnoreCase(dataType))
		  {
			  if(colValues.size()>0)
			  {
				  for(int i=0; i<colValues.size(); i++)
				  {
					  if(i==colValues.size()-1)
					  {
						  colValStr = colValStr + "'"+colValues.get(i).trim()+"'";
					  }
					  else
					  {
						  colValStr = colValStr + "'"+colValues.get(i).trim()+"',";
					  }
				  }
			  }
		  }
		  else if("integer".equalsIgnoreCase(dataType))
		  {
			  if(colValues.size()>0)
			  {
				  for(int i=0; i<colValues.size(); i++)
				  {
					  if(i==colValues.size()-1)
					  {
						  colValStr = colValStr +colValues.get(i).trim();
					  }
					  else
					  {
						  colValStr = colValStr +colValues.get(i).trim()+",";
					  }
				  }
			  }
		  }
		  else if("DATE".equalsIgnoreCase(dataType))
		  {
			  	colValStr = colValues.toString();
			  	colValStr = colValStr.replace("[", "");
			  	colValStr = colValStr.replace("]", "");
			  	colValStr = colValStr.replace(",","|");
			  	colValStr = colValStr.replace(" ", "");
		  }
		  Connection conn = null;
		  Statement stmt = null;
		  ResultSet result = null; 
		  try{
			  	DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
			  	conn = ds.getConnection();
			  	stmt = conn.createStatement();
			   DataViews dv=dataViewsRepository.findOne(viewId.longValue());
			   if(dv!= null)
			   {
				   String viewName = dv.getDataViewName();
				   if("fileDate".equalsIgnoreCase(periodFactor))
				   {
					   if("DATE".equalsIgnoreCase(dataType))
					   {
						   log.info("SELECT scrIds FROM `"+viewName.toLowerCase()+"` where Date(fileDate) between '"+rangeFrom+"' AND '"+rangeTo+"' AND Date(`"+columnName+"`) REGEXP '"+colValStr+"'");
						   result=stmt.executeQuery("SELECT scrIds FROM `"+viewName.toLowerCase()+"` where Date(fileDate) between '"+rangeFrom+"' AND '"+rangeTo+"' AND Date(`"+columnName+"`) REGEXP '"+colValStr+"'");
					   }
					   else
					   {
						   log.info("SELECT scrIds from `"+viewName.toLowerCase()+"` WHERE Date(fileDate) between '"+rangeFrom+"' AND '"+rangeTo+"' AND `"+columnName+"` IN ("+colValStr+")");
					       result=stmt.executeQuery("SELECT scrIds from `"+viewName.toLowerCase()+"` WHERE Date(fileDate) between '"+rangeFrom+"' AND '"+rangeTo+"' AND `"+columnName+"` IN ("+colValStr+")");					   
					   }
				   }
				   else if("dateQualifier".equalsIgnoreCase(periodFactor))
				   {
					   String dateQualifier = reconciliationResultService.getTransDateQualifier(BigInteger.valueOf(viewId), "TRANSDATE");
					   if("DATE".equalsIgnoreCase(dataType))
					   {
						   log.info("SELECT scrIds FROM `"+viewName.toLowerCase()+"` where Date(`"+dateQualifier+"`) between '"+rangeFrom+"' AND '"+rangeTo+"' AND Date(`"+columnName+"`) REGEXP '"+colValStr+"'");
						   result=stmt.executeQuery("SELECT scrIds FROM `"+viewName.toLowerCase()+"` where Date(`"+dateQualifier+"`) between '"+rangeFrom+"' AND '"+rangeTo+"' AND `"+columnName+"` REGEXP '"+colValStr+"'");
					   }
					   else
					   {
						   log.info("SELECT scrIds from `"+viewName.toLowerCase()+"` WHERE Date(`"+dateQualifier+"`) between '"+rangeFrom+"' AND '"+rangeTo+"' AND `"+columnName+"` IN ("+colValStr+")");
					       result=stmt.executeQuery("SELECT scrIds from `"+viewName.toLowerCase()+"` WHERE Date(`"+dateQualifier+"`) between '"+rangeFrom+"' AND '"+rangeTo+"' AND `"+columnName+"` IN ("+colValStr+")");					   
					   }
				   }

				   stmt.setFetchSize(500);
			       while(result.next()){
			    	   totalIds.add(new BigInteger(result.getString(1)));
			       }  
			   }
			   else
			   {
				   log.info("View doen't not exist for the view id: "+viewId);
			   }
		  }
		  catch(SQLException se){
			   log.info("Error while executing query: "+se);
		  }
		  catch(Exception e)
		  {
			  log.info("Exception while getting databse properties");
		  }
		  finally{	
			  if(result != null)
				  result.close();	
			  if(stmt != null)
				  stmt.close();
			  if(conn != null)
				  conn.close();
		  }
	  }
	  log.info("TotalIds Size: "+ totalIds.size());
	  return totalIds;
  }
  
  public List<String> getDistinctColValuesWithFilteredGroupBy(Long viewId, String rangeFrom, String rangeTo, Long columnId, String transDateQualifier, String transDate) throws SQLException
  {
	  log.info("Fetching distinct column values for the view id: "+ viewId + ", column id: "+ columnId);
	  List<String> distColValues = new ArrayList<String>();
	  
	  Connection conn = null;
	  Statement stmt = null;
	  ResultSet result = null; 
	  try{
		  DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
		  conn = ds.getConnection();
		   stmt = conn.createStatement();
		   DataViews dv=dataViewsRepository.findOne(viewId.longValue());
		   DataViewsColumns dvc = dataViewsColumnsRepository.findOne(columnId);
		   String dataType = "";
		   if(dv!= null && dvc != null)
		   {
			   String columnName = "";
			   if("File Template".equalsIgnoreCase(dvc.getRefDvType()))
			   {
				   FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dvc.getRefDvColumn().toString()));
				   if(ftl != null)
				   {
					   columnName = columnName + ftl.getColumnAlias();
				   }
			   }
			   else if("Data View".equalsIgnoreCase(dvc.getRefDvType()) || dvc.getRefDvType() == null)
			   {
				   columnName = columnName + dvc.getColumnName();
			   }
			   dataType = dvc.getColDataType();
			   if(columnName.length()>0)
			   {		
				   String viewName = dv.getDataViewName();
				   if("DATE".equalsIgnoreCase(dataType))
				   {
					   result=stmt.executeQuery("SELECT DATE(`"+columnName+"`) FROM `"+viewName.toLowerCase()+"` where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' AND `"+transDateQualifier +"` LIKE '%"+transDate+"%' group by DATE(`"+columnName+"`) ORDER BY DATE(`"+columnName+"`) DESC");   
				   }
				   else if("VARCHAR".equalsIgnoreCase(dataType) || "STRING".equalsIgnoreCase(dataType) || "INTEGER".equalsIgnoreCase(dataType) || "DECIMAL".equalsIgnoreCase(dataType))
				   {
					   result=stmt.executeQuery("SELECT distinct(`"+ columnName+"`) from `"+viewName.toLowerCase()+"` WHERE fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' AND `"+transDateQualifier +"` LIKE '%"+transDate+"%' ORDER BY `"+columnName+"` asc");
				   }
			       while(result.next()){
			    	   distColValues.add(result.getString(1));
			       }  
			   }
		   }
		   else
		   {
			   log.info("View doen't not exist for the view id: "+viewId);
		   }
	  }
	  catch(SQLException se){
		   log.info("Error while executing query: "+se);
	  }
	  catch(Exception e)
	  {
		  log.info("Exception while getting databse properties");
	  }
	  finally{	
		  if(result != null)
			  result.close();	
		  if(stmt != null)
			  stmt.close();
		  if(conn != null)
			  conn.close();
	  }

	  log.info("Distinct column values: "+ distColValues);
	  return distColValues;
  }

  public List<String> getDistinctDaysWithFilteredGroupByColumnValue(Long viewId, String rangeFrom, String rangeTo, String transDateQualifier, Long columnId, String columnValue) throws SQLException
  {
	  log.info("Fetching distinct column values for the view id: "+ viewId + ", column id: "+ columnId);
	  List<String> distColValues = new ArrayList<String>();
	  Connection conn = null;
	  Statement stmt = null;
	  ResultSet result = null; 
	  try{
			DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
			conn = ds.getConnection();
		   stmt = conn.createStatement();
		   DataViews dv=dataViewsRepository.findOne(viewId.longValue());
		   DataViewsColumns dvc = dataViewsColumnsRepository.findOne(columnId);
		   String dataType = "";
		   if(dv!= null && dvc != null)
		   {
			   String columnName = "";
			   if("File Template".equalsIgnoreCase(dvc.getRefDvType()))
			   {
				   FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dvc.getRefDvColumn().toString()));
				   if(ftl != null)
				   {
					   columnName = columnName + ftl.getColumnAlias();
				   }
			   }
			   else if("Data View".equalsIgnoreCase(dvc.getRefDvType()) || dvc.getRefDvType() == null)
			   {
				   columnName = columnName + dvc.getColumnName();
			   }
			   dataType = dvc.getColDataType();
			   if(columnName.length()>0)
			   {		
				   String viewName = dv.getDataViewName();
				   if("DATE".equalsIgnoreCase(dataType))
				   {
					   //"SELECT DATE("+transDateQualifier+") FROM "+schemaName+"."+viewName.toLowerCase()+" where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' group by DATE("+transDateQualifier+") ORDER BY DATE("+transDateQualifier+") DESC"
					   result=stmt.executeQuery("SELECT DATE(`"+transDateQualifier+"`) FROM `"+viewName.toLowerCase()+"` where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' AND `"+columnName +"` LIKE '%"+columnValue+"%' group by DATE(`"+transDateQualifier+"`) ORDER BY DATE(`"+transDateQualifier+"`) DESC");
					   //result=stmt.executeQuery("SELECT distinct("+ columnName+") from "+schemaName+"."+viewName.toLowerCase()+" WHERE fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' ORDER BY "+columnName+" desc");   
				   }
				   else if("VARCHAR".equalsIgnoreCase(dataType) || "STRING".equalsIgnoreCase(dataType))
				   {
					   result=stmt.executeQuery("SELECT distinct(`"+ transDateQualifier+"`) from `"+viewName.toLowerCase()+"` WHERE fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' AND `"+columnName +"` = '"+columnValue+"' ORDER BY `"+transDateQualifier+"` DESC");
				   }
				   else if("INTEGER".equalsIgnoreCase(dataType) || "DECIMAL".equalsIgnoreCase(dataType))
				   {
					   result=stmt.executeQuery("SELECT distinct(`"+ transDateQualifier+"`) from `"+viewName.toLowerCase()+"` WHERE fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' AND `"+columnName +"` = "+columnValue+" ORDER BY `"+transDateQualifier+"` DESC");
				   }
			       while(result.next()){
			    	   distColValues.add(result.getString(1));
			       }  
			   }
		   }
		   else
		   {
			   log.info("View doen't not exist for the view id: "+viewId);
		   }
	  }
	  catch(SQLException se){
		   log.info("Error while executing query: "+se);
	  }
	  catch(Exception e)
	  {
		  log.info("Exception while getting databse properties");
	  }
	  finally{	
		  if(result != null)
			  result.close();	
		  if(stmt != null)
			  stmt.close();
		  if(conn != null)
			  conn.close();
	  }

	  log.info("Distinct column values: "+ distColValues);
	  return distColValues;
  }

  
  public List<String> getDistinctColValues(Long viewId, String rangeFrom, String rangeTo, Long columnId, String periodFactor) throws SQLException
  {
	  log.info("Fetching distinct column values for the view id: "+ viewId + ", column id: "+ columnId);
	  List<String> distColValues = new ArrayList<String>();
	  
	  Connection conn = null;
	  Statement stmt = null;
	  ResultSet result = null; 
	  try{
		  DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
		  conn = ds.getConnection();
		   stmt = conn.createStatement();
		   DataViews dv=dataViewsRepository.findOne(viewId.longValue());
		   DataViewsColumns dvc = dataViewsColumnsRepository.findOne(columnId);
		   String dataType = "";
		   if(dv!= null && dvc != null)
		   {
			   String columnName = "";
			   if("File Template".equalsIgnoreCase(dvc.getRefDvType()))
			   {
				   FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dvc.getRefDvColumn().toString()));
				   if(ftl != null)
				   {
					   columnName = columnName + ftl.getColumnAlias();
				   }
			   }
			   else if("Data View".equalsIgnoreCase(dvc.getRefDvType()) || dvc.getRefDvType() == null)
			   {
				   columnName = columnName + dvc.getColumnName();
			   }
			   dataType = dvc.getColDataType();
			   if(columnName.length()>0)
			   {		
				   String viewName = dv.getDataViewName();
				   if("fileDate".equalsIgnoreCase(periodFactor))
				   {
					   if("DATE".equalsIgnoreCase(dataType))
					   {
						   log.info("DistinctColumnsQuery: SELECT DATE(`"+columnName+"`) FROM `"+viewName.toLowerCase()+"` where Date(fileDate) between '"+rangeFrom+"' AND '"+rangeTo+"' group by DATE(`"+columnName+"`) ORDER BY DATE(`"+columnName+"`) DESC");
						   result=stmt.executeQuery("SELECT DATE(`"+columnName+"`) FROM `"+viewName.toLowerCase()+"` where Date(fileDate) between '"+rangeFrom+"' AND '"+rangeTo+"' group by DATE(`"+columnName+"`) ORDER BY DATE(`"+columnName+"`) DESC");
					   }
					   else if("VARCHAR".equalsIgnoreCase(dataType) || "STRING".equalsIgnoreCase(dataType) || "INTEGER".equalsIgnoreCase(dataType) || "DECIMAL".equalsIgnoreCase(dataType))
					   {
						   log.info("DistinctColumnsQuery: SELECT distinct(`"+ columnName+"`) from `"+viewName.toLowerCase()+"` WHERE Date(fileDate) between '"+rangeFrom+"' AND '"+rangeTo+"' ORDER BY `"+columnName+"` asc");
						   result=stmt.executeQuery("SELECT distinct(`"+ columnName+"`) from `"+viewName.toLowerCase()+"` WHERE Date(fileDate) between '"+rangeFrom+"' AND '"+rangeTo+"' ORDER BY `"+columnName+"` asc");
					   }
					   
				   }
				   else if("dateQualifier".equalsIgnoreCase(periodFactor))
				   {
					   String transDateColumn = reconciliationResultService.getTransDateQualifier(new BigInteger(viewId.toString()), "TRANSDATE");
					   if(transDateColumn.length()>0)
					   {
						   if("DATE".equalsIgnoreCase(dataType))
						   {
							   log.info("DistinctColumnsQuery: SELECT DATE(`"+columnName+"`) FROM `"+viewName.toLowerCase()+"` where Date(`"+transDateColumn+"`) between '"+rangeFrom+"' AND '"+rangeTo+"' group by DATE(`"+columnName+"`) ORDER BY DATE(`"+columnName+"`) DESC");
							   result=stmt.executeQuery("SELECT DATE(`"+columnName+"`) FROM `"+viewName.toLowerCase()+"` where Date(`"+transDateColumn+"`) between '"+rangeFrom+"' AND '"+rangeTo+"' group by DATE(`"+columnName+"`) ORDER BY DATE(`"+columnName+"`) DESC");
						   }
						   else if("VARCHAR".equalsIgnoreCase(dataType) || "STRING".equalsIgnoreCase(dataType) || "INTEGER".equalsIgnoreCase(dataType) || "DECIMAL".equalsIgnoreCase(dataType))
						   {
							   log.info("DistinctColumnsQuery: SELECT distinct(`"+ columnName+"`) from `"+viewName.toLowerCase()+"` WHERE Date(`"+transDateColumn+"`) between '"+rangeFrom+"' AND '"+rangeTo+"' ORDER BY `"+columnName+"` asc");
							   result=stmt.executeQuery("SELECT distinct(`"+ columnName+"`) from `"+viewName.toLowerCase()+"` WHERE Date(`"+transDateColumn+"`) between '"+rangeFrom+"' AND '"+rangeTo+"' ORDER BY `"+columnName+"` asc");
						   }  
					   }
				   }
			       while(result.next()){
			    	   distColValues.add(result.getString(1));
			       }  
			   }
		   }
		   else
		   {
			   log.info("View doen't not exist for the view id: "+viewId);
		   }
	  }
	  catch(SQLException se){
		   log.info("Error while executing query: "+se);
	  }
	  catch(Exception e)
	  {
		  log.info("Exception while getting databse properties");
	  }
	  finally{	
		  if(result != null)
			  result.close();	
		  if(stmt != null)
			  stmt.close();
		  if(conn != null)
			  conn.close();
	  }
	  return distColValues;
  }
  
  
  /**
   * Author: Shiva
   * Purpose: Fetching trans date's grouped list
   * @throws ClassNotFoundException 
   * @throws SQLException 
   * **/
/*  public List<HashMap> getGroupedTransDatesListWithMultipleCurrency(List<String> transDates, String rangeFrom, String rangeTo, Long viewId, Long tenantId, Long groupId, String qualifier, String amountQualifier, String jobReference, List<String> currencyCodes, String currencyQualifier) throws ClassNotFoundException, SQLException
  {
	   List<HashMap> transDatesList = new ArrayList<HashMap>();
	   Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	   String currencyFormat = props.getProperty("currencyFormat");
	   if(currencyCodes.size()>0)
	   {
		   for(String transDate: transDates)
		   {
			   HashMap  transDateMp = new HashMap();
			   transDateMp.put("name", transDate);
			   List<HashMap> currencyGroupedList = new ArrayList<HashMap>();
			   for(String currency : currencyCodes)
			   {
				   HashMap currencyMp = new HashMap();
				   currencyMp.put("name", currency);
				   List<BigInteger> totalOriginalIds = getOriginalIdsByTransDateWithCurrency(viewId, rangeFrom, rangeTo, qualifier, transDate, "string", currencyQualifier, currency);
				   List<BigInteger> unRecIds = new ArrayList<BigInteger>();
				   if(totalOriginalIds.size()>0)
				   {
					   List<BigInteger> recIds = new ArrayList<BigInteger>();
					   if(jobReference.length()>0)
					   {
						   recIds = reconciliationResultRepository.fetchReconciledIdswithJobReferenceForSource(tenantId, groupId, totalOriginalIds, jobReference, viewId);
					   }
					   else
					   {
						   recIds = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForSource(tenantId, groupId, totalOriginalIds, viewId);
					   }
	
					   for(BigInteger id: totalOriginalIds)
					   {
						   if(!recIds.contains(id))
						   {
							   unRecIds.add(id);
						   }
					   }
					   
					   HashMap total = new HashMap();
					   HashMap recon = new HashMap();
					   HashMap unRecon = new HashMap();
					   
					   HashMap totalAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, amountQualifier,totalOriginalIds);
					   total.put("amount", reconciliationResultService.getAmountInFormat(totalAmountCount.get("totalAmount").toString(),currencyFormat));
					   total.put("count", totalAmountCount.get("totalCount"));
					   currencyMp.put("total", total);
					   
					   HashMap recAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, amountQualifier,recIds);
					   recon.put("amount", reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
					   recon.put("count", recAmountCount.get("totalCount"));
					   currencyMp.put("reconciled", recon);
					   
					   HashMap unRecAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, amountQualifier,unRecIds);
					   unRecon.put("amount", reconciliationResultService.getAmountInFormat(unRecAmountCount.get("totalAmount").toString(),currencyFormat));
					   unRecon.put("count", unRecAmountCount.get("totalCount"));
					   currencyMp.put("unReconciled", unRecon);
					   currencyGroupedList.add(currencyMp);
				   }
			   }
			   transDateMp.put("currencyGroupedList", currencyGroupedList);
			   //log.info("CurrencyCodeGroupedList: "+currencyGroupedList.size());
			   transDatesList.add(transDateMp);
		   }
	   }

	   log.info("Grouped by trans date size: "+transDatesList.size());
	   return transDatesList;
  }*/
  
  
  /**
   * Author: Shiva
   * Purpose: Fetching trans date's grouped list
   * @throws ClassNotFoundException 
   * @throws SQLException 
   * **/
/*  public List<HashMap> getGroupedTransDatesListWithMultipleCurrencyTree(List<String> transDates, String rangeFrom, String rangeTo, Long viewId, Long tenantId, Long groupId, String qualifier, String amountQualifier, String jobReference, List<String> currencyCodes, String currencyQualifier) throws ClassNotFoundException, SQLException
  {
	   List<HashMap> transDatesList = new ArrayList<HashMap>();
	   Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	   String currencyFormat = props.getProperty("currencyFormat");
	   if(currencyCodes.size()>0)
	   {
		   for(String transDate: transDates)
		   {
			   List<HashMap> currencyGroupedList = new ArrayList<HashMap>();
			   for(String currency : currencyCodes)
			   {
				   HashMap  transDateMp = new HashMap();
				   transDateMp.put("name", transDate);
				   transDateMp.put("currency", currency);

				   List<BigInteger> totalOriginalIds = getOriginalIdsByTransDateWithCurrency(viewId, rangeFrom, rangeTo, qualifier, transDate, "string", currencyQualifier, currency);
				   List<BigInteger> unRecIds = new ArrayList<BigInteger>();
				   if(totalOriginalIds.size()>0)
				   {
					   List<BigInteger> recIds = new ArrayList<BigInteger>();
					   if(jobReference.length()>0)
					   {
						   recIds = reconciliationResultRepository.fetchReconciledIdswithJobReferenceForSource(tenantId, groupId, totalOriginalIds, jobReference, viewId);
					   }
					   else
					   {
						   recIds = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForSource(tenantId, groupId, totalOriginalIds, viewId);
					   }
	
					   for(BigInteger id: totalOriginalIds)
					   {
						   if(!recIds.contains(id))
						   {
							   unRecIds.add(id);
						   }
					   }
					   
					   HashMap total = new HashMap();
					   HashMap recon = new HashMap();
					   HashMap unRecon = new HashMap();
					   
					   HashMap totalAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, amountQualifier,totalOriginalIds);
					   total.put("amount", reconciliationResultService.getAmountInFormat(totalAmountCount.get("totalAmount").toString(),currencyFormat));
					   total.put("count", totalAmountCount.get("totalCount"));
					   transDateMp.put("total", total);
					   
					   HashMap recAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, amountQualifier,recIds);
					   recon.put("amount", reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
					   recon.put("count", recAmountCount.get("totalCount"));
					   transDateMp.put("reconciled", recon);
					   
					   HashMap unRecAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, amountQualifier,unRecIds);
					   unRecon.put("amount", reconciliationResultService.getAmountInFormat(unRecAmountCount.get("totalAmount").toString(),currencyFormat));
					   unRecon.put("count", unRecAmountCount.get("totalCount"));
					   transDateMp.put("unReconciled", unRecon);
					   
					   transDatesList.add(transDateMp);
				   }
			   }
			   
		   }
	   }

	   log.info("Grouped by trans date size: "+transDatesList.size());
	   return transDatesList;
  }*/
  
  public String getCurrencySymbol(String currencyCode) throws ParseException
  {
	  String symbol = "";
		String jsonString = "[ {"
				   +"   \"symbol\":\"$\","
				   +  " \"currency\":\"USD\" "
				   +" },"
				   + " { "
				   +"   \"symbol\":\"$\","
				   +  " \"currency\":\"US\" "
				   +" },"
				   + "{"
				   +  " \"symbol\":\"CA$\","
				   + " \"currency\":\"CAD\" "
				   + " },"
				   + " { "
				   + "   \"symbol\":\"\u20AC\", "
				   + "   \"currency\":\"EUR\" "
				   + "},"
				   + " { "
				   + "   \"symbol\":\"AED\", "
				   + "   \"currency\":\"AED\" "
				   + "  },"
				   + "  { "
				   + "   \"symbol\":\"Af\", "
				   + "    \"currency\":\"AFN\""
				   + "  },"
				   + "  {"
				   + "    \"symbol\":\"ALL\","
				   + "   \"currency\":\"ALL\""
				   + "  },"
				   + "  {"
				   + "    \"symbol\":\"AMD\","
				   + "    \"currency\":\"AMD\""
				   + "  },"
				   + "  {"
				   + "     \"symbol\":\"AR$\","
				   +  " \"currency\":\"ARS\""
				   + " },"
				   + " {"
				   + "  \"symbol\":\"AU$\","
				   + "  \"currency\":\"AUD\""
				   + " },"
				   + " { "
				   + "  \"symbol\":\"man.\", "
				   + "   \"currency\":\"AZN\""
				   + "},"
				   + "{"
				   + "   \"symbol\":\"KM\","
				    + "   \"currency\":\"BAM\""
				    + " },"
				    + "{"
				      + " \"symbol\":\"Tk\","
				       + "\"currency\":\"BDT\""
				       + " },"
				       + " {"
				       + "\"symbol\":\"BGN\","
				       + "\"currency\":\"BGN\""
				       + " },"
				       + "{"
				     + "  \"symbol\":\"BD\","
				    + "   \"currency\":\"BHD\""
				    + "  },"
				    + "  {"
				   + "    \"symbol\":\"FBu\","
				   + "    \"currency\":\"BIF\""
				   + " },"
				   + " {"
				   + "    \"symbol\":\"BN$\","
				    + "   \"currency\":\"BND\""
				    + " },"
				    + " {"
							 + "     \"symbol\":\"Bs\","
				     + "  \"currency\":\"BOB\""
				     + " },"
				     + "  {"
				    + "   \"symbol\":\"R$\","
				      + "    \"currency\":\"BRL\""
				      + "   },"
				      + "  {"
				   + "    \"symbol\":\"BWP\","
				   + "    \"currency\":\"BWP\""
				   + "  },"
				   + "  {"
				  + "     \"symbol\":\"BYR\","
				   + "    \"currency\":\"BYR\""
				   + " },"
				   + " {"
				  + "     \"symbol\":\"BZ$\","
				   + "    \"currency\":\"BZD\""
				   + " },"
				   + "  {"
				  + "     \"symbol\":\"CDF\","
				      + "     \"currency\":\"CDF\""
				      + " },"
				      + "  {"
				  + "     \"symbol\":\"CHF\","
				  + "     \"currency\":\"CHF\""
				  + "  },"
				  + "  {"
				   + "    \"symbol\":\"CL$\","
				  + "    \"currency\":\"CLP\""
				  + "  },"
				  + "  {"
				   + "    \"symbol\":\"CN¥\","
				   + "    \"currency\":\"CNY\""
				   + "  },"
				   + " {"
				    + "   \"symbol\":\"CO$\","
				    + "   \"currency\":\"COP\""
				    + " },"
				    + " {"
				   + "    \"symbol\":\"\u20A1\","
				      + "     \"currency\":\"CRC\""
				      + "  },"
				      + "  {"
							 + "     \"symbol\":\"CV$\","
				   + "    \"currency\":\"CVE\""
				   + " },"
				   + "  {"
				   + "    \"symbol\":\"Kč\","
				   + "    \"currency\":\"CZK\""
				   + "  },"
				   + "  {"
				  + "     \"symbol\":\"Fdj\","
				   + "    \"currency\":\"DJF\""
				   + "  },"
				   + "  {"
				    + "   \"symbol\":\"Dkr\","
				    + "   \"currency\":\"DKK\""
				    + "  },"
				    + "  {"
				   + "    \"symbol\":\"RD$\","
				   + "    \"currency\":\"DOP\""
				   + " },"
				   + "  {"
				   + "    \"symbol\":\"DA\","
				   + "    \"currency\":\"DZD\""
				   + " },"
				   + " {"
				   + "    \"symbol\":\"Ekr\","
				   + "   \"currency\":\"EEK\""
				   + " },"
				   + "  {"
					   + "     \"symbol\":\"EGP\","
				   + "    \"currency\":\"EGP\""
				   + "  },"
				   + "  {"
				   + "    \"symbol\":\"Nfk\","
				   + "    \"currency\":\"ERN\""
				   + "  },"
				   + "  {"
				   + "    \"symbol\":\"Br\","
				      + "    \"currency\":\"ETB\""
				      + "  },"
				      + " {"
				   + "    \"symbol\":\"£\","
				   + "    \"currency\":\"GBP\""
				   + " },"
				   + " {"
				   + "    \"symbol\":\"GEL\","
				   + "    \"currency\":\"GEL\""
				      + " },"
				      + " {"
				    + "   \"symbol\":\"GH\u20B5\","
				    + "   \"currency\":\"GHS\""
				    + "},"
				   + "  {"
				   + "    \"symbol\":\"FG\","
				      + "    \"currency\":\"GNF\""
				  + "  },"
				  + "  {"
				  + "     \"symbol\":\"GTQ\","
				  + "     \"currency\":\"GTQ\""
				 + "   },"
				 + "  {"
				   + "    \"symbol\":\"HK$\","
				   + "    \"currency\":\"HKD\""
				  + "  },"
				  + "  {"
				   + "    \"symbol\":\"HNL\","
				   + "    \"currency\":\"HNL\""
				  + "  },"
				  + "   {"
				   + "    \"symbol\":\"kn\","
				   + "    \"currency\":\"HRK\""
				   + " },"
				   + "  {"
				   + "    \"symbol\":\"Ft\","
				  + "     \"currency\":\"HUF\""
				 + "   },"
				 + "  {"
				   + "    \"symbol\":\"Rp\","
				      + "     \"currency\":\"IDR\""
				  + "  },"
				  + "  {"
					   + "     \"symbol\":\"\u20AA\","
				   + "    \"currency\":\"ILS\""
				  + "  },"
				   + "  {"
				  + "     \"symbol\":\"₹\","
				  + "     \"currency\":\"INR\""
				 + "   },"
				 + "  {"
				 + "  \"symbol\":\"IQD\","
				 + "     \"currency\":\"IQD\""
				    		  + " },"
				    		  + "   {"
				   + "    \"symbol\":\"IRR\","
				   + "    \"currency\":\"IRR\""
				  + "  },"
				  + "  {"
				   + "    \"symbol\":\"Ikr\","
				      + "     \"currency\":\"ISK\""
				  + "  },"
				  + " {"
				   + "    \"symbol\":\"J$\","
				   + "    \"currency\":\"JMD\""
				  + "  },"
				  + "  {"
				  + "     \"symbol\":\"JD\","
				  + "     \"currency\":\"JOD\""
				  + "  },"
				  + "  {"
					   + "     \"symbol\":\"¥\","
				   + "    \"currency\":\"JPY\""
				 + "   },"
				 + " {"
				  + "     \"symbol\":\"Ksh\","
				  + "     \"currency\":\"KES\""
				  + "  },"
				  + "  {"
					   + "     \"symbol\":\"KHR\","
				    + "   \"currency\":\"KHR\""
				   + " },"
				   + "  {"
				   + "    \"symbol\":\"CF\","
				   + "    \"currency\":\"KMF\""
				  + "  },"
				  + "  {"
				  + "     \"symbol\":\"\u20A9\","
				      + "     \"currency\":\"KRW\""
				  + "  },"
				  + "  {"
				  + "     \"symbol\":\"KD\","
				  + "     \"currency\":\"KWD\""
				  + "  },"
				  + "   {"
				   + "    \"symbol\":\"KZT\","
				   + "    \"currency\":\"KZT\""
				  + "  },"
				  + " {"
				   + "    \"symbol\":\"LB£\","
				   + "    \"currency\":\"LBP\""
				  + "  },"
				  + " {"
					 + "  \"symbol\":\"SLRs\","
					 + "    \"currency\":\"LKR\""
				  + "  },"
				  + "   {"
				 + "   \"symbol\":\"Lt\","
				 + "      \"currency\":\"LTL\""
				  + "  },"
				  + "  {"
				   + "    \"symbol\":\"Ls\","
				   + "    \"currency\":\"LVL\""
				   + " },"
				   + " {"
				   + "    \"symbol\":\"LD\","
				  + "     \"currency\":\"LYD\""
				    		  + "  },"
				    		  + "  {"
				  + "     \"symbol\":\"MAD\","
				    + "   \"currency\":\"MAD\""
				    		  + "  },"
				    		  + "  {"
					   + "     \"symbol\":\"MDL\","
				   + "    \"currency\":\"MDL\""
				  + "  },"
				  + "  {"
				    + "   \"symbol\":\"MGA\","
				   + "    \"currency\":\"MGA\""
				   + " },"
				   + "  {"
				   + "    \"symbol\":\"MKD\","
				   + "    \"currency\":\"MKD\""
				   + " },"
				   + " {"
				    + "   \"symbol\":\"MMK\","
				    + "   \"currency\":\"MMK\""
				 + "   },"
				 + "  {"
				  + "     \"symbol\":\"MOP$\","
				      + "     \"currency\":\"MOP\""
				  + "  },"
				  + " {"
				   + "    \"symbol\":\"MURs\","
				   + "    \"currency\":\"MUR\""
				   + " },"
				   + "  {"
				   + "    \"symbol\":\"MX$\","
				   + "    \"currency\":\"MXN\""
				    		  + " },"
				    		  + " {"
				  + "     \"symbol\":\"RM\","
				  + "   \"currency\":\"MYR\""
				    		  + "  },"
				    		  + " {"
				    + "   \"symbol\":\"MTn\","
				  + "     \"currency\":\"MZN\""
				  + "  },"
				  + " {"
				   + "    \"symbol\":\"N$\","
				   + "    \"currency\":\"NAD\""
				   + " },"
				   + " {"
				  + "     \"symbol\":\"\u20A6\","
				  + "     \"currency\":\"NGN\""
				  + "  },"
				  + "   {"
				   + "    \"symbol\":\"C$\","
				  + "     \"currency\":\"NIO\""
				  + "  },"
				  + "  {"
				  + "     \"symbol\":\"Nkr\","
				      + "     \"currency\":\"NOK\""
				  + "  },"
				  + "  {"
				  + "     \"symbol\":\"NPRs\","
				  + "     \"currency\":\"NPR\""
				  + "  },"
				  + " {"
				   + "    \"symbol\":\"NZ$\","
				      + "   \"currency\":\"NZD\""
				   + " },"
				   + "  {"
				  + "     \"symbol\":\"OMR\","
				   + "    \"currency\":\"OMR\""
				  + "  },"
				  + "  {"
					   + " \"symbol\":\"B/.\","
				  + "     \"currency\":\"PAB\""
				  + "  },"
				  + "  {"
				  + "     \"symbol\":\"S/.\","
				  + "     \"currency\":\"PEN\""
				  + "  },"
				  + "  {"
				  + "     \"symbol\":\"\u20B1\","
				    + "   \"currency\":\"PHP\""
				 + "   },"
				 + "  {"
				  + "     \"symbol\":\"PKRs\","
				  + "     \"currency\":\"PKR\""
				    		  + " },"
				    		  + "  {"
				  + "     \"symbol\":\"zł\","
				      + "     \"currency\":\"PLN\""
				  + "  },"
				  + "  {"
				   + "    \"symbol\":\"\u20B2\","
				  + "     \"currency\":\"PYG\""
				    		  + " },"
				    		  + "  {"
				  + "     \"symbol\":\"QR\","
				      + "    \"currency\":\"QAR\""
				    		  + "},"
				    		  + " {"
				   + "    \"symbol\":\"RON\","
				   + "    \"currency\":\"RON\""
				  + "  },"
				  + "  {"
				  + "     \"symbol\":\"din.\","
				  + "     \"currency\":\"RSD\""
				  + "  },"
				  + "  {"
					   + "     \"symbol\":\"RUB\","
				  + "     \"currency\":\"RUB\""
				  + "  },"
				  + " {"
				   + "    \"symbol\":\"RWF\","
				      + "    \"currency\":\"RWF\""
				   + " },"
				   + "  {"
				    + "   \"symbol\":\"SR\","
				  + "     \"currency\":\"SAR\""
				  + "  },"
				  + "  {"
				   + "    \"symbol\":\"SDG\","
				      + "    \"currency\":\"SDG\""
				  + "  },"
				  + "  {"
					   + "    \"symbol\":\"Skr\","
				  + "     \"currency\":\"SEK\""
				  + "  },"
				  + "   {"
				   + "    \"symbol\":\"S$\","
				      + "    \"currency\":\"SGD\""
				   + " },"
				   + " {"
				   + "    \"symbol\":\"Ssh\","
				   + "    \"currency\":\"SOS\""
				   + " },"
				   + " {"
				   + "    \"symbol\":\"SY£\","
				   + "    \"currency\":\"SYP\""
				  + "  },"
				  + "  {"
				  + "     \"symbol\":\"฿\","
				  + "     \"currency\":\"THB\""
				  + "  },"
				  + "  {"
				   + "    \"symbol\":\"DT\","
				      + "    \"currency\":\"TND\""
				  + "  },"
				  + " {"
				   + "    \"symbol\":\"T$\","
				   + "    \"currency\":\"TOP\""
				  + "  },"
				  + "  {"
				  + "     \"symbol\":\"TL\","
				      + "     \"currency\":\"TRY\""
				  + "  },"
				  + "   {"
				  + "     \"symbol\":\"TT$\","
				   + "    \"currency\":\"TTD\""
				    		  + "  },"
				    		  + " {"
				   + "    \"symbol\":\"NT$\","
				   + "    \"currency\":\"TWD\""
				  + "  },"
				  + " {"
				  + "     \"symbol\":\"TSh\","
				   + "    \"currency\":\"TZS\""
				  + "  },"
				  + " {"
				   + "    \"symbol\":\"\u20B4\","
				   + "    \"currency\":\"UAH\""
				    		  + " },"
				    		  + " {"
				   + "    \"symbol\":\"USh\","
				  + "     \"currency\":\"UGX\""
				  + "  },"
				  + "  {"
				   + "    \"symbol\":\"$U\","
				  + "     \"currency\":\"UYU\""
				  + "  },"
				  + "  {"
				   + "    \"symbol\":\"UZS\","
				   + "    \"currency\":\"UZS\""
				  + "  },"
				  + "  {"
				  + "     \"symbol\":\"Bs.F.\","
				    + "   \"currency\":\"VEF\""
				   + " },"
				   + " {"
				  + "     \"symbol\":\"\u20AB\","
				  + "     \"currency\":\"VND\""
				  + "  },"
				   + "   {"
				 + "      \"symbol\":\"FCFA\","
				      + "     \"currency\":\"XAF\""
				  + "  },"
				  + "   {"
				  + "     \"symbol\":\"CFA\","
				  + "     \"currency\":\"XOF\""
				  + "  },"
				  + "   {"
				  + "     \"symbol\":\"YR\","
				      + "   \"currency\":\"YER\""
				 + "   },"
				 + "   {"
				  + "     \"symbol\":\"R\","
				   + "    \"currency\":\"ZAR\""
				 + "   },"
				 + "   {"
				  + "     \"symbol\":\"ZK\","
				      + "     \"currency\":\"ZMK\""
				  + "  }"
				  + "]";
						
						 JSONArray c = (JSONArray) new JSONParser().parse(jsonString);
						 for(int i = 0; i < c.size(); i++) {
					            JSONObject obj = (JSONObject) c.get(i);
					            if(currencyCode.equalsIgnoreCase(obj.get("currency").toString()))
					            {
					            	symbol = obj.get("symbol").toString();
					            }
					            //System.out.println("["+obj.get("currency")+", "+obj.get("symbol")+"]"); 
						 }
						 
						 return symbol; 
  }
  
  public HashMap getColNameNType(Long columnId)
  {
	  //log.info("ColumnId: "+ columnId);
	  HashMap finalMap = new HashMap();
	  DataViewsColumns dvc = dataViewsColumnsRepository.findOne(columnId);
	  if(dvc != null)
	  {
		  if("File Template".equalsIgnoreCase(dvc.getRefDvType()))
		  {
			  FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dvc.getRefDvColumn()));
			  if(ftl != null)
			  {
				  finalMap.put("columnName",ftl.getColumnAlias());
				  finalMap.put("dataType", dvc.getColDataType());
			  }
		  }
		  else if("Data View".equalsIgnoreCase(dvc.getRefDvType()) || dvc.getRefDvType() == null)
		  {
			  finalMap.put("columnName",dvc.getColumnName());
			  finalMap.put("dataType", dvc.getColDataType());
		  }
		  finalMap.put("displayColName", dvc.getColumnName());
	  }
	  return finalMap;
  }
  
  
  
  // Reconciled, Un-Reconciled Total Amounts
/*  public HashMap getTotalRecUnRecAmounts(Long viewId, Long tenantId, Long groupId, String sourceOrTarget) throws SQLException, ClassNotFoundException, ParseException
  {
	  HashMap finalMap = new HashMap();
	  String amoutQualifier = reconciliationResultService.getQualifier(BigInteger.valueOf(viewId));
	  List<BigInteger> allOriginalIds = getTargetIds(viewId);
	  List<BigInteger> recIds = new ArrayList<BigInteger>();
	  List<BigInteger> unRecIds = new ArrayList<BigInteger>();
	  String currencyCodeColName = getTransDateQualifier(BigInteger.valueOf(viewId), "CURRENCYCODE");
	  DataViews dv = dataViewsRepository.findOne(viewId.longValue());

	  Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	  String currencyFormat = props.getProperty("currencyFormat");
  	
	  if(dv != null && amoutQualifier.length()>0 && allOriginalIds.size()>0)
	  {
		  if(allOriginalIds.size()>0)
		  {
			  if("source".equalsIgnoreCase(sourceOrTarget))
			  {
				  recIds = reconciliationResultRepository.fetchReconciledSourceIds(tenantId, groupId, viewId);
			  }
			  else if("target".equalsIgnoreCase(sourceOrTarget))
			  {
				  recIds = reconciliationResultRepository.fetchReconciledTargetIds(tenantId, groupId, viewId);
			  }

			  for(BigInteger id : allOriginalIds)
			  {
				  if(!recIds.contains(id))
				  {
					  unRecIds.add(id);
				  }
			  }
		  }
		   List<String> currenciesRec = getDistColumnValues(recIds,currencyCodeColName,dv.getDataViewName());
		   String currencySymbol = "";
		   if(currenciesRec.size()==1)
		   {
			   currencySymbol = currencySymbol+getCurrencySymbol(currenciesRec.get(0));
		   }
		   else if(currenciesRec.size()>1)
		   {
			   currencySymbol = currencySymbol+"*";
		   }
		  HashMap recAmountCount = reconciliationResultService.getCountNAmountForDVId(BigInteger.valueOf(viewId), tenantId, amoutQualifier,recIds);
		  
		   List<String> currenciesUnRec = getDistColumnValues(unRecIds,currencyCodeColName,dv.getDataViewName());
		   String currencyUnSymbol = "";
		   if(currenciesUnRec.size()==1)
		   {
			   currencyUnSymbol = currencyUnSymbol+getCurrencySymbol(currenciesUnRec.get(0));
		   }
		   else if(currenciesUnRec.size()>1)
		   {
			   currencyUnSymbol = currencyUnSymbol+"*";
		   }
		  
		  HashMap unRecAmountCount = reconciliationResultService.getCountNAmountForDVId(BigInteger.valueOf(viewId), tenantId, amoutQualifier,unRecIds);
		  
		  finalMap.put("recAmount", currencySymbol+" "+reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
		  finalMap.put("unRecAmount", currencyUnSymbol+" "+reconciliationResultService.getAmountInFormat(unRecAmountCount.get("totalAmount").toString(),currencyFormat));
	  }
	  else
	  {
		  log.info("Invalid Amount Qualifier: "+ amoutQualifier + ", Total Ids Size: "+ allOriginalIds.size() +", dv"+dv);
	  }
	  return finalMap;
  }*/
  
  public void unReconcileBasedOnReconRefs(List<String> reconRefs,List<RuleGroup> accountingGroupIds, Long tenantId, Long userId, String jobReference)
  {
	  List<ReconciliationResult> reconResult = reconciliationResultRepository.fetchRecordsByReconReferenceIds(reconRefs);
	  ZonedDateTime reconciledDate = ZonedDateTime.now();
	  log.info("ReconciliationResult with recon ref ids size: "+reconResult.size());
	  if(accountingGroupIds.size()>0)
	  {
		  log.info("Un Reconciling activity based");
		  for(RuleGroup accountingGroupIdTagged:accountingGroupIds)
		  {
			  List<BigInteger> accountingViewIds = new ArrayList<BigInteger>();
			  if(accountingGroupIdTagged!=null && reconRefs.size()>0)
			  {
				  List<Long> accountingRuleIds = ruleGroupDetailsRepository.fetchRuleIdsByGroupIdAndTenantId(accountingGroupIdTagged.getId(),tenantId);
				  log.info("accountingRuleIds "+accountingRuleIds);
				  accountingViewIds = rulesRepository.fetchDistictSrcViewIdsByRuleId(accountingRuleIds);
				  log.info("accountingViewIds "+accountingViewIds);
			  }
			  Map<Long,Long> rowAndViewIds = new HashMap<Long,Long>();

			  List<ReconciliationResult> unreconciledRecords = new ArrayList<ReconciliationResult>();
			  // log.info("reconResult "+reconResult);
			  List<Long> originalIds = new ArrayList<Long>();
			  List<Long> targetIds = new ArrayList<Long>();
			  List<Long> ruleIds = new ArrayList<Long>();

			  if(reconResult.size()>0)
			  {
				  List<ReconciliationResult> reconResultContainer = new ArrayList<ReconciliationResult>();
				  List<Long> varianceIds = new ArrayList<Long>();
				  int reconResultTemp = 1;
				  for(ReconciliationResult row: reconResult)
				  {
					  if(ruleIds.isEmpty() || !ruleIds.contains(row.getReconciliationRuleId()))
					  {
						  ruleIds.add(row.getReconciliationRuleId());
			 	 			}
			 	 			row.setReconStatus("UNRECONCILED");
			 	 			row.setCurrentRecordFlag(false);
							row.setReconciledDate(reconciledDate);
							row.setReconJobReference(jobReference);
			 				//log.info("row "+row.toString());
			 				if(row.getOriginalViewId()!=null && accountingViewIds.contains(BigInteger.valueOf(row.getOriginalViewId())) )
			 				{
//			 					log.info("in original ");
			 					rowAndViewIds.put(row.getOriginalRowId(),row.getOriginalViewId());
			 					if(row.getOriginalRowId().compareTo(0L)<0)
			 					{
			 						varianceIds.add(row.getOriginalRowId()*-1);
			 					}
			 				}
			 				else if(row.getTargetViewId()!=null && accountingViewIds.contains(BigInteger.valueOf(row.getTargetViewId())) )
			 				{
//			 					log.info("in target ");
			 					targetIds.add(row.getTargetRowId());
			 					
			 					if(row.getTargetRowId().compareTo(0L)<0)
			 					{
			 						varianceIds.add(row.getTargetRowId()*-1);
			 					}
			 				}
			 				
			 				if(row.getOriginalViewId()!=null)
			 				{
			 					originalIds.add(row.getOriginalRowId());
			 				}
			 				else if(row.getTargetViewId()!=null)
			 				{
			 					targetIds.add(row.getTargetRowId());
			 				}
//			 				ReconciliationResult savedRecord = reconciliationResultRepository.saveAndFlush(row);
			 				//unreconciledRecords.add(savedRecord);
			 				if(reconResultTemp<1000)
			 				{
			 					reconResultContainer.add(row);
			 					reconResultTemp++;
			 				}
			 				else
			 				{
			 					reconciliationResultRepository.save(reconResultContainer);
			 					reconciliationResultRepository.flush();
			 					reconResultTemp=1;
			 					reconResultContainer.clear();
			 				}
			 	 		}
			 	 		if(!reconResultContainer.isEmpty())
			 	 		{
			 	 			reconciliationResultRepository.save(reconResultContainer);
			 	 			reconciliationResultRepository.flush();
							reconResultTemp=1;
							reconResultContainer.clear();
			 	 		}
			 	 		if(!varianceIds.isEmpty())
			 	 		{
			 	 			dataChildRepository.deleteByIds(varianceIds);
			 	 		}
			 	 	}
			 		Iterator<Long> iter = null;
			 		try{
			 			iter = rowAndViewIds.keySet().iterator();
			 		}
			 		catch(Exception exp)
			 		{
			 			exp.printStackTrace();
			 		}
			 		List<Long> viewIds = new ArrayList<Long>();
			 		List<Long> rowIds = new ArrayList<Long>();
			 		
			 		if(iter!=null && accountingGroupIdTagged != null)
			 		{
				 			while(iter.hasNext())
				 	 		{
				 	 			Long rowId = iter.next();
				 	 			if(rowIds.isEmpty() || !rowIds.contains(rowId))
				 	 			{
				 	 				rowIds.add(rowId);
				 	 			}
				 	 			Long viewId = rowAndViewIds.get(rowId);
				 	 			if(viewIds.isEmpty() || ! viewIds.contains(viewId))
				 	 			{
				 	 				viewIds.add(viewId);
				 	 			}
				 	 		}
				 		
				 		List<AccountingEvents> acctEventsContainer = new ArrayList<AccountingEvents>();
				 		int acctEventsTemp = 1;
				 		List<AccountingEvents> deletedEvents = new ArrayList<AccountingEvents>();
				 		
				 		List<AccountingEvents> existingRecords = accountingEventsRepository.findByAcctRuleGroupIdAndDataViewIdInAndRowIdInAndRuleIdIn(accountingGroupIdTagged.getId(),viewIds,rowIds,ruleIds);
				 	 	for(AccountingEvents existingRecord:existingRecords)
				 		{
				 			if(existingRecord.getAcctStatus().equalsIgnoreCase("PENDING"))
				 			{
				 				existingRecord.setEventType("UNRECONCILED");
				 				existingRecord.setEventTime(ZonedDateTime.now());
				 			}
				 			else if(existingRecord.getAcctStatus().equalsIgnoreCase("ACCOUNTED"))
				 			{
				 				existingRecord.setEventType("UNRECONCILED");
				 				existingRecord.setAcctStatus("NEED_REACCOUNTING");
								existingRecord.setEventTime(ZonedDateTime.now());
								existingRecord.setLastUpdatedDate(ZonedDateTime.now());
				 			}
				 			else if("NOT_ACCOUNTED".equalsIgnoreCase(existingRecord.getAcctStatus()))
					 		{
				 				deletedEvents.add(existingRecord);
					 			continue;
					 		}
				 			
				 			if(acctEventsTemp<1000)
							{
				 				acctEventsContainer.add(existingRecord);
								acctEventsTemp++;
							}
							else
							{
								accountingEventsRepository.save(acctEventsContainer);
								accountingEventsRepository.flush();
								acctEventsTemp=1;
								acctEventsContainer.clear();
							}
				 		}
						if(!acctEventsContainer.isEmpty())
				 		{
							accountingEventsRepository.save(acctEventsContainer);
				 			accountingEventsRepository.flush();
				 			acctEventsTemp=1;
							acctEventsContainer.clear();
				 	 	}
						
				 		if(!deletedEvents.isEmpty())
				 		{
				 			accountingEventsRepository.delete(deletedEvents);
				 		}
			 		}
			 	 	
			/* 		if(unreconciledRecords.size()>0)
			 		{
			 			List<ReconciliationResult> unReconciledDataForBalaceTypeSource = new ArrayList<ReconciliationResult>();
			 			List<ReconciliationResult> unReconciledDataForBalaceTypeTarget = new ArrayList<ReconciliationResult>(); 

			 			Set<ReconciliationResult> unReconciledIdsSource = new HashSet<ReconciliationResult>();
			 			Set<ReconciliationResult> unReconciledIdsTarget = new HashSet<ReconciliationResult>(); 
			 			
			 			for(ReconciliationResult record:unreconciledRecords)
			 			{
			 				if(record.getTargetViewId()==null || record.getTargetRowId()==null)
			 				{
			 					unReconciledDataForBalaceTypeSource.add(record);
			 					
			 					ReconciliationResult srcIdRec = new ReconciliationResult();
			 					srcIdRec.setOriginalViewId(record.getOriginalViewId());
			 					srcIdRec.setReconciliationRuleGroupId(record.getReconciliationRuleGroupId());
			 					srcIdRec.setReconciliationRuleId(record.getReconciliationRuleId());
			 					
			 					unReconciledIdsSource.add(srcIdRec);
			 				}
			 				
			 				if(record.getOriginalViewId()==null || record.getOriginalRowId()==null)
			 				{
			 					unReconciledDataForBalaceTypeTarget.add(record);
			 					
			 					ReconciliationResult tarIdRec = new ReconciliationResult();
			 					tarIdRec.setTargetViewId(record.getTargetViewId());
			 					tarIdRec.setReconciliationRuleGroupId(record.getReconciliationRuleGroupId());
			 					tarIdRec.setReconciliationRuleId(record.getReconciliationRuleId());
			 					
			 					unReconciledIdsTarget.add(tarIdRec);
			 				}
			 			}
			 		 	log.info("Time6: "+ new Date());
			 			String dbUrl=env.getProperty("spring.datasource.url");
			    		String[] parts=dbUrl.split("[\\s@&?$+-]+");
			    		String schemaName=parts[0].split("/")[3];
			    		
			 			Map<Long,List<String>> viewColsMap = new HashMap<Long, List<String>>();
			 			log.info("UnReconcileIds For Source: "+unReconciledIdsSource.size()+", unReconciledIdsSource: "+unReconciledIdsSource);
			 			log.info("UnReconcileIds For Target: "+unReconciledIdsTarget.size()+", unReconciledIdsTarget: "+unReconciledIdsTarget);
			 			for(ReconciliationResult viewId:unReconciledIdsSource)
						{
							Long id = viewId.getOriginalViewId();
							Long reconGroupId = viewId.getReconciliationRuleGroupId();
							Long reconRuleId = viewId.getReconciliationRuleId();
							
							HashMap<String, List<String>> groupBycolsAndQualifier = balanceTypeService.findGrpByColNamesAndQualifiersForDataView(id);
							String dataViewName = dataViewsRepository.findById(id).getDataViewName();
							List<String> groupBycols = groupBycolsAndQualifier.get("groupByCol");
							String amtQualifierCol = null;
							if(groupBycolsAndQualifier.get("AMOUNT")!=null)
							{
								amtQualifierCol = groupBycolsAndQualifier.get("AMOUNT").get(0);
							}
							else
							{
								continue;
							}
							if(groupBycols.size()==0)
							{
								continue;
							}
							viewColsMap.put(id, groupBycols );
							
							String subQuery = "SELECT original_row_id FROM "+schemaName+".t_reconciliation_result WHERE recon_job_reference = '"+jobReference+"' and "
									+ "reconciliation_rule_group_id = "+reconGroupId+" and reconciliation_rule_id = "+reconRuleId+" and original_view_id = "+id+
									" and recon_status = 'UNRECONCILED' and current_record_flag = true and original_row_id is not null";
							String inIds = "";
							for(Long unreconId:originalIds)
							{
								if(inIds.length()==0)
								{
									inIds = ""+unreconId;
								}
								else
								{
									inIds += ", "+unreconId;
								}
							}
							String groupBySQL = "SELECT SUM("+amtQualifierCol+") as type_amt";
							for(String col: groupBycols)
							{
								groupBySQL += ", "+col.toLowerCase(); 
							}
							
							groupBySQL += " FROM "+schemaName+".`"+dataViewName.toLowerCase()+ "` WHERE scrIds in ( "+inIds+" ) ";
							groupBySQL += " GROUP BY ";
							
							for(String col: groupBycols)
							{
								groupBySQL += col.toLowerCase()+", "; 
							}
							
							groupBySQL = groupBySQL.trim();
							if(groupBySQL.endsWith(","))
							{
								groupBySQL = groupBySQL.substring(0,groupBySQL.length()-1);
							}
							
							List<BalanceType> balanceTypeForProcessedRecords = new ArrayList<BalanceType>();
							if(inIds.length()>0)
							{
								balanceTypeForProcessedRecords = balanceTypeService.fetchProcessedRecords(groupBySQL,groupBycols,id, tenantId, userId, "RECONCILIATION", reconGroupId, reconRuleId,"SOURCE");
							}
							
							List<BalanceType> existingBalanceTypeRecords = balanceTypeService.fetchExistingBalanceTypeRecords("RECONCILIATION", groupBycols, id, tenantId, reconGroupId, reconRuleId);
							List<BalanceType> derivedBalanceTypeRecords = balanceTypeService.deriveOpeningAndClosingBalance(existingBalanceTypeRecords,balanceTypeForProcessedRecords);
							
							balanceTypeRepository.save(derivedBalanceTypeRecords);
							
						}
			 		 	log.info("Time7: "+ new Date());
			 			for(ReconciliationResult viewId:unReconciledIdsTarget)
						{
			 				Long id = viewId.getTargetViewId();
							Long reconGroupId = viewId.getReconciliationRuleGroupId();
							Long reconRuleId = viewId.getReconciliationRuleId();
							
							HashMap<String, List<String>> groupBycolsAndQualifier = balanceTypeService.findGrpByColNamesAndQualifiersForDataView(id);
							String dataViewName = dataViewsRepository.findById(id).getDataViewName();
							List<String> groupBycols = groupBycolsAndQualifier.get("groupByCol");
							String amtQualifierCol = null;
							if(groupBycolsAndQualifier.get("AMOUNT")!=null)
							{
								amtQualifierCol = groupBycolsAndQualifier.get("AMOUNT").get(0);
							}
							else
							{
								continue;
							}
							if(groupBycols.size()==0)
							{
								continue;
							}
							viewColsMap.put(id, groupBycols );
							
							String subQuery = "SELECT target_row_id FROM "+schemaName+".t_reconciliation_result WHERE recon_job_reference = '"+jobReference+"' and "
									+ "reconciliation_rule_group_id = "+reconGroupId+" and reconciliation_rule_id = "+reconRuleId+" and target_view_id = "+id+
									" and recon_status = 'UNRECONCILED' and current_record_flag = true and target_row_id is not null";
							String inIds = "";
							
							for(Long unreconId:targetIds)
							{
								if(inIds.length()==0)
								{
									inIds = ""+unreconId;
								}
								else
								{
									inIds += ", "+unreconId;
								}
							}
							
							String groupBySQL = "SELECT SUM("+amtQualifierCol+") as type_amt";
							for(String col: groupBycols)
							{
								groupBySQL += ", "+col.toLowerCase(); 
							}
							
							groupBySQL += " FROM "+schemaName+".`"+dataViewName.toLowerCase()+ "` WHERE scrIds in ( "+inIds+" ) ";
							groupBySQL += " GROUP BY ";
							
							for(String col: groupBycols)
							{
								groupBySQL += col.toLowerCase()+", "; 
							}
							
							groupBySQL = groupBySQL.trim();
							if(groupBySQL.endsWith(","))
							{
								groupBySQL = groupBySQL.substring(0,groupBySQL.length()-1);
							}
							
							List<BalanceType> balanceTypeForProcessedRecords = new ArrayList<BalanceType>();
							if(inIds.length()>0)
							{
								balanceTypeForProcessedRecords = balanceTypeService.fetchProcessedRecords(groupBySQL,groupBycols,id, tenantId, userId, "RECONCILIATION", reconGroupId, reconRuleId, "TARGET");
							}
								
							List<BalanceType> existingBalanceTypeRecords = balanceTypeService.fetchExistingBalanceTypeRecords("RECONCILIATION", groupBycols, id, tenantId, reconGroupId, reconRuleId);
							List<BalanceType> derivedBalanceTypeRecords = balanceTypeService.deriveOpeningAndClosingBalance(existingBalanceTypeRecords,balanceTypeForProcessedRecords);
							
							balanceTypeRepository.save(derivedBalanceTypeRecords);
						}
			 		 	log.info("Time8: "+ new Date());
			 		}

		  }
	 	 */  
		  }
	  }
	  else
	  {
		  log.info("Un Reconciling non activity based.");
		  if(reconResult.size()>0)
		  {
			  List<ReconciliationResult> reconResultContainer = new ArrayList<ReconciliationResult>();
			  List<Long> varianceIds = new ArrayList<Long>();
			  int reconResultTemp = 1;
			  for(ReconciliationResult row: reconResult)
			  {
				  row.setReconStatus("UNRECONCILED");
				  row.setReconciledDate(reconciledDate);
				  row.setReconJobReference(jobReference);
				  if(row.getOriginalViewId()!=null)
				  {
					  if(row.getOriginalRowId().compareTo(0L)<0)
					  {
						  varianceIds.add(row.getOriginalRowId()*-1);
					  }
				  }
				  else if(row.getTargetViewId()!=null)
				  {
					  if(row.getTargetRowId().compareTo(0L)<0)
					  {
						  varianceIds.add(row.getTargetRowId()*-1);
					  }
				  }
				  if(reconResultTemp<1000)
				  {
					  reconResultContainer.add(row);
					  reconResultTemp++;
				  }
				  else
				  {
					  reconciliationResultRepository.save(reconResultContainer);
					  reconciliationResultRepository.flush();
					  reconResultTemp=1;
					  reconResultContainer.clear();
				  }
			  }
			  if(!reconResultContainer.isEmpty())
			  {
				  reconciliationResultRepository.save(reconResultContainer);
				  reconciliationResultRepository.flush();
				  reconResultTemp=1;
				  reconResultContainer.clear();
			  }
			  if(!varianceIds.isEmpty())
			  {
				  dataChildRepository.deleteByIds(varianceIds);
			  }
		  }
	  }

  }

/**
   * Author: Shiva
   * Purpose: Posting reconciliation counts in t_app_module_summary table **/
  public void postAppModuleSummaryTable(Long groupId, Long viewId, Long ruleId, Long userId, Long typeCount, String type, String sourceOrTarget)
  {
	  log.info("Posting "+sourceOrTarget+" count in t_app_module_summary table for the group id: "+groupId+", view id: "+ viewId+", rule id: "+ ruleId+", type: "+ type);
	  AppModuleSummary amsSource = appModuleSummaryRepository.findByModuleAndRuleGroupIdAndRuleIdAndTypeAndViewId(type, groupId, ruleId, sourceOrTarget, viewId);
	  if(amsSource != null)
	  {
		  amsSource.setLastUpdatedBy(userId);
		  amsSource.setLastUpdatedDate(ZonedDateTime.now());
		  amsSource.setTypeCount(amsSource.getTypeCount()-typeCount);
		  AppModuleSummary amsSrcUpdate = appModuleSummaryRepository.save(amsSource);
	  }
	  else
	  {
		  AppModuleSummary amsCreate = new AppModuleSummary();
		  amsCreate.setCreatedBy(userId);
		  amsCreate.setCreatedDate(ZonedDateTime.now());
		  amsCreate.setLastUpdatedBy(userId);
		  amsCreate.setLastUpdatedDate(ZonedDateTime.now());
		  amsCreate.setModule(type);
		  amsCreate.setRuleGroupId(groupId);
		  amsCreate.setRuleId(ruleId);
		  amsCreate.setType(sourceOrTarget);
		  amsCreate.setTypeCount(typeCount);
		  amsCreate.setViewId(viewId);
		  AppModuleSummary amsSrcCreate = appModuleSummaryRepository.save(amsCreate);
	  }
  }
  public String convertDatsToString(List<String> dates)
  {
	  String datesAsString = "";
	  for(int i=0; i<dates.size(); i++)
	  {
		  if(i == dates.size()-1)
		  {
			  datesAsString = datesAsString + dates.get(i).trim(); 
		  }
		  else
		  {
			  datesAsString = datesAsString + dates.get(i).trim() + "|";			  
		  }
	  }
	  return datesAsString;
  }
  public HashMap getTotalByPeriodFactorForDays(Long viewId, String periodFactor, String rangeFrom, String rangeTo, List<String> transDates) throws ClassNotFoundException
  {
	  HashMap finalMap = new HashMap();
	  List<BigInteger> totalIds = new ArrayList<BigInteger>();
	  String status = "";
	  List<String> reasons = new ArrayList<String>();
	  String transDateQualifier = getTransDateQualifier(BigInteger.valueOf(viewId), "TRANSDATE");
	  if("dateQualifier".equalsIgnoreCase(periodFactor))
	  {
		  log.info("with date qualifier");
		  
		  log.info("Trans Date Qualifier for Data View Id: "+transDateQualifier);
		  if(transDateQualifier.length()>0)
		  {
			  try{
				  totalIds = getOriginalIdsForDateQualifier(viewId, rangeFrom, rangeTo, transDateQualifier, transDates);
				  status = "Success";
			  }catch(Exception e)
			  {
				  status = "Failed";
				  reasons.add("Un able to fetch the total ids for the view id: "+ viewId+", trans date qualifier: "+ transDateQualifier+", range from: "+ rangeFrom+", range to: "+ rangeTo);
			  }
		  }
		  else
		  {
			  status = "Failed";
			  reasons.add("No trans date qualifier found for the view id: "+viewId);
			  log.info("No trans date qualifier found for the view id: "+viewId);
		  }
	  }
	  else if("fileDate".equalsIgnoreCase(periodFactor))
	  {
		  log.info("with file date");
		  try{
			  transDateQualifier = "fileDate";
			  totalIds = getOriginalIdsByTransDates(viewId, rangeFrom, rangeTo, transDateQualifier, transDates);
			  status = "Success";
		  }catch(Exception e)
		  {
			  status = "Failed";
			  reasons.add("Un able to fetch the total ids for the view id: "+ viewId+" between range: "+rangeFrom+"-"+rangeTo);
		  }
	  }
	  finalMap.put("status", status);
	  finalMap.put("reasons", reasons);
	  finalMap.put("totalIds", totalIds);
	  return finalMap;
  }
  
  public HashMap getTotalByPeriodFactor(Long viewId, String periodFactor, String rangeFrom, String rangeTo) throws ClassNotFoundException
  {
	  HashMap finalMap = new HashMap();
	  List<BigInteger> totalIds = new ArrayList<BigInteger>();
	  String status = "";
	  List<String> reasons = new ArrayList<String>();
	  if("dateQualifier".equalsIgnoreCase(periodFactor))
	  {
		  log.info("with date qualifier");
		  String transDateQualifier = getTransDateQualifier(BigInteger.valueOf(viewId), "TRANSDATE");
		  log.info("Trans Date Qualifier for Data View Id: "+transDateQualifier);
		  if(transDateQualifier.length()>0)
		  {
			  try{
				  totalIds = getOriginalIdsByDateQualifier(viewId, transDateQualifier, rangeFrom, rangeTo);
				  status = "Success";
			  }catch(Exception e)
			  {
				  status = "Failed";
				  reasons.add("Un able to fetch the total ids for the view id: "+ viewId+", trans date qualifier: "+ transDateQualifier+", range from: "+ rangeFrom+", range to: "+ rangeTo);
			  }
		  }
		  else
		  {
			  status = "Failed";
			  reasons.add("No trans date qualifier found for the view id: "+viewId);
			  log.info("No trans date qualifier found for the view id: "+viewId);
		  }
	  }
	  else if("fileDate".equalsIgnoreCase(periodFactor))
	  {
		  log.info("with file date");
		  try{
			  totalIds = getViewOriginalIds(viewId, rangeFrom, rangeTo, "");
			  status = "Success";
		  }catch(Exception e)
		  {
			  status = "Failed";
			  reasons.add("Un able to fetch the total ids for the view id: "+ viewId+" between range: "+rangeFrom+"-"+rangeTo);
		  }
	  }
	  finalMap.put("status", status);
	  finalMap.put("reasons", reasons);
	  finalMap.put("totalIds", totalIds);
	  return finalMap;
  }
  
  public HashMap getRecUnRecAmounts(ReconUnReconAmountsDTO params, Long viewId, String sourceOrTarget, Long tenantId, Long groupId) throws ClassNotFoundException
  {
	  log.info("Fetching rec un-rec amounts for the group id: "+params.getRuleGroupId()+", tenant id: "+tenantId+", view id: "+viewId);
	  HashMap finalMap = new HashMap();
	  List<BigInteger> totalIds = new ArrayList<BigInteger>();
	  List<BigInteger> recIds = new ArrayList<BigInteger>();
	  List<BigInteger> unRecIds = new ArrayList<BigInteger>();
	  List<BigInteger> suggestedIds = new ArrayList<BigInteger>();
	  
	  List<String> recCurrencies = new ArrayList<String>();
	  List<String> unRecCurrencies = new ArrayList<String>();
	  List<String> suggestedCurrencies = new ArrayList<String>();
	  String status = "";
	  List<String> reasons = new ArrayList<String>();
	  
	  String totalAmount = "0.0";
	  String recAmount = "0.0";
	  String unRecAmount = "0.0";
	  String suggestedAmount = "0.0";
	  DataViews dv = dataViewsRepository.findOne(viewId);
	  if(dv != null)
	  {
		  String amountQualifier = getTransDateQualifier(BigInteger.valueOf(viewId), "AMOUNT");
		  String currencyCodeColName = getTransDateQualifier(BigInteger.valueOf(viewId), "CURRENCYCODE");
		  if(amountQualifier.length()>0 && currencyCodeColName.length()>0)
		  {
			  // Fetching total ids based on date qualifier or file date.
			  HashMap totalIdsMap = getTotalByPeriodFactor(viewId, params.getPeriodFactor(), params.getRangeFrom(), params.getRangeTo());
			  if("Success".equalsIgnoreCase(totalIdsMap.get("status").toString()))
			  {
				  totalIds = (List<BigInteger>) totalIdsMap.get("totalIds");
				  log.info("Total original ids size: "+ totalIds.size());
				  // Fetching reconciled, un-reconciled amounts
				  if(totalIds.size()>0)
				  {
					  try{
						  totalAmount = getAmountSumByIds(totalIds, amountQualifier, BigInteger.valueOf(viewId));
						  if("source".equalsIgnoreCase(sourceOrTarget))
						  {
							  log.info("in source");
							  recIds = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForSource(tenantId, groupId, totalIds, viewId);
							  suggestedIds = reconciliationDuplicateResultRepository.fetchReconciledIdswithStatusUnreconciledForSource(tenantId, groupId, totalIds, viewId);
						  }
						  else if("target".equalsIgnoreCase(sourceOrTarget))
						  {
							  log.info("in target");
							  recIds = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForTarget(tenantId, groupId, totalIds, viewId);
							  suggestedIds = reconciliationDuplicateResultRepository.fetchReconciledIdswithStatusUnreconciledForTarget(tenantId, groupId, totalIds, viewId);
						  }
						  log.info("reconciled ids size: "+ recIds.size());
						  recAmount = getAmountSumByIds(recIds, amountQualifier, BigInteger.valueOf(viewId));
						  recCurrencies = getDistColumnValues(recIds,currencyCodeColName,dv.getDataViewName());	// Currencies List for Reconciled IDs
						  totalIds.removeAll(recIds);	// removing reconciled ids
						  totalIds.removeAll(suggestedIds);	// removing suggested ids
						  unRecAmount = getAmountSumByIds(totalIds, amountQualifier, BigInteger.valueOf(viewId));
						  unRecCurrencies = getDistColumnValues(totalIds,currencyCodeColName,dv.getDataViewName()); // Currencies List for UnReconciled IDs
						  suggestedAmount = getAmountSumByIds(suggestedIds, amountQualifier, BigInteger.valueOf(viewId));
						  suggestedCurrencies = getDistColumnValues(suggestedIds,currencyCodeColName,dv.getDataViewName());	// Currencies List for Reconciled IDs
						  log.info("un reconciled ids size: "+ totalIds.size());
						  status = "Success";
					  }
					  catch(Exception e)
					  {
						  status = "Failed";
						  reasons.add("Error while fetching reconciled data for the tenant id: "+tenantId+", rule group id: "+params.getRuleGroupId()+" view id: "+viewId);
					  }
				  }
			  }
		  }
		  else
		  {
			  status = "Failed";
			  reasons.add("No Amount or Currency Code Qualifier found for the view id: " + viewId);
			  log.info("No Amount or Currency Code Qualifier found for the view id: " + viewId);
		  }
	  }
	  else 
	  {
		  status = "Failed";
		  reasons.add("Data view doen't exist. View id: "+ viewId);
	  }
	  
	  finalMap.put("totalAmount", totalAmount);
	  finalMap.put("recAmount", recAmount);
	  finalMap.put("unRecAmount", unRecAmount);
	  finalMap.put("suggestedAmount", suggestedAmount);
	  finalMap.put("recCurrency", recCurrencies);
	  finalMap.put("unRecCurrency", unRecCurrencies);
	  finalMap.put("suggestedCurrency", suggestedCurrencies);
	  finalMap.put("status", status);
	  finalMap.put("reasons", reasons);
	  
	  return finalMap;
  }
  
/*  public HashMap getRecUnRecIdsForSrcNTargetForManualBatch(ReconCountNAmountsDTO params, List<String> manualBatches, Long groupId, Long sViewId, Long tViewId) throws ClassNotFoundException, SQLException, ParseException
  {
	  
	  Long tenantId = params.getTenantId();
	  HashMap finalMap = new HashMap();
	  log.info("Fetching Recon Un-Recon counts and amounts for Manual Batch the tenant id: "+ tenantId+", group id: "+ groupId+", source view id: "+sViewId+", target view id "+ tViewId);
	  List<HashMap> groupedList = new ArrayList<HashMap>();
	  List<BigInteger> sTotalIds = new ArrayList<BigInteger>();
	  List<BigInteger> tTotalIds = new ArrayList<BigInteger>();
	  List<BigInteger> sRecIds = new ArrayList<BigInteger>();
	  List<BigInteger> tRecIds = new ArrayList<BigInteger>();
	  DataViews sdv = dataViewsRepository.findOne(sViewId);
	  DataViews tdv = dataViewsRepository.findOne(tViewId);
	  String sCurrencyCode = getTransDateQualifier(BigInteger.valueOf(sViewId), "CURRENCYCODE");
	  String tCurrencyCode = getTransDateQualifier(BigInteger.valueOf(tViewId), "CURRENCYCODE");
	  
	  String sAmountQualifier = getTransDateQualifier(BigInteger.valueOf(sViewId), "AMOUNT");
	  String tAmountQualifier = getTransDateQualifier(BigInteger.valueOf(tViewId), "AMOUNT");
	  log.info("sCurrencyCode: "+sCurrencyCode+", tCurrencyCode: "+tCurrencyCode+", sAmountQualifier: "+sAmountQualifier+". "+tAmountQualifier);
	  Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	  String currencyFormat = props.getProperty("currencyFormat");
	   
	  if(sdv != null && tdv != null)
	  {
		  try{
			  HashMap sTotalIdsMap = getTotalByPeriodFactor(sViewId, params.getPeriodFactor(), params.getRangeFrom(), params.getRangeTo());
			  HashMap tTotalIdsMap = getTotalByPeriodFactor(tViewId, params.getPeriodFactor(), params.getRangeFrom(), params.getRangeTo());
			  if("Success".equalsIgnoreCase(sTotalIdsMap.get("status").toString()) && "Success".equalsIgnoreCase(tTotalIdsMap.get("status").toString()))
			  {
				  sTotalIds = (List<BigInteger>) sTotalIdsMap.get("totalIds");
				  tTotalIds = (List<BigInteger>) tTotalIdsMap.get("totalIds");
			  }
			  else
			  {
				  log.info("Error while fetching total ids for the source view : "+params.getsViewId()+", or target view: "+params.gettViewId());
			  } 
		  }
		  catch(Exception e)
		  {
			  log.info("Error while fetching total ids for the source view : "+params.getsViewId()+", or target view: "+params.gettViewId());
		  }
		  log.info("sTotalIds.size(): "+sTotalIds.size()+", tTotalIds.size(): "+tTotalIds.size());
		  if(sTotalIds.size()>0 && tTotalIds.size()>0)
		  {
			  log.info("Manual Batches: "+manualBatches);
				  HashMap recMap = new HashMap();
				  recMap.put("name", "Manual");
				  sRecIds = reconciliationResultRepository.fetchReconciledIdswithJobReferencesForSource(tenantId, groupId, sTotalIds, manualBatches, sViewId);
				  tRecIds = reconciliationResultRepository.fetchReconciledIdswithJobReferencesForTarget(tenantId, groupId, tTotalIds, manualBatches, tViewId);
				  log.info("Batch: Manual , sRecIds.size(): "+sRecIds.size()+", tRecIds: "+tRecIds.size());
			  		String sRecCurrencySymbol = "";
			  		List<String> sRecCurrencies = getDistColumnValues(sRecIds,sCurrencyCode,sdv.getDataViewName());
			  		if(sRecCurrencies.size()==1)
			  		{
			  			sRecCurrencySymbol = sRecCurrencySymbol+getCurrencySymbol(sRecCurrencies.get(0));
			  		}
			  		else if(sRecCurrencies.size()>1)
			  		{
			  			sRecCurrencySymbol = sRecCurrencySymbol+"*";
			  		}
			  		
			  		String tRecCurrencySymbol = "";
			  		List<String> tRecCurrencies = getDistColumnValues(tRecIds,tCurrencyCode,tdv.getDataViewName());
			  		if(tRecCurrencies.size()==1)
			  		{
			  			tRecCurrencySymbol = tRecCurrencySymbol+getCurrencySymbol(tRecCurrencies.get(0));
			  		}
			  		else if(tRecCurrencies.size()>1)
			  		{
			  			tRecCurrencySymbol = tRecCurrencySymbol+"*";
			  		}
			  		
					HashMap sRecCountNAmount = reconciliationResultService.getCountNAmountForDVId(BigInteger.valueOf(sViewId), tenantId, sAmountQualifier,sRecIds);
					recMap.put("sAmount", sRecCurrencySymbol+" "+reconciliationResultService.getAmountInFormat(sRecCountNAmount.get("totalAmount").toString(),currencyFormat));
					recMap.put("sCount", sRecCountNAmount.get("totalCount"));
					recMap.put("dsCount", sRecIds.size());
					recMap.put("sCurrency", sRecCurrencySymbol);
					recMap.put("sAmountValue", sRecCountNAmount.get("totalAmount"));
					
					HashMap tRecCountNAmount = reconciliationResultService.getCountNAmountForDVId(BigInteger.valueOf(tViewId), tenantId, tAmountQualifier,tRecIds);
					recMap.put("tAmount", tRecCurrencySymbol+" "+reconciliationResultService.getAmountInFormat(tRecCountNAmount.get("totalAmount").toString(),currencyFormat));
					recMap.put("tCount", tRecCountNAmount.get("totalCount"));
					recMap.put("dtCount", tRecIds.size());
					recMap.put("tCurrency", tRecCurrencySymbol);
					recMap.put("tAmountValue", tRecCountNAmount.get("totalAmount"));
					log.info("Manual: map: "+recMap);
					groupedList.add(recMap);
		  }
		  else
		  {
			  log.info("No records fournd for the source view id: "+params.getsViewId()+", or target view id: "+params.gettViewId());
		  }
	  }
	  else
	  {
		  log.info("Source view i: "+ params.getsViewId()+" or target view id: "+ params.gettViewId()+" doesn't exist");
	  }
	  finalMap.put("summary", groupedList);
	  finalMap.put("status", "");
	  log.info("Manual Final Map Size: "+groupedList.size());
	  return finalMap;
  }*/

  //getUnReconIdsForDays
/*  public HashMap getRecUnRecIdsForSrcNTargetForBatch(ReconCountNAmountsDTO params, List<String> batches, Long groupId, Long sViewId, Long tViewId) throws ClassNotFoundException, SQLException, ParseException
  {	
	  Long tenantId = params.getTenantId();
	  HashMap finalMap = new HashMap();
	  log.info("Fetching Recon Un-Recon counts and amounts for the tenant id: "+ tenantId+", group id: "+ groupId+", source view id: "+sViewId+", target view id "+ tViewId);
	  List<HashMap> groupedList = new ArrayList<HashMap>();
	  List<BigInteger> sTotalIds = new ArrayList<BigInteger>();
	  List<BigInteger> tTotalIds = new ArrayList<BigInteger>();
	  List<BigInteger> sRecIds = new ArrayList<BigInteger>();
	  List<BigInteger> tRecIds = new ArrayList<BigInteger>();
	  DataViews sdv = dataViewsRepository.findOne(sViewId);
	  DataViews tdv = dataViewsRepository.findOne(tViewId);
	  String sCurrencyCode = getTransDateQualifier(BigInteger.valueOf(sViewId), "CURRENCYCODE");
	  String tCurrencyCode = getTransDateQualifier(BigInteger.valueOf(tViewId), "CURRENCYCODE");
	  
	  String sAmountQualifier = getTransDateQualifier(BigInteger.valueOf(sViewId), "AMOUNT");
	  String tAmountQualifier = getTransDateQualifier(BigInteger.valueOf(tViewId), "AMOUNT");
	  log.info("sCurrencyCode: "+sCurrencyCode+", tCurrencyCode: "+tCurrencyCode+", sAmountQualifier: "+sAmountQualifier+". "+tAmountQualifier);
	  Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	  String currencyFormat = props.getProperty("currencyFormat");
	   
	  if(sdv != null && tdv != null)
	  {
		  try{
			  HashMap sTotalIdsMap = getTotalByPeriodFactor(sViewId, params.getPeriodFactor(), params.getRangeFrom(), params.getRangeTo());
			  HashMap tTotalIdsMap = getTotalByPeriodFactor(tViewId, params.getPeriodFactor(), params.getRangeFrom(), params.getRangeTo());
			  if("Success".equalsIgnoreCase(sTotalIdsMap.get("status").toString()) && "Success".equalsIgnoreCase(tTotalIdsMap.get("status").toString()))
			  {
				  sTotalIds = (List<BigInteger>) sTotalIdsMap.get("totalIds");
				  tTotalIds = (List<BigInteger>) tTotalIdsMap.get("totalIds");
			  }
			  else
			  {
				  log.info("Error while fetching total ids for the source view : "+params.getsViewId()+", or target view: "+params.gettViewId());
			  } 
		  }
		  catch(Exception e)
		  {
			  log.info("Error while fetching total ids for the source view : "+params.getsViewId()+", or target view: "+params.gettViewId());
		  }
		  log.info("sTotalIds.size(): "+sTotalIds.size()+", tTotalIds.size(): "+tTotalIds.size());
		  if(sTotalIds.size()>0 && tTotalIds.size()>0)
		  {
			  for(String batch : batches)
			  {
				  HashMap recMap = new HashMap();
				  recMap.put("name", batch);
				  sRecIds = reconciliationResultRepository.fetchReconciledIdswithJobReferenceForSource(tenantId, groupId, sTotalIds, batch, sViewId);
				  tRecIds = reconciliationResultRepository.fetchReconciledIdswithJobReferenceForTarget(tenantId, groupId, tTotalIds, batch, tViewId);
				  log.info("Batch: "+batch+", sRecIds.size(): "+sRecIds.size()+", tRecIds: "+tRecIds.size());
			  		String sRecCurrencySymbol = "";
			  		List<String> sRecCurrencies = getDistColumnValues(sRecIds,sCurrencyCode,sdv.getDataViewName());
			  		if(sRecCurrencies.size()==1)
			  		{
			  			sRecCurrencySymbol = sRecCurrencySymbol+getCurrencySymbol(sRecCurrencies.get(0));
			  		}
			  		else if(sRecCurrencies.size()>1)
			  		{
			  			sRecCurrencySymbol = sRecCurrencySymbol+"*";
			  		}
			  		
			  		String tRecCurrencySymbol = "";
			  		List<String> tRecCurrencies = getDistColumnValues(tRecIds,tCurrencyCode,tdv.getDataViewName());
			  		if(tRecCurrencies.size()==1)
			  		{
			  			tRecCurrencySymbol = tRecCurrencySymbol+getCurrencySymbol(tRecCurrencies.get(0));
			  		}
			  		else if(tRecCurrencies.size()>1)
			  		{
			  			tRecCurrencySymbol = tRecCurrencySymbol+"*";
			  		}
			  		
					HashMap sRecCountNAmount = reconciliationResultService.getCountNAmountForDVId(BigInteger.valueOf(sViewId), tenantId, sAmountQualifier,sRecIds);
					recMap.put("sAmount", sRecCurrencySymbol+" "+reconciliationResultService.getAmountInFormat(sRecCountNAmount.get("totalAmount").toString(),currencyFormat));
					recMap.put("sCount", sRecCountNAmount.get("totalCount"));
					recMap.put("dsCount", sRecIds.size());
					recMap.put("sCurrency", sRecCurrencySymbol);
					recMap.put("sAmountValue", sRecCountNAmount.get("totalAmount"));
					
					HashMap tRecCountNAmount = reconciliationResultService.getCountNAmountForDVId(BigInteger.valueOf(tViewId), tenantId, tAmountQualifier,tRecIds);
					recMap.put("tAmount", tRecCurrencySymbol+" "+reconciliationResultService.getAmountInFormat(tRecCountNAmount.get("totalAmount").toString(),currencyFormat));
					recMap.put("tCount", tRecCountNAmount.get("totalCount"));
					recMap.put("dtCount", tRecIds.size());
					recMap.put("tCurrency", tRecCurrencySymbol);
					recMap.put("tAmountValue", tRecCountNAmount.get("totalAmount"));
					log.info("Batch: "+ batch+", map: "+recMap);
					groupedList.add(recMap);
			  	}
		  }
		  else
		  {
			  log.info("No records fournd for the source view id: "+params.getsViewId()+", or target view id: "+params.gettViewId());
		  }
	  }
	  else
	  {
		  log.info("Source view i: "+ params.getsViewId()+" or target view id: "+ params.gettViewId()+" doesn't exist");
	  }
	  finalMap.put("summary", groupedList);
	  finalMap.put("status", "");
	  log.info("Final Map Size: "+groupedList.size());
	  return finalMap;
  }*/
  
/*  public HashMap getRecUnRecIdsForSrcNTarget(ReconCountNAmountsDTO params, List<BigInteger> ruleIds, Long groupId, Long sViewId, Long tViewId) throws ClassNotFoundException, SQLException, ParseException
  {
	  Long tenantId = params.getTenantId();
	  HashMap finalMap = new HashMap();
	  log.info("Fetching Recon Un-Recon counts and amounts for the tenant id: "+ tenantId+", group id: "+ groupId+", source view id: "+sViewId+", target view id "+ tViewId);
	  List<HashMap> groupedList = new ArrayList<HashMap>();
	  List<BigInteger> sTotalIds = new ArrayList<BigInteger>();
	  List<BigInteger> tTotalIds = new ArrayList<BigInteger>();
	  List<BigInteger> sRecIds = new ArrayList<BigInteger>();
	  List<BigInteger> tRecIds = new ArrayList<BigInteger>();
	  DataViews sdv = dataViewsRepository.findOne(sViewId);
	  DataViews tdv = dataViewsRepository.findOne(tViewId);
	  String sCurrencyCode = getTransDateQualifier(BigInteger.valueOf(sViewId), "CURRENCYCODE");
	  String tCurrencyCode = getTransDateQualifier(BigInteger.valueOf(tViewId), "CURRENCYCODE");
	  
	  String sAmountQualifier = getTransDateQualifier(BigInteger.valueOf(sViewId), "AMOUNT");
	  String tAmountQualifier = getTransDateQualifier(BigInteger.valueOf(tViewId), "AMOUNT");
	  
	  Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	  String currencyFormat = props.getProperty("currencyFormat");
	   
	  if(sdv != null && tdv != null)
	  {
		  try{
			  HashMap sTotalIdsMap = getTotalByPeriodFactor(sViewId, params.getPeriodFactor(), params.getRangeFrom(), params.getRangeTo());
			  HashMap tTotalIdsMap = getTotalByPeriodFactor(tViewId, params.getPeriodFactor(), params.getRangeFrom(), params.getRangeTo());
			  if("Success".equalsIgnoreCase(sTotalIdsMap.get("status").toString()) && "Success".equalsIgnoreCase(tTotalIdsMap.get("status").toString()))
			  {
				  sTotalIds = (List<BigInteger>) sTotalIdsMap.get("totalIds");
				  tTotalIds = (List<BigInteger>) tTotalIdsMap.get("totalIds");
			  }
			  else
			  {
				  log.info("Error while fetching total ids for the source view : "+sViewId+", or target view: "+tViewId);
			  } 
		  }
		  catch(Exception e)
		  {
			  log.info("Error while fetching total ids for the source view : "+sViewId+", or target view: "+tViewId);
		  }
		  if(sTotalIds.size()>0 && tTotalIds.size()>0)
		  {
			  for(BigInteger ruleId : ruleIds)
			  {
				  HashMap recMap = new HashMap();
				  if(ruleId == BigInteger.valueOf(0L))
				  {
					  recMap.put("id", ruleId);
					  recMap.put("name", "Manual");
				  }
				  else
				  {
					  Rules rule = rulesRepository.findOne(ruleId.longValue());
					  if(rule != null)
					  {
						  recMap.put("id", ruleId);
						  recMap.put("name", rule.getRuleCode());
					  }
				  }

				  List<Long> ruleIdSingle = new ArrayList<Long>();
				  ruleIdSingle.add(ruleId.longValue());
				  sRecIds = reconciliationResultRepository.fetchReconciledIdsWithOutJobRefWithStatusReconciledForSource(tenantId, ruleIdSingle, groupId, sTotalIds,sViewId);
				  tRecIds = reconciliationResultRepository.fetchReconciledIdsWithOutJobRefWithStatusReconciledForTarget(tenantId, ruleIdSingle, groupId, tTotalIds, tViewId);
			
			  		String sRecCurrencySymbol = "";
			  		List<String> sRecCurrencies = getDistColumnValues(sRecIds,sCurrencyCode,sdv.getDataViewName());
			  		if(sRecCurrencies.size()==1)
			  		{
			  			sRecCurrencySymbol = sRecCurrencySymbol+getCurrencySymbol(sRecCurrencies.get(0));
			  		}
			  		else if(sRecCurrencies.size()>1)
			  		{
			  			sRecCurrencySymbol = sRecCurrencySymbol+"*";
			  		}
			  		
			  		String tRecCurrencySymbol = "";
			  		List<String> tRecCurrencies = getDistColumnValues(tRecIds,tCurrencyCode,tdv.getDataViewName());
			  		if(tRecCurrencies.size()==1)
			  		{
			  			tRecCurrencySymbol = tRecCurrencySymbol+getCurrencySymbol(tRecCurrencies.get(0));
			  		}
			  		else if(tRecCurrencies.size()>1)
			  		{
			  			tRecCurrencySymbol = tRecCurrencySymbol+"*";
			  		}
			  		
					HashMap sRecCountNAmount = reconciliationResultService.getCountNAmountForDVId(BigInteger.valueOf(sViewId), tenantId, sAmountQualifier,sRecIds);
					recMap.put("sAmount", sRecCurrencySymbol+" "+reconciliationResultService.getAmountInFormat(sRecCountNAmount.get("totalAmount").toString(),currencyFormat));
					recMap.put("sCount", sRecCountNAmount.get("totalCount"));
					recMap.put("dsCount", sRecIds.size());
					recMap.put("sCurrency", sRecCurrencySymbol);
					recMap.put("sAmountValue", sRecCountNAmount.get("totalAmount"));
					
					HashMap tRecCountNAmount = reconciliationResultService.getCountNAmountForDVId(BigInteger.valueOf(tViewId), tenantId, tAmountQualifier,tRecIds);
					recMap.put("tAmount", tRecCurrencySymbol+" "+reconciliationResultService.getAmountInFormat(tRecCountNAmount.get("totalAmount").toString(),currencyFormat));
					recMap.put("tCount", tRecCountNAmount.get("totalCount"));
					recMap.put("dtCount", tRecIds.size());
					recMap.put("tCurrency", tRecIds.size());
					recMap.put("tAmountValue", tRecCountNAmount.get("totalAmount"));
					groupedList.add(recMap);
			  	}
		  }
		  else
		  {
			  log.info("No records fournd for the source view id: "+params.getsViewId()+", or target view id: "+params.gettViewId());
		  }
	  }
	  else
	  {
		  log.info("Source view i: "+ params.getsViewId()+" or target view id: "+ params.gettViewId()+" doesn't exist");
	  }
	  finalMap.put("summary", groupedList);
	  finalMap.put("status", "");
	  return finalMap;
  }*/
  
  public String getCurrencySymbol(Set<String> codesList) throws ParseException
  {
	  String currencySymbol = "";
	  if(codesList.size() == 1)
	  {
		  currencySymbol = currencySymbol+getCurrencySymbol(codesList.toArray()[codesList.size()-1].toString());
	  }
	  else if(codesList.size()>1)
	  {
		  currencySymbol = currencySymbol+"*";
	  }
	  return currencySymbol;
  }
  
  public HashMap getRulesRecIdsForSource(Long viewId, String periodFacotr, String rangeFrom, String rangeTo, List<Long> ruleIds, Long tenantId, Long groupId, String typeOfRecData)
  {
	  HashMap finalMap = new HashMap();
	  List<BigInteger> totalIds = new ArrayList<BigInteger>();
	  List<BigInteger> recIds = new ArrayList<BigInteger>();
	  try{
		  HashMap stotalIdsMap = getTotalByPeriodFactor(viewId, periodFacotr, rangeFrom, rangeTo);
		  if("Success".equalsIgnoreCase(stotalIdsMap.get("status").toString()))
		  {
			  totalIds = (List<BigInteger>) stotalIdsMap.get("totalIds");
		  }
		  else
		  {
			  log.info("Error while fetching total ids for the source view : "+viewId);
		  } 
	  }
	  catch(Exception e)
	  {
		  log.info("Error while fetching total ids for the source view : "+viewId);
	  }
	  if(totalIds.size()>0)
	  {
		  if("suggestion".equalsIgnoreCase(typeOfRecData))
		  {
			  recIds = reconciliationDuplicateResultRepository.fetchReconciledIdsWithOutJobRefWithStatusReconciledForSource(tenantId, ruleIds, groupId, totalIds,viewId);
		  }
		  else
		  {
			  recIds = reconciliationResultRepository.fetchReconciledIdsWithOutJobRefWithStatusReconciledForSource(tenantId, ruleIds, groupId, totalIds,viewId);	  
		  }
	  }
	  finalMap.put("reconciled", recIds);
	  finalMap.put("totalIds", totalIds);
	  return finalMap;
  }
  
  
  
  
  public HashMap getAppRulesRecIdsForSource(Long viewId, String periodFacotr, String rangeFrom, String rangeTo, List<Long> ruleIds, Long tenantId, Long groupId)
  {
	  HashMap finalMap = new HashMap();
	  List<BigInteger> totalIds = new ArrayList<BigInteger>();
	  List<BigInteger> recIds = new ArrayList<BigInteger>();
	  try{
		  HashMap stotalIdsMap = getTotalByPeriodFactor(viewId, periodFacotr, rangeFrom, rangeTo);
		  if("Success".equalsIgnoreCase(stotalIdsMap.get("status").toString()))
		  {
			  totalIds = (List<BigInteger>) stotalIdsMap.get("totalIds");
		  }
		  else
		  {
			  log.info("Error while fetching total ids for the source view : "+viewId);
		  } 
	  }
	  catch(Exception e)
	  {
		  log.info("Error while fetching total ids for the source view : "+viewId);
	  }
	  if(totalIds.size()>0)
	  {
		  recIds = reconciliationResultRepository.fetchReconciledIdsWithOutJobRefWithStatusReconciledForSource(tenantId, ruleIds, groupId, totalIds,viewId);
	  }
	  finalMap.put("reconciled", recIds);
	  finalMap.put("totalIds", totalIds);
	  return finalMap;
  }
  
  public HashMap getRecIdsforBatches(Long viewId, String periodFactor, String rangeFrom, String rangeTo, Long tenantId, Long groupId, List<String> batches, String sourceOrTarget, String typeOfRecData)
  {
	  HashMap finalMap = new HashMap();
	  List<BigInteger> totalIds = new ArrayList<BigInteger>();
	  List<BigInteger> recIds = new ArrayList<BigInteger>();
	  try{
		  HashMap stotalIdsMap = getTotalByPeriodFactor(viewId, periodFactor, rangeFrom, rangeTo);
		  if("Success".equalsIgnoreCase(stotalIdsMap.get("status").toString()))
		  {
			  totalIds = (List<BigInteger>) stotalIdsMap.get("totalIds");
		  }
		  else
		  {
			  log.info("Error while fetching total ids for the source view : "+viewId);
		  } 
	  }
	  catch(Exception e)
	  {
		  log.info("Error while fetching total ids for the source view : "+viewId);
	  }
	  if(totalIds.size()>0)
	  {
		  if("source".equalsIgnoreCase(sourceOrTarget))
		  {
			  if("suggestion".equalsIgnoreCase(typeOfRecData))
			  {
				  recIds = reconciliationDuplicateResultRepository.fetchReconciledIdswittBatchesForSource(tenantId, groupId, totalIds, batches, viewId);
			  }
			  else
			  {
				  recIds = reconciliationResultRepository.fetchReconciledIdswittBatchesForSource(tenantId, groupId, totalIds, batches, viewId);  
			  }
		  }
		  else if("target".equalsIgnoreCase(sourceOrTarget))
		  {
			  if("suggestion".equalsIgnoreCase(typeOfRecData))
			  {
				  recIds = reconciliationDuplicateResultRepository.fetchReconciledIdswithJobReferencesForTarget(tenantId, groupId, totalIds, batches, viewId);
			  }
			  else
			  {
				  recIds = reconciliationResultRepository.fetchReconciledIdswithJobReferencesForTarget(tenantId, groupId, totalIds, batches, viewId);  
			  }
			  
		  }
	  }
	  log.info("RecIds Size: "+recIds.size());
	  log.info("Total Ids Size: "+totalIds.size());
	  finalMap.put("reconciled", recIds);
	  finalMap.put("totalIds", totalIds);
	  return finalMap;
  }
  
  public HashMap getRulesRecIdsForTarget(Long viewId, String periodFacotr, String rangeFrom, String rangeTo, List<Long> ruleIds, Long tenantId, Long groupId, String typeOfRecData)
  {
	  HashMap finalMap = new HashMap();
	  List<BigInteger> totalIds = new ArrayList<BigInteger>();
	  List<BigInteger> recIds = new ArrayList<BigInteger>();
	  try{
		  HashMap stotalIdsMap = getTotalByPeriodFactor(viewId, periodFacotr, rangeFrom, rangeTo);
		  if("Success".equalsIgnoreCase(stotalIdsMap.get("status").toString()))
		  {
			  totalIds = (List<BigInteger>) stotalIdsMap.get("totalIds");
		  }
		  else
		  {
			  log.info("Error while fetching total ids for the source view : "+viewId);
		  } 
	  }
	  catch(Exception e)
	  {
		  log.info("Error while fetching total ids for the source view : "+viewId);
	  }
	  if(totalIds.size()>0)
	  {
		  if("suggestion".equalsIgnoreCase(typeOfRecData))
		  {
			  recIds = reconciliationDuplicateResultRepository.fetchReconciledIdsWithOutJobRefWithStatusReconciledForTarget(tenantId, ruleIds, groupId, totalIds,viewId);
		  }
		  else
		  {
			  recIds = reconciliationResultRepository.fetchReconciledIdsWithOutJobRefWithStatusReconciledForTarget(tenantId, ruleIds, groupId, totalIds,viewId);
		  }
	  }
	  finalMap.put("reconciled", recIds);
	  finalMap.put("totalIds", totalIds);
	  return finalMap;
  }
  
/*  public HashMap getDatesUnRecSummaryInfo(List<String> dates, String periodFactor, String rangeFrom, String rangeTo, Long sViewId, Long tViewId, Long tenantId, Long groupId, String sourceOrTarget) throws java.text.ParseException, SQLException, ParseException, ClassNotFoundException
  {
	  HashMap finalMap = new HashMap();
	  Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	  String currencyFormat = props.getProperty("currencyFormat");
	  List<HashMap> finalList = new ArrayList<HashMap>();
	  for(String transDate : dates)
	  {
		  HashMap transDateMp = new HashMap();
		  DateFormat df = new SimpleDateFormat("yyyy-MM-dd");
		  Date date = df.parse(transDate);
		  df = new SimpleDateFormat("dd-MMM-yy");
		  transDateMp.put("name", df.format(date));
			  if("source".equalsIgnoreCase(sourceOrTarget))
			  {
				  log.info("Fetching source dates summary info");
				  DataViews dv = dataViewsRepository.findOne(sViewId);
				  List<BigInteger> recIdSource = new ArrayList<BigInteger>();
				  List<BigInteger> suggestedIdSource = new ArrayList<BigInteger>();
				  List<BigInteger> unRecIdSource = new ArrayList<BigInteger>();
				  String dateQualifier = getTransDateQualifier(BigInteger.valueOf(sViewId), "TRANSDATE");
				  List<BigInteger> totalOriginalIds = new ArrayList<BigInteger>();		
				  totalOriginalIds =   getOriginalIdsForDays(sViewId, rangeFrom, rangeTo, dateQualifier, transDate, periodFactor);
				  log.info("Source Date: "+transDate+" original ids size: "+totalOriginalIds.size());
				  if(totalOriginalIds.size()>0)
				  {
					  String currencyCodeColName = getTransDateQualifier(BigInteger.valueOf(sViewId), "CURRENCYCODE"); 
					  String amountQualifier = getTransDateQualifier(BigInteger.valueOf(sViewId), "AMOUNT"); 

					  recIdSource = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForSource(tenantId, groupId, totalOriginalIds,sViewId);
					  suggestedIdSource = reconciliationDuplicateResultRepository.fetchReconciledIdswithStatusUnreconciledForSource(tenantId, groupId, totalOriginalIds,sViewId);
					  HashMap unRecon = new HashMap();
					  String currencySymbolUnRec = "";
					   
					  for(BigInteger id: totalOriginalIds)
					  {
						  if(!recIdSource.contains(id))
						  {
							  unRecIdSource.add(id);
						  }
					  }
					  unRecIdSource.removeAll(suggestedIdSource);
						if(unRecIdSource.size()>0)
						{
							List<String> currenciesUnRec = getDistColumnValues(unRecIdSource,currencyCodeColName,dv.getDataViewName());
							if(currenciesUnRec.size()==1)
							{
								currencySymbolUnRec = currencySymbolUnRec+getCurrencySymbol(currenciesUnRec.get(0));
							}
							else if(currenciesUnRec.size()>1)
							{
								currencySymbolUnRec = currencySymbolUnRec+"*";
							}
							HashMap unRecAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(sViewId.toString()), tenantId, amountQualifier,unRecIdSource);
							transDateMp.put("sAmount", currencySymbolUnRec + " " + reconciliationResultService.getAmountInFormat(unRecAmountCount.get("totalAmount").toString(),currencyFormat));
							transDateMp.put("sCount", unRecAmountCount.get("totalCount"));			
							transDateMp.put("dsCount", unRecIdSource.size());
							transDateMp.put("sCurrency", currencySymbolUnRec);
							transDateMp.put("sAmountValue", unRecAmountCount.get("totalAmount"));
							
							transDateMp.put("tAmount", 0.0);
							transDateMp.put("tCount", 0);			
							transDateMp.put("dtCount", 0);
							transDateMp.put("tCurrency", "");
							transDateMp.put("tAmountValue", 0);
							finalList.add(transDateMp);
						}
				  }
			  }
			  else if("target".equalsIgnoreCase(sourceOrTarget))
			  {
				  log.info("Fetching target dates summary info");
				  List<BigInteger> recIdTarget = new ArrayList<BigInteger>();
				  List<BigInteger> unRecIdTarget = new ArrayList<BigInteger>();
				  List<BigInteger> suggestedIdTarget = new ArrayList<BigInteger>();
				  
				  List<BigInteger> totalOriginalIds = new ArrayList<BigInteger>();
				  String dateQualifier = getTransDateQualifier(BigInteger.valueOf(tViewId), "TRANSDATE");
				  totalOriginalIds =   getOriginalIdsForDays(tViewId, rangeFrom, rangeTo, dateQualifier, transDate, periodFactor);
				  log.info("Target Date: "+transDate+" original ids size: "+totalOriginalIds.size());
				  if(totalOriginalIds.size()>0)
				  {
					  String currencyCodeColName = getTransDateQualifier(BigInteger.valueOf(tViewId), "CURRENCYCODE"); 
					  String amountQualifier = getTransDateQualifier(BigInteger.valueOf(tViewId), "AMOUNT"); 
					  DataViews dv = dataViewsRepository.findOne(tViewId);
					  recIdTarget = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForTarget(tenantId, groupId, totalOriginalIds,tViewId);
					  suggestedIdTarget = reconciliationDuplicateResultRepository.fetchReconciledIdswithStatusUnreconciledForTarget(tenantId, groupId, totalOriginalIds,tViewId);
					   HashMap unRecon = new HashMap();
					   String currencySymbolUnRec = "";
					   
						  for(BigInteger id: totalOriginalIds)
						  {
							  if(!recIdTarget.contains(id))
							  {
								  unRecIdTarget.add(id);
							  }
						  }
						  unRecIdTarget.removeAll(suggestedIdTarget);
						  if(unRecIdTarget.size()>0)
						  {
							   List<String> currenciesUnRec = getDistColumnValues(unRecIdTarget,currencyCodeColName,dv.getDataViewName());
							   if(currenciesUnRec.size()==1)
							   {
								   currencySymbolUnRec = currencySymbolUnRec+getCurrencySymbol(currenciesUnRec.get(0));
							   }
							   else if(currenciesUnRec.size()>1)
							   {
								   currencySymbolUnRec = currencySymbolUnRec+"*";
							   }
							   HashMap unRecAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(tViewId.toString()), tenantId, amountQualifier,unRecIdTarget);
							   transDateMp.put("tAmount", currencySymbolUnRec + " " + reconciliationResultService.getAmountInFormat(unRecAmountCount.get("totalAmount").toString(),currencyFormat));
							   transDateMp.put("tCount", unRecAmountCount.get("totalCount"));
							   transDateMp.put("dtCount", unRecIdTarget.size());
							   transDateMp.put("tCurrency", currencySymbolUnRec);
							   transDateMp.put("tAmountValue", unRecAmountCount.get("totalAmount").toString());
							   
							   transDateMp.put("sAmount", 0.0);
							   transDateMp.put("sCount", 0);
							   transDateMp.put("dsCount", 0);
							   transDateMp.put("sCurrency", "");
							   transDateMp.put("sAmountValue", 0);
							   
							   finalList.add(transDateMp);
						  }
				  }
			  }
			  else if("common".equalsIgnoreCase(sourceOrTarget))
			  {
				  log.info("Fetching common dates info");
				  List<BigInteger> recIdTarget = new ArrayList<BigInteger>();
				  List<BigInteger> suggestedIdTarget = new ArrayList<BigInteger>();
				  List<BigInteger> unRecIdTarget = new ArrayList<BigInteger>();
				  
				  List<BigInteger> recIdSource = new ArrayList<BigInteger>();
				  List<BigInteger> suggestedIdSource = new ArrayList<BigInteger>();
				  List<BigInteger> unRecIdSource = new ArrayList<BigInteger>();
				  
				  String sDateQualifier = getTransDateQualifier(BigInteger.valueOf(sViewId), "TRANSDATE");
				  String tDateQualifier = getTransDateQualifier(BigInteger.valueOf(tViewId), "TRANSDATE");
				  List<BigInteger> sTotalOriginalIds = new ArrayList<BigInteger>();				  
				  sTotalOriginalIds =   getOriginalIdsForDays(sViewId, rangeFrom, rangeTo, sDateQualifier, transDate, periodFactor);
				  log.info("Source Date: "+transDate+", total ids size: "+sTotalOriginalIds.size());
				  if(sTotalOriginalIds.size()>0)
				  {
					  String sCurrencyCodeColName = getTransDateQualifier(BigInteger.valueOf(sViewId), "CURRENCYCODE"); 
					  String sAmountQualifier = getTransDateQualifier(BigInteger.valueOf(sViewId), "AMOUNT"); 

					  DataViews dv = dataViewsRepository.findOne(sViewId);
					  recIdSource = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForSource(tenantId, groupId, sTotalOriginalIds,sViewId);
					  suggestedIdSource = reconciliationDuplicateResultRepository.fetchReconciledIdswithStatusUnreconciledForSource(tenantId, groupId, sTotalOriginalIds,sViewId);
					  HashMap unRecon = new HashMap();
					  String currencySymbolUnRec = "";
					   
					  for(BigInteger id: sTotalOriginalIds)
					  {
						  if(!recIdSource.contains(id))
						  {
							  unRecIdSource.add(id);
						  }
					  }
					  unRecIdSource.removeAll(suggestedIdSource);
					  if(unRecIdSource.size()>0)
					  {
						  List<String> currenciesUnRec = getDistColumnValues(unRecIdSource,sCurrencyCodeColName,dv.getDataViewName());
						  if(currenciesUnRec.size()==1)
						  {
							  currencySymbolUnRec = currencySymbolUnRec+getCurrencySymbol(currenciesUnRec.get(0));
						  }
						  else if(currenciesUnRec.size()>1)
						  {
							  currencySymbolUnRec = currencySymbolUnRec+"*";
						  }
						  
						  HashMap unRecAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(sViewId.toString()), tenantId, sAmountQualifier,unRecIdSource);
						  transDateMp.put("sAmount", currencySymbolUnRec + " " + reconciliationResultService.getAmountInFormat(unRecAmountCount.get("totalAmount").toString(),currencyFormat));
						  transDateMp.put("sCount", unRecAmountCount.get("totalCount"));		
						  transDateMp.put("dsCount", unRecIdSource.size());
						  transDateMp.put("sCurrency", currencySymbolUnRec);
						  transDateMp.put("sAmountValue", unRecAmountCount.get("totalAmount"));
					  }
					  else
					  {
						   transDateMp.put("sAmount", 0.0);
						   transDateMp.put("sCount", 0);
						   transDateMp.put("dsCount", 0);
						   transDateMp.put("sCurrency", "");
						   transDateMp.put("sAmountValue", 0);
					  }

				  }

				  List<BigInteger> tTotalOriginalIds = new ArrayList<BigInteger>();
				  tTotalOriginalIds =   getOriginalIdsForDays(tViewId, rangeFrom, rangeTo, tDateQualifier, transDate, periodFactor);
				  log.info("Target: "+transDate+", total ids size: "+sTotalOriginalIds.size());
				  if(tTotalOriginalIds.size()>0)
				  {
					  String currencyCodeColName = getTransDateQualifier(BigInteger.valueOf(tViewId), "CURRENCYCODE"); 
					  String amountQualifier = getTransDateQualifier(BigInteger.valueOf(tViewId), "AMOUNT"); 
					  DataViews dv = dataViewsRepository.findOne(tViewId);
					  recIdTarget = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForTarget(tenantId, groupId, tTotalOriginalIds,tViewId);
					  suggestedIdTarget = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForTarget(tenantId, groupId, tTotalOriginalIds,tViewId);
					  HashMap unRecon = new HashMap();
					  String currencySymbolUnRec = "";
					   
					  for(BigInteger id: tTotalOriginalIds)
					  {
						  if(!recIdTarget.contains(id))
						  {
							  unRecIdTarget.add(id);
						  }
					  }
					  unRecIdTarget.removeAll(suggestedIdTarget);
					  if(unRecIdTarget.size()>0)
					  {
						  List<String> currenciesUnRec = getDistColumnValues(unRecIdTarget,currencyCodeColName,dv.getDataViewName());
						  if(currenciesUnRec.size()==1)
						  {
							  currencySymbolUnRec = currencySymbolUnRec+getCurrencySymbol(currenciesUnRec.get(0));
						  }
						  else if(currenciesUnRec.size()>1)
						  {
							  currencySymbolUnRec = currencySymbolUnRec+"*";
						  }
						  HashMap unRecAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(tViewId.toString()), tenantId, amountQualifier,unRecIdTarget);
						  transDateMp.put("tAmount", currencySymbolUnRec + " " + reconciliationResultService.getAmountInFormat(unRecAmountCount.get("totalAmount").toString(),currencyFormat));
						  transDateMp.put("tCount", unRecAmountCount.get("totalCount"));					  
						  transDateMp.put("dtCount", unRecIdTarget.size());
						  transDateMp.put("tCurrency", currencySymbolUnRec);
						  transDateMp.put("tAmountValue", unRecAmountCount.get("totalAmount"));
					  }
					  else
					  {
						   transDateMp.put("tAmount", 0.0);
						   transDateMp.put("tCount", 0); 
						   transDateMp.put("dtCount", 0);
						   transDateMp.put("tCurrency", "");
						   transDateMp.put("tAmountValue", 0);
					  }
				  }
				  if(unRecIdSource.size() == 0 && unRecIdTarget.size() == 0)
				  {}
				  else
				  {
					  finalList.add(transDateMp);
				  }
			  }
		  }
	  finalMap.put("summary", finalList);
	  finalMap.put("status", "");
	  return finalMap;
  }*/
  
/*  public HashMap getDatesUnRecSummary(List<String> sDates, List<String> tDates,List<String> commonDates, Long tenantId, Long sViewId, Long tViewId, String rangeFrom, String rangeTo, String sDateQualifier, String tDateQualifier, String periodFactor, Long groupId) throws ClassNotFoundException, java.text.ParseException, SQLException, ParseException
  {
	  HashMap finalMap = new HashMap();
	  List<HashMap> finalList = new ArrayList<HashMap>();
	  Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	  String currencyFormat = props.getProperty("currencyFormat"); 
	  String sCurrencyCode = getTransDateQualifier(BigInteger.valueOf(sViewId), "CURRENCYCODE"); 
	  String tCurrencyCode = getTransDateQualifier(BigInteger.valueOf(tViewId), "CURRENCYCODE"); 
	  DataViews sdv = dataViewsRepository.findOne(sViewId);
	  DataViews tdv = dataViewsRepository.findOne(tViewId);
	  List<HashMap> allDatesMap = new ArrayList<HashMap>();
	  if(sdv != null && tdv != null)
	  {	
		  if(sCurrencyCode.length()>0 && tCurrencyCode.length()>0)
		  {
			  if(sDates.size()>0)
			  {
				  log.info("source dates: "+sDates);
				  HashMap map = getDatesUnRecSummaryInfo(sDates, periodFactor, rangeFrom, rangeTo, sViewId, tViewId, tenantId, groupId, "source");
				  finalList.addAll((List<HashMap>) map.get("summary"));
			  }
			  if(tDates.size()>0)
			  {
				  log.info("target dates: "+tDates);
				  HashMap map = getDatesUnRecSummaryInfo(tDates, periodFactor, rangeFrom, rangeTo, sViewId, tViewId, tenantId, groupId, "target");
				  finalList.addAll((List<HashMap>) map.get("summary"));
			  }
			  if(commonDates.size()>0)
			  {
				  log.info("common dates: "+commonDates);
				  HashMap map = getDatesUnRecSummaryInfo(commonDates, periodFactor, rangeFrom, rangeTo, sViewId, tViewId, tenantId, groupId, "common");
				  finalList.addAll((List<HashMap>) map.get("summary"));
			  }
		  }
		  else
		  {
			  log.info("There is no currency code qualifiers found the source view id: "+sViewId+" or target view id: "+tViewId);
		  }
	  }
	  else 
	  {
		  log.info("source view id: "+sViewId+" or target view id: "+tViewId+" are");
	  }
	  finalMap.put("summary", finalList);
	  finalMap.put("status", "");
	  return finalMap;
  }*/
  
/*  public HashMap getColValuesUnRecSummaryInfo(List<String> colValues, ReconCountNAmountsDTO params, String sourceOrTarget, String columnName, String dataType, Long groupId, Long sViewId, Long tViewId) throws ClassNotFoundException, SQLException, ParseException
  {
	  HashMap finalMap = new HashMap();
	  List<HashMap> summaryInfo = new ArrayList<HashMap>();
	  List<HashMap> finalList = new ArrayList<HashMap>();
	  if("source".equalsIgnoreCase(sourceOrTarget))
	  {
		  log.info("Source column values summary info");
		  if("reconciled".equalsIgnoreCase(params.getStatus()))
		  {
			  log.info("Fetching source reconciled column values summary info");
			  summaryInfo = getColSummaryInfo(colValues, sViewId, params.getRangeFrom(), params.getRangeTo(), columnName, dataType, params.getTenantId(), groupId, sourceOrTarget, params.getStatus(), params.getPeriodFactor());
			  if(summaryInfo.size()>0)
			  {
				  for(HashMap hm : summaryInfo)
				  {
					  HashMap hmNew = new HashMap();
					  hmNew.put("sAmount", hm.get("rAmount").toString());
					  hmNew.put("sCount", hm.get("rCount").toString());
					  hmNew.put("dsCount", hm.get("dCount").toString());

					  hmNew.put("tAmount", 0.0);
					  hmNew.put("tCount", 0);
					  hmNew.put("dtCount", 0);

					  hmNew.put("name", hm.get("name").toString());
					  finalList.add(hmNew);
				  }
			  }
			  log.info("Source reconciled summary info size: "+summaryInfo.size());
		  }
		  else if("unReconciled".equalsIgnoreCase(params.getStatus()))
		  {
			  log.info("Fetching source un reconciled column values summary info");
			  summaryInfo = getColSummaryInfo(colValues, sViewId, params.getRangeFrom(), params.getRangeTo(), columnName, dataType, params.getTenantId(), groupId, sourceOrTarget, params.getStatus(), params.getPeriodFactor());
			  if(summaryInfo.size()>0)
			  {
				  for(HashMap hm : summaryInfo)
				  {
					  HashMap hmNew = new HashMap();
					  hmNew.put("sAmount", hm.get("uAmount").toString());
					  hmNew.put("sCount", hm.get("uCount").toString());
					  hmNew.put("dsCount", hm.get("dCount").toString());
					  hmNew.put("name", hm.get("name").toString());
					  
					  hmNew.put("tAmount", 0.0);
					  hmNew.put("tCount", 0);
					  hmNew.put("dtCount", 0);

					  
					  finalList.add(hmNew);
				  }
			  }
			  log.info("Source un reconciled summary info size: "+finalList.size());
		  }
	  }
	  else if("target".equalsIgnoreCase(sourceOrTarget))
	  {
		  log.info("Target column values summary info");
		   DataViews tdv = dataViewsRepository.findOne(tViewId);
		   if("reconciled".equalsIgnoreCase(params.getStatus()))
		   {
			   log.info("Fetching target reconciled column values summary info");
				summaryInfo = getColSummaryInfo(colValues, tViewId, params.getRangeFrom(), params.getRangeTo(), columnName, dataType, params.getTenantId(), groupId, sourceOrTarget, params.getStatus(), params.getPeriodFactor());
				log.info("target reconciled column values summary info size: "+summaryInfo.size());
				if(summaryInfo.size()>0)
				  {
					  for(HashMap hm : summaryInfo)
					  {
						  HashMap hmNew = new HashMap();
						  hmNew.put("tAmount", hm.get("rAmount").toString());
						  hmNew.put("tCount", hm.get("rCount").toString());
						  hmNew.put("dtCount", hm.get("dCount").toString());
						  
						  hmNew.put("sAmount", 0.0);
						  hmNew.put("sCount", 0);
						  hmNew.put("dsCount", 0);
						  
						  hmNew.put("name", hm.get("name").toString());
						  finalList.add(hmNew);
					  }
				  }
				log.info("target reconciled column values summary info size: "+ finalList.size());
		   }
		   else if("unReconciled".equalsIgnoreCase(params.getStatus()))
		   {
			   log.info("Fetching target un reconciled column values summary info");
			   summaryInfo = getColSummaryInfo(colValues, tViewId, params.getRangeFrom(), params.getRangeTo(), columnName, dataType, params.getTenantId(), groupId, sourceOrTarget, params.getStatus(), params.getPeriodFactor());
				log.info("target un reconciled column values summary info");
			   if(summaryInfo.size()>0)
				  {
					  for(HashMap hm : summaryInfo)
					  {
						  HashMap hmNew = new HashMap();
						  hmNew.put("tAmount", hm.get("rAmount").toString());
						  hmNew.put("tCount", hm.get("rCount").toString());
						  hmNew.put("dtCount", hm.get("dCount").toString());
						  
						  hmNew.put("sAmount", 0.0);
						  hmNew.put("sCount", 0);
						  hmNew.put("dsCount", 0);
						  
						  hmNew.put("name", hm.get("name").toString());
						  finalList.add(hmNew);
					  }
				  }
			   log.info("target un reconciled column values summary info size: "+ finalList.size());
		   }
	  }
	  else if("common".equalsIgnoreCase(sourceOrTarget))
	  {
		  DataViews sdv = dataViewsRepository.findOne(sViewId);
		  DataViews tdv = dataViewsRepository.findOne(tViewId);
		  
		  HashMap smap = getDataTYpeNColumnName(params.getsColumnId());
		  HashMap tmap = getDataTYpeNColumnName(params.gettColumnId());
		   
		  String sColName = smap.get("columnName").toString();
		  String sDataType = smap.get("dataType").toString();
			  
		  String tColName = tmap.get("columnName").toString();
		  String tDataType = tmap.get("dataType").toString();
		  log.info("common: source column name: "+sColName+", dataType: "+ sDataType);
		  log.info("common: target column name: "+tColName+", dataType: "+ tDataType);

		  List<HashMap> srcRec = new ArrayList<HashMap>();
		  List<HashMap> srcUnRec = new ArrayList<HashMap>();
		  
		  List<HashMap> targetRec = new ArrayList<HashMap>();
		  List<HashMap> targetUnRec = new ArrayList<HashMap>();
		  
		  if("reconciled".equalsIgnoreCase(params.getStatus()))
		  {
			  log.info("Common reconciled column values summary info");
			  srcRec = getColSummaryInfo(colValues, sViewId, params.getRangeFrom(), params.getRangeTo(), sColName, sDataType, params.getTenantId(), groupId, "source", "reconciled",params.getPeriodFactor());
			  log.info("Common source reconciled column values summary info: "+srcRec.size());
			  if(srcRec.size()>0)
			  {
				  for(HashMap hm : srcRec)
				  {
					  HashMap hmNew = new HashMap();
					  hmNew.put("sAmount", hm.get("rAmount").toString());
					  hmNew.put("sCount", hm.get("rCount").toString());
					  hmNew.put("dsCount", hm.get("dCount").toString());
					  hmNew.put("name", hm.get("name").toString());
					  finalList.add(hmNew);
				  }
			  }
			  log.info("Common source reconcield column values summary info: "+finalList.size());
			  targetRec = getColSummaryInfo(colValues, tViewId, params.getRangeFrom(), params.getRangeTo(), tColName, tDataType, params.getTenantId(), groupId, "target", "reconciled",params.getPeriodFactor());
			  log.info("Common target reconciled column values summary info: "+targetRec.size());
			  if(targetRec.size()>0)
			  {
				  for(HashMap hm : targetRec)
				  {
					  HashMap hmNew = new HashMap();
					  hmNew.put("tAmount", hm.get("rAmount").toString());
					  hmNew.put("tCount", hm.get("rCount").toString());
					  hmNew.put("dtCount", hm.get("dCount").toString());
					  hmNew.put("name", hm.get("name").toString());
					  finalList.add(hmNew);
				  }
			  }
			  log.info("Common target reconciled column values summary info: "+ finalList.size());
		  }
		  else if("unReconciled".equalsIgnoreCase(params.getStatus()))
		  {
			  log.info("Fetching common un reconciled column values summary info");
			  srcUnRec = getColSummaryInfo(colValues, sViewId, params.getRangeFrom(), params.getRangeTo(), sColName, sDataType, params.getTenantId(), groupId, "source", "unReconciled",params.getPeriodFactor());
			  log.info("Common source un reconciled column values summary info: "+srcUnRec.size());
			  if(srcUnRec.size()>0)
			  {
				  for(HashMap hm : srcUnRec)
				  {
					  HashMap hmNew = new HashMap();
					  hmNew.put("sAmount", hm.get("uAmount").toString());
					  hmNew.put("sCount", hm.get("uCount").toString());
					  hmNew.put("dsCount", hm.get("dCount").toString());
					  hmNew.put("name", hm.get("name").toString());
					  finalList.add(hmNew);
				  }
			  }
			  log.info("Common source un reconciled column values summary info: "+finalList.size());
			  targetUnRec = getColSummaryInfo(colValues, tViewId, params.getRangeFrom(), params.getRangeTo(), tColName, tDataType, params.getTenantId(), groupId, "target", "unReconciled",params.getPeriodFactor());
			  log.info("Common targt un reconciled column values summary info: "+ targetUnRec.size());
			  if(targetUnRec.size()>0)
			  {
				  for(HashMap hm : targetUnRec)
				  {
					  HashMap hmNew = new HashMap();
					  hmNew.put("tAmount", hm.get("rAmount").toString());
					  hmNew.put("tCount", hm.get("rCount").toString());
					  hmNew.put("dtCount", hm.get("dCount").toString());
					  hmNew.put("name", hm.get("name").toString());
					  finalList.add(hmNew);
				  }
			  }
			  log.info("Common target un reconciled column values summary info: "+ finalList.size());
		  }
	  }
	  finalMap.put("summary", finalList);
	  finalMap.put("status", "");
	  return finalMap;
  }
*/  
 /* public List<HashMap> getColSummaryInfo(List<String> colValues, Long viewId, String rangeFrom, String rangeTo, String columnName, String dataType, Long tenantId, Long groupId, String sourceOrTarget, String status, String periodFactor) throws ClassNotFoundException, SQLException, ParseException
  {
	  String currencyCodeColName = getTransDateQualifier(new BigInteger(viewId.toString()), "CURRENCYCODE"); 
	  List<HashMap> finalList = new ArrayList<HashMap>();
	  Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	  String currencyFormat = props.getProperty("currencyFormat");
	  DataViews dv = dataViewsRepository.findOne(viewId);
	  String amountQualifier = getTransDateQualifier(new BigInteger(viewId.toString()), "AMOUNT"); 
	  if(dv != null)
	  {
		   for(String colValue: colValues)
		   {
			   HashMap colValuMP = new HashMap();
			   colValuMP.put("name", colValue);
			   List<BigInteger> totalOriginalIds = getOriginalIdsByTransDate(viewId, rangeFrom, rangeTo, columnName, colValue, dataType, periodFactor);
			   
			   List<BigInteger> unRecIds = new ArrayList<BigInteger>();
			   if(totalOriginalIds.size()>0)
			   {
				   List<BigInteger> recIds = new ArrayList<BigInteger>();
				   if("source".equalsIgnoreCase(sourceOrTarget))
				   {
					   recIds = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForSource(tenantId, groupId, totalOriginalIds, viewId);
				   }
				   else if("target".equalsIgnoreCase(sourceOrTarget))
				   {
					   recIds = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForTarget(tenantId, groupId, totalOriginalIds, viewId);
				   }
				   if(recIds.size()>0)
				   {
					   for(BigInteger id: totalOriginalIds)
					   {
						   if(!recIds.contains(id))
						   {
							   unRecIds.add(id);
						   }
					   }
					   HashMap total = new HashMap();
					   HashMap recon = new HashMap();
					   HashMap unRecon = new HashMap();
					   
					   String currencySymbolRec = "";
					   List<String> currenciesRec = getDistColumnValues(recIds,currencyCodeColName,dv.getDataViewName());
					   if(currenciesRec.size()==1)
					   {
						   currencySymbolRec = currencySymbolRec+getCurrencySymbol(currenciesRec.get(0));
					   }
					   else if(currenciesRec.size()>1)
					   {
						   currencySymbolRec = currencySymbolRec+"*";
					   }
					   
					   String currencySymbolUnRec = "";
					   List<String> currenciesUnRec = getDistColumnValues(unRecIds,currencyCodeColName,dv.getDataViewName());
					   if(currenciesUnRec.size()==1)
					   {
						   currencySymbolUnRec = currencySymbolUnRec+getCurrencySymbol(currenciesUnRec.get(0));
					   }
					   else if(currenciesUnRec.size()>1)
					   {
						   currencySymbolUnRec = currencySymbolUnRec+"*";
					   }
					   				   
					   if("reconciled".equalsIgnoreCase(status))
					   {
						   HashMap recAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, amountQualifier,recIds);
						   colValuMP.put("rAmount", currencySymbolRec + " " + reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
						   colValuMP.put("rCount", recAmountCount.get("totalCount"));
						   colValuMP.put("dCount", recIds.size());
						   
					   }
					   else if("unReconciled".equalsIgnoreCase(status))
					   {
						   HashMap unRecAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, amountQualifier,unRecIds);
						   colValuMP.put("uAmount", currencySymbolUnRec + " " + reconciliationResultService.getAmountInFormat(unRecAmountCount.get("totalAmount").toString(),currencyFormat));
						   colValuMP.put("uCount", unRecAmountCount.get("totalCount"));
						   colValuMP.put("dCount", unRecIds.size());					   
					   }
					   finalList.add(colValuMP);
				   }
			   }
		   }
	  }
	  return finalList;
  }*/
  public HashMap getDataTYpeNColumnName(Long colId)
  {
	  HashMap finalMap = new HashMap();
	  finalMap.put("dataType", "");
	  finalMap.put("columnName", "");
	  DataViewsColumns dvc = dataViewsColumnsRepository.findOne(colId);
	  if(dvc != null)
	  {
		  if("VARCHAR".equals(dvc.getColDataType()) || "DATE".equalsIgnoreCase(dvc.getColDataType()))
		  {
			  finalMap.put("dataType","string");
		  }
		  else if("INTEGER".equalsIgnoreCase(dvc.getColDataType()) || "DECIMAL".equalsIgnoreCase(dvc.getColDataType()))
		  {
			  finalMap.put("dataType","integer");
		  }
		  if("File Template".equalsIgnoreCase(dvc.getRefDvType()))
		  {
			  FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dvc.getRefDvColumn().toString()));
			  if(ftl != null)
			  {
				 finalMap.put("columnName", ftl.getColumnAlias());
			  }
		  }
		  else if("Data View".equalsIgnoreCase(dvc.getRefDvType()) || dvc.getRefDvType() == null)
		  {
			  finalMap.put("columnName", dvc.getColumnName());
		  }
	   }
	  return finalMap;
  }
  public String getCurrencySymbolByIds(List<BigInteger> originalIds, String currencyCodeColName, String dataViewName) throws SQLException, ParseException
  {
	  String currencySymbol = "";
	  List<String> currencies = getDistColumnValues(originalIds,currencyCodeColName, dataViewName);
	  if(currencies.size()==1)
	  {
		  currencySymbol = currencySymbol+getCurrencySymbol(currencies.get(0));
	  }
	  else if(currencies.size()>1)
	  {
		  currencySymbol = currencySymbol+"*";
	  }
	  return currencySymbol;
  }
  
/*  public HashMap getColSummaryForSource(String status, String colValue, List<BigInteger> totalIds, Long tenantId, Long groupId, Long viewId) throws ClassNotFoundException, SQLException, ParseException
  {
	  HashMap finalMap = new HashMap();
	  List<BigInteger> recIds = new ArrayList<BigInteger>();
	  List<BigInteger> unRecIds = new ArrayList<BigInteger>();
	  List<BigInteger> suggestedIds = new ArrayList<BigInteger>();
	  DataViews dv = dataViewsRepository.findOne(viewId);
	  String currencyCodeColName = getTransDateQualifier(new BigInteger(viewId.toString()), "CURRENCYCODE");
	  String amountQualifier = getTransDateQualifier(new BigInteger(viewId.toString()), "AMOUNT");
	  
	  Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	  String currencyFormat = props.getProperty("currencyFormat");
	  log.info("getColSummaryForSource: ViewID: "+viewId+", CurrencyCodeColName: "+currencyCodeColName+", AmountQualifier: "+amountQualifier);
	  if(totalIds.size()>0)
	  {
		  recIds = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForSource(tenantId, groupId, totalIds, viewId);
		  suggestedIds = reconciliationDuplicateResultRepository.fetchReconciledIdswithStatusUnreconciledForSource(tenantId, groupId, totalIds, viewId);
		  log.info("RecIds Size: "+recIds.size());
		  log.info("Suggested Ids Size: "+suggestedIds.size());
		  for(BigInteger id : totalIds)
		  {
			  if(!recIds.contains(id))
			  {
				  unRecIds.add(id);
			  }
		  }
		  unRecIds.removeAll(suggestedIds); // Removing suggested Ids
		  log.info("UnRecIds Size: "+unRecIds.size());
		  if("reconciled".equalsIgnoreCase(status))
		  {
			  if(recIds.size()>0)
			  {
				  String currencySymbol = getCurrencySymbolByIds(recIds, currencyCodeColName, dv.getDataViewName());
				  HashMap recAmountCount = reconciliationResultService.getCountNAmountForDVId(BigInteger.valueOf(viewId), tenantId, amountQualifier,recIds);
				  finalMap.put("sAmount", currencySymbol +" " +reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
				  finalMap.put("sCount", recAmountCount.get("totalCount"));
				  finalMap.put("dsCount", recIds.size());
				  
				  finalMap.put("tAmount", 0.0);
				  finalMap.put("tCount", 0);
				  finalMap.put("dtCount", 0);
			  }
		  }
		  else if("unReconciled".equalsIgnoreCase(status))
		  {
			  if(unRecIds.size()>0)
			  {
				  String currencySymbol = getCurrencySymbolByIds(unRecIds, currencyCodeColName, dv.getDataViewName());
				  HashMap recAmountCount = reconciliationResultService.getCountNAmountForDVId(BigInteger.valueOf(viewId), tenantId, amountQualifier,unRecIds);
				  finalMap.put("sAmount", currencySymbol +" " +reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
				  finalMap.put("sCount", recAmountCount.get("totalCount"));
				  finalMap.put("dsCount", recIds.size());
				  
				  finalMap.put("tAmount", 0.0);
				  finalMap.put("tCount", 0);
				  finalMap.put("dtCount", 0);
			  }
		  }
		  else if("suggestion".equalsIgnoreCase(status))
		  {
			  log.info("In Suggestion Block");
			  if(suggestedIds.size()>0)
			  {
				  String currencySymbol = getCurrencySymbolByIds(suggestedIds, currencyCodeColName, dv.getDataViewName());
				  log.info("Currency Symbol: "+currencySymbol);
				  HashMap recAmountCount = reconciliationResultService.getCountNAmountForDVId(BigInteger.valueOf(viewId), tenantId, amountQualifier,suggestedIds);
				  finalMap.put("sAmount", currencySymbol +" " +reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
				  finalMap.put("sCount", recAmountCount.get("totalCount"));
				  finalMap.put("dsCount", suggestedIds.size());
				  
				  finalMap.put("tAmount", 0.0);
				  finalMap.put("tCount", 0);
				  finalMap.put("dtCount", 0);
			  }
		  }
	  }
	  return finalMap;
  }*/
  
  /*public HashMap getColSummaryForTarget(String status, String colValue,List<BigInteger> totalIds, Long tenantId, Long groupId, Long viewId) throws ClassNotFoundException, SQLException, ParseException
  {
	  HashMap finalMap = new HashMap();
	  List<BigInteger> recIds = new ArrayList<BigInteger>();
	  List<BigInteger> unRecIds = new ArrayList<BigInteger>();
	  List<BigInteger> suggestedIds = new ArrayList<BigInteger>();
	  DataViews dv = dataViewsRepository.findOne(viewId);
	  String currencyCodeColName = getTransDateQualifier(new BigInteger(viewId.toString()), "CURRENCYCODE");
	  String amountQualifier = getTransDateQualifier(new BigInteger(viewId.toString()), "AMOUNT");
	  Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	  String currencyFormat = props.getProperty("currencyFormat");
	  if(totalIds.size()>0)
	  {
		  recIds = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForTarget(tenantId, groupId, totalIds, viewId);
		  suggestedIds = reconciliationDuplicateResultRepository.fetchReconciledIdswithStatusUnreconciledForTarget(tenantId, groupId, totalIds, viewId);
		  for(BigInteger id : totalIds)
		  {
			  if(!recIds.contains(id))
			  {
				  unRecIds.add(id);
			  }
		  }
		  unRecIds.removeAll(suggestedIds);
		  if("reconciled".equalsIgnoreCase(status))
		  {
			  if(recIds.size()>0)
			  {
				  String currencySymbol = getCurrencySymbolByIds(recIds, currencyCodeColName, dv.getDataViewName());
				  HashMap recAmountCount = reconciliationResultService.getCountNAmountForDVId(BigInteger.valueOf(viewId), tenantId, amountQualifier,recIds);
				  finalMap.put("tAmount", currencySymbol +" " +reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
				  finalMap.put("tCount", recAmountCount.get("totalCount"));
				  finalMap.put("dtCount", recIds.size());
				  
				  finalMap.put("sAmount", 0.0);
				  finalMap.put("sCount", 0);
				  finalMap.put("dsCount", 0);
			  }
		  }
		  else if("unReconciled".equalsIgnoreCase(status))
		  {
			  if(unRecIds.size()>0)
			  {
				  String currencySymbol = getCurrencySymbolByIds(unRecIds, currencyCodeColName, dv.getDataViewName());
				  HashMap recAmountCount = reconciliationResultService.getCountNAmountForDVId(BigInteger.valueOf(viewId), tenantId, amountQualifier,unRecIds);
				  finalMap.put("tAmount", currencySymbol +" " +reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
				  finalMap.put("tCount", recAmountCount.get("totalCount"));
				  finalMap.put("dtCount", recIds.size());
				  
				  finalMap.put("sAmount", 0.0);
				  finalMap.put("sCount", 0);
				  finalMap.put("dsCount", 0);
			  }
		  }
		  else if("suggestion".equalsIgnoreCase(status))
		  {
			  if(suggestedIds.size()>0)
			  {
				  String currencySymbol = getCurrencySymbolByIds(suggestedIds, currencyCodeColName, dv.getDataViewName());
				  HashMap recAmountCount = reconciliationResultService.getCountNAmountForDVId(BigInteger.valueOf(viewId), tenantId, amountQualifier,suggestedIds);
				  finalMap.put("tAmount", currencySymbol +" " +reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
				  finalMap.put("tCount", recAmountCount.get("totalCount"));
				  finalMap.put("dtCount", recIds.size());
				  
				  finalMap.put("sAmount", 0.0);
				  finalMap.put("sCount", 0);
				  finalMap.put("dsCount", 0);
			  }
		  }
	  }
	  return finalMap;
  }*/
 
/*  public HashMap getColumnValuesUnRecSummary2(ReconCountNAmountsDTO params, List<String> sCols, List<String> tCols, List<String> commonCols, Long groupId, Long sViewId, Long tViewId) throws ClassNotFoundException, SQLException, ParseException
  {
	  HashMap finalMap = new HashMap();
  	  DataViews sdv = dataViewsRepository.findOne(sViewId);
  	  DataViews tdv = dataViewsRepository.findOne(tViewId);
  	  List<HashMap> finalList = new ArrayList<HashMap>();
  	  if(sdv != null && tdv != null)
  	  {
  		 log.info("Source and target views exist.");
  		 if(sCols.size()>0)
  		 {
  			 log.info("Source Columns: "+ sCols);
  			 for(String col : sCols)
  			 {
  				 HashMap mp = getDataTYpeNColumnName(params.getsColumnId());
  				 List<BigInteger> totalOriginalIds = getOriginalIdsByTransDate(sViewId, params.getRangeFrom(), params.getRangeTo(), mp.get("columnName").toString(), col, mp.get("dataType").toString(), params.getPeriodFactor());
  				 HashMap colMap = getColSummaryForSource(params.getStatus(), col, totalOriginalIds, params.getTenantId(),groupId, sViewId);
  				 if(colMap.size()>0)
  				 {
  					 colMap.put("name", col);
  	  				 finalList.add(colMap); 
  				 }
  			 }
  		 }
  		 if(tCols.size()>0)
  		 {
  			 log.info("Target Columns: "+tCols);
  			 for(String col : tCols)
  			 {
  				 HashMap mp = getDataTYpeNColumnName(params.gettColumnId()); 
  				 List<BigInteger> totalOriginalIds = getOriginalIdsByTransDate(tViewId, params.getRangeFrom(), params.getRangeTo(), mp.get("columnName").toString(), col, mp.get("dataType").toString(), params.getPeriodFactor());

  				 HashMap colMap = getColSummaryForTarget(params.getStatus(), col, totalOriginalIds,params.getTenantId(), groupId, tViewId);
  				 if(colMap.size()>0)
  				 {
  					 colMap.put("name", col);
  	  				 finalList.add(colMap);
  				 }
  			 }
  		 }
  		 if(commonCols.size()>0)
  		 {
  			 log.info("Common Columns: "+ commonCols);
  			 for(String col : commonCols)
  			 {
  				 HashMap smp = getDataTYpeNColumnName(params.getsColumnId());
  				 List<BigInteger> sTotalIds = getOriginalIdsByTransDate(sViewId, params.getRangeFrom(), params.getRangeTo(), smp.get("columnName").toString(), col, smp.get("dataType").toString(), params.getPeriodFactor());

  				 HashMap tmp = getDataTYpeNColumnName(params.gettColumnId()); 
  				 List<BigInteger> tTotalIds = getOriginalIdsByTransDate(tViewId, params.getRangeFrom(), params.getRangeTo(), tmp.get("columnName").toString(), col, tmp.get("dataType").toString(), params.getPeriodFactor());
  				 
  				 HashMap colMapSrc = getColSummaryForSource(params.getStatus(), col, sTotalIds,params.getTenantId(), groupId, sViewId);
  				 HashMap colMapTrgt = getColSummaryForTarget(params.getStatus(), col, tTotalIds,params.getTenantId(), groupId, tViewId);
  				 log.info("Common: SourceMap: "+colMapSrc+", TargetMap: "+colMapTrgt);
  				 if(colMapSrc.size() > 0 && colMapTrgt.size() > 0)
  				 {
  					 HashMap commonMap = new HashMap();
  					 commonMap.put("sAmount", colMapSrc.get("sAmount").toString());
  					 commonMap.put("sCount", colMapSrc.get("sCount").toString());
  					 commonMap.put("dsCount", Integer.parseInt(colMapSrc.get("dsCount").toString()));
  					 commonMap.put("name", col); 
  					 commonMap.put("tAmount", colMapTrgt.get("tAmount").toString());
  					 commonMap.put("tCount", colMapTrgt.get("tCount").toString());
  					 commonMap.put("dtCount", Integer.parseInt(colMapTrgt.get("dtCount").toString()));
  					 finalList.add(commonMap);
  				 }
  			 }
  		 }
  	  }
  	  else
  	  {
  		  log.info("There are no data views found for the source view id: "+params.getsViewId() +" or target data view id: "+ params.gettViewId()); 
  	  }
  	  
	  finalMap.put("summary", finalList);
	  finalMap.put("status", "");
	  return finalMap;
  }
*/  
/*  public HashMap getColumnValuesUnRecSummary(ReconCountNAmountsDTO params, List<String> sCols, List<String> tCols, List<String> commonCols, Long groupId, Long sViewId, Long tViewId) throws ClassNotFoundException, SQLException, ParseException
  {
	  HashMap finalMap = new HashMap();
	  List<HashMap> finalList = new ArrayList<HashMap>();
	  Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
  	  DataViews sdv = dataViewsRepository.findOne(sViewId);
  	  DataViews tdv = dataViewsRepository.findOne(tViewId);
  	  if(sdv != null && tdv != null)
  	  {
  		  log.info("Source and target views exist.");
  		  if(sCols.size()>0)
  		  {
  			  log.info("Fetching source column values summary info");
  			  HashMap mp = getDataTYpeNColumnName(params.getsColumnId()); 
  			  log.info("Source column column name: "+ mp.get("columnName").toString()+", data type: "+ mp.get("dataType").toString());
  			  HashMap map = getColValuesUnRecSummaryInfo(sCols, params, "source", mp.get("columnName").toString(), mp.get("dataType").toString(), groupId, sViewId, tViewId);
  			  finalList.addAll((List<HashMap>) map.get("summary"));
  			  log.info("Source column values summary size: "+ finalList.size());
  		  }
  		  if(tCols.size()>0)
  		  {
  			log.info("Fetching target column values summary info");
  			 HashMap mp = getDataTYpeNColumnName(params.gettColumnId());
  			 HashMap map = getColValuesUnRecSummaryInfo(tCols, params, "target", mp.get("columnName").toString(), mp.get("dataType").toString(), groupId, sViewId, tViewId);
  			 finalList.addAll((List<HashMap>) map.get("summary"));
  		  }
  		  if(commonCols.size()>0)
  		  {
  			 log.info("Fetching common column values summary info");
  			 HashMap map = getColValuesUnRecSummaryInfo(commonCols, params, "common", "", "", groupId, sViewId, tViewId);
  			 finalList.addAll((List<HashMap>) map.get("summary"));
  		  }
  	  }
  	  else
  	  {
  		 log.info("There are no data views found for the source view id: "+params.getsViewId() +" or target data view id: "+ params.gettViewId()); 
  	  }
	  finalMap.put("summary", finalList);
	  finalMap.put("status", "");
	  return finalMap;
  }
*/  
  @Transactional
  public List<BigInteger> getOriginalIdsForDays(Long viewId, String rangeFrom, String rangeTo, String qualifier, String transDate, String periodFactor) throws SQLException
  {
	   List<BigInteger> viewOriginalIds = new ArrayList<BigInteger>();
	   Connection conn = null;
	   Statement stmt = null;
	   ResultSet result = null; 
	   try{
			DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
			conn = ds.getConnection();
		   stmt = conn.createStatement();
    	   DataViews dv=dataViewsRepository.findOne(viewId.longValue());
    	   if(dv!= null)
    	   {
    		   String viewName = dv.getDataViewName();
        	   String query = "";
        	   if("fileDate".equalsIgnoreCase(periodFactor))
        	   {
        		   log.info("Total Ids Query: "+"SELECT scrIds FROM `"+viewName.toLowerCase()+"` where Date(fileDate) between '"+rangeFrom+"' AND '"+rangeTo+"' and Date(fileDate) REGEXP '"+transDate+"'");
         		   query = "SELECT scrIds FROM `"+viewName.toLowerCase()+"` where Date(fileDate) between '"+rangeFrom+"' AND '"+rangeTo+"' and Date(fileDate) REGEXP '"+transDate+"'";
        	   }
        	   else if("dateQualifier".equalsIgnoreCase(periodFactor))
        	   {
        		   log.info("Total Ids Query: "+"SELECT scrIds FROM `"+viewName.toLowerCase()+"` where Date(`"+qualifier+"`) between '"+rangeFrom+"' AND '"+rangeTo+"' and Date(`"+qualifier+"`) REGEXP '"+transDate+"'");
        		   query = "SELECT scrIds FROM `"+viewName.toLowerCase()+"` where Date(`"+qualifier+"`) between '"+rangeFrom+"' AND '"+rangeTo+"' and Date(`"+qualifier+"`) REGEXP '"+transDate+"'";
        	   }
        	   result=stmt.executeQuery(query);
	       	   while(result.next()){
	       		   viewOriginalIds.add(new BigInteger((result.getString(1))));
	       	   }  
    	   }
    	   else
    	   {
    		   log.info("View doen't not exist for the view id: "+viewId);
    	   }
	   }
	   catch(SQLException se){
		   log.info("Error while executing query: "+se);
      }
	   catch(Exception e)
	   {
		   log.info("Exception while getting databse properties");
	   }
	   finally{
	   		if(result != null)
	   			result.close();	
	   		if(stmt != null)
	   			stmt.close();
			if(conn != null)
				conn.close();
			}
  	return viewOriginalIds;

  }

  public HashMap updateAppModuleSummaryForSource(String amountQualifier, Long viewId, Long groupId, String module, String type, String status, Long userId) throws SQLException, ClassNotFoundException
  {
	  	log.info("Updating counts and amounts in app_module_summary table for source...");
	  	HashMap finalMap = new HashMap();
	  	Connection conn = null;
	  	Statement countAmntsStmt = null;
	  	ResultSet countAmntsRS = null;
	  	
	  	Statement dvStmt = null;
	  	ResultSet dvRS = null;	  	
	  	
    	PreparedStatement appModSumIdsStmt = null;
    	ResultSet appModSumIdsRS = null;
    	
    	PreparedStatement checkRecordStmt = null;
    	ResultSet checkRecordRS = null;

    	Statement updateExistedRecordStmt = null;
    	String timeStamp = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date());

    	try
	  	{
			DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
			conn = ds.getConnection();
	  		DataViews dv=dataViewsRepository.findOne(viewId.longValue());
	    	// Fetching app_module_summary ids based on status
	    	String appModSumIdsQuery = "select id from t_app_module_summary where rule_group_id = "+groupId+" and view_id = "+viewId+" and module = 'Reconciliation' and type = 'Source'";
	    	List<Long> appModSumIds = new ArrayList<Long>();
	    	appModSumIdsStmt = conn.prepareStatement(appModSumIdsQuery);
    		appModSumIdsRS = appModSumIdsStmt.executeQuery();
		    while(appModSumIdsRS.next())
		    {
		    	appModSumIds.add(appModSumIdsRS.getLong(1));
		    }
    		log.info("App Module Summary Ids: "+appModSumIds.size());

	  		if(dv != null)
	  		{
	  			String dvQuery = "select Date(fileDate), count(*), sum(`"+amountQualifier+"`) from `"+dv.getDataViewName().toLowerCase()+"` group by Date(fileDate)";
	  			dvStmt = conn.createStatement();
	  			dvRS = dvStmt.executeQuery(dvQuery);
	  			HashMap dvMap = new HashMap();
	  			while(dvRS.next())
	  			{
	  				HashMap dateMap = new HashMap();
	  				dateMap.put("count", dvRS.getString(2));
	  				dateMap.put("amount", dvRS.getString(3));
	  				dvMap.put(dvRS.getString(1), dateMap);
	  			}
	  			log.info("DV Dates Count And Amounts Size: "+dvMap.size());
		  		String query = "select Date(dv.`fileDate`), count(*), sum(dv.`"+amountQualifier+"`),"
		  				+ "    recon.reconciliation_rule_id, recon.reconciliation_rule_group_id"
		  				+ "    from t_reconciliation_result recon,"
		  				+ "    `"+dv.getDataViewName().toLowerCase()+"` dv"
		  				+ "	   where reconciliation_rule_group_id = "+groupId+" "
		  				+ "    and original_view_id = "+viewId+""
		  				+ "    and current_record_flag is true"
		  				+ "    and recon.original_row_id = dv.scrIds"
		  				+ "    and recon_status = 'RECONCILED'"
		  				+ "    group by Date(dv.`fileDate`),reconciliation_rule_id, reconciliation_rule_group_id";
		  		
				countAmntsStmt = conn.createStatement();
		  		countAmntsRS = countAmntsStmt.executeQuery(query);
		  		
		  		while(countAmntsRS.next()){
		    		  String date = countAmntsRS.getString(1);
		    		  Long count = Long.parseLong(countAmntsRS.getString(2));
		    		  BigDecimal amount = new BigDecimal(countAmntsRS.getString(3));
		    		  Long ruleId = Long.parseLong(countAmntsRS.getString(4));
		    		  LocalDate localDate = LocalDate.parse(date);
		    		  HashMap getDVMap = (HashMap) dvMap.get(date);
		    		  Long dvCount = Long.parseLong(getDVMap.get("count").toString());
		    		  BigDecimal dvAmount = new BigDecimal(getDVMap.get("amount").toString());
/*		    		  
		    		  AppModuleSummary checkRecord = appModuleSummaryRepository.findByFileDateAndModuleAndRuleGroupIdAndRuleIdAndViewIdAndType(localDate, module, groupId, ruleId, viewId, type);
*/		    		  
	    		    	// Check to record exist in app_module_summary table or not
	    		    	String checkRecordquery = "select * from t_app_module_summary where file_date = '"+date+"' and module = 'Reconciliation' and rule_group_id = "+groupId+" and rule_id = "+ruleId+" and view_id = "+viewId+" and type = 'Source'";

	    		    	checkRecordStmt = conn.prepareStatement(checkRecordquery);
	    		    	checkRecordRS = checkRecordStmt.executeQuery();
	    		    	int size = 0;
	    		    	Long id = null;
	    		    	while(checkRecordRS.next())
	    		    	{
	    		    		id = Long.parseLong(checkRecordRS.getString("id"));
	    		    		size = size + 1;
	    		    	}
	    		    	log.info("AppModuleSummaryID: "+id+", Size: "+size);

	    		    	if(size > 0)
	    		    	{
	    		    		if(size == 1)
	    		    		{
	    		    			// Updating existing record
	    		    			String updateQuery =  "update t_app_module_summary set type_count = "+count+", type_amt = "+amount+", dv_count = "+dvCount+", dv_amt = "+dvAmount+", last_updated_date = '"+timeStamp+"', last_updated_by = "+userId+" where id = "+id;
	    		    			updateExistedRecordStmt = conn.createStatement();
	    		    			updateExistedRecordStmt.executeUpdate(updateQuery);
	    		    			log.info("Updated app module summary for id: "+id);
	    		    			appModSumIds.remove(id);	// Removing updated Record
	    		    		}
	    		    		else
	    		    		{
	    		    			log.info("Duplicate records exist while updating count and amounts for the group id: "+ groupId+", viewId: "+ viewId+", date: "+ date+", ruleId: "+ ruleId+", status: Source, module: Reconciliation");
	    		    		}
	    		    	}
	    		    	else
	    		    	{
	    		    		log.info("Need to insert a record once data transmission has been completed for group id: "+ groupId+", viewId: "+ viewId+", date: "+ date+", ruleId: "+ ruleId+", status: Source, module: Reconciliation");
	    		    
	    		    		String insertTableSQL = "INSERT INTO t_app_module_summary"
	    		    				+ "(file_date, module, rule_group_id, rule_id, view_id, type, type_count, created_date, last_updated_date, type_amt, dv_count, dv_amt) VALUES"
	    		    				+ "(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
	    				    PreparedStatement preparedStatement = conn.prepareStatement(insertTableSQL);
	    				    preparedStatement.setDate(1, java.sql.Date.valueOf(date));
	    				    preparedStatement.setString(2, "Reconciliation");
	    				    preparedStatement.setLong(3, groupId);
	    				    if(ruleId != null)
	    				    {
	    				    	preparedStatement.setLong(4, ruleId);	
	    				   	}
	    				   	else
	    				   	{
	    				    	preparedStatement.setNull(4, java.sql.Types.INTEGER);
	    				   	}
	    				    preparedStatement.setLong(5, viewId);
	    				    preparedStatement.setString(6, "Source");
	    				    preparedStatement.setLong(7, count);
	    				    preparedStatement.setTimestamp(8, new java.sql.Timestamp(System.currentTimeMillis()));
	    				   	preparedStatement.setTimestamp(9, new java.sql.Timestamp(System.currentTimeMillis()));
	    				  	preparedStatement.setBigDecimal(10, amount);
	    				  	preparedStatement.setLong(11, dvCount);
	    				  	preparedStatement.setBigDecimal(12, dvAmount);
	    			 		// execute insert SQL stetement
	    		    		preparedStatement .executeUpdate();
	    		    	}
		  		}
		  		log.info("AppModuleSummaryIds After removing Ids: "+appModSumIds);
		  		if(appModSumIds.size()>0)
		  		{
    		    	for(Long id : appModSumIds)
    		    	{
    		    		String dvCountAmtQuery = "select * from t_app_module_summary where id = "+id;
    		  			dvStmt = conn.createStatement();
    		  			dvRS = dvStmt.executeQuery(dvCountAmtQuery);
    		  			Long dvCount = 0L;
    		  			BigDecimal dvAmount = new BigDecimal("0.0");
    		  			String date = "";
    		  			while(dvRS.next())
    		  			{
    		  				date = dvRS.getString("file_date");
    		  			}
    		  			HashMap getDVMap = (HashMap) dvMap.get(date);
    		  			if(getDVMap != null)
    		  			{
        		  			dvCount = Long.parseLong(getDVMap.get("count").toString());
        		  			dvAmount = new BigDecimal(getDVMap.get("amount").toString());
    		  			}

    		    		String updateQuery = "update t_app_module_summary set type_count = 0, type_amt = 0.0, dv_count = "+dvCount+", dv_amt = "+dvAmount+", last_updated_date = '"+timeStamp+"', last_updated_by = "+userId+" where id = "+id;
    		    		updateExistedRecordStmt = conn.createStatement();
    		    		updateExistedRecordStmt.executeUpdate(updateQuery);
    		    	}
    		    	System.out.println("Updated Remainig Records: "+appModSumIds);
		  			log.info("Updated remaining app module summary ids: "+appModSumIds);
		  		}
	  		}
	  	}
	  	catch(Exception e)
	  	{
	  		log.info("Exception while updating count and amounts in app_module_summary: "+e);
	  	}
	  	finally
	  	{
	  		// ResultSet
	  		if(countAmntsRS != null)
	  			countAmntsRS.close();
    		if(appModSumIdsRS != null)
    			appModSumIdsRS.close();
    		if(checkRecordRS != null)
    			checkRecordRS.close();
    		if(dvRS != null)
    			dvRS.close();
	  		// Statement
		  	if(countAmntsStmt != null)
		  		countAmntsStmt.close();
   	        if(appModSumIdsStmt != null)
   	        	appModSumIdsStmt.close();
   	        if(checkRecordStmt != null)
   	        	checkRecordStmt.close();
   	        if(updateExistedRecordStmt != null)
   	        	updateExistedRecordStmt.close();
   	        if(dvStmt != null)
   	        	dvStmt.close();
	  		// Connection
	  		if(conn != null)
	  			conn.close();
	  	}
	  	
	  	return finalMap;
  }
  
  
  public HashMap updateAppModuleSummaryForTarget(String amountQualifier, Long viewId, Long groupId, String module, String type, String status, Long userId) throws SQLException, ClassNotFoundException
  {
	  	log.info("Updating counts and amounts in app_module_summary table for target...");
	  	HashMap finalMap = new HashMap();
	  	Connection conn = null;
	  	Statement countAmntsStmt = null;
	  	ResultSet countAmntsRS = null;
	  	
	  	PreparedStatement appModSumIdsStmt = null;
	  	ResultSet appModSumIdsRS = null;
  	
	  	PreparedStatement checkRecordStmt = null;
	  	ResultSet checkRecordRS = null;
	  	
	  	Statement dvStmt = null;
	  	ResultSet dvRS = null;	
  	
	  	Statement updateExistedRecordStmt = null;
  	
	  	String timeStamp = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date());
  	
	  	try
	  	{
			DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
			conn = ds.getConnection();
	  		DataViews dv=dataViewsRepository.findOne(viewId.longValue());
	  		
	    	// Fetching app_module_summary ids based on status
	    	String appModSumIdsQuery = "select id from t_app_module_summary where rule_group_id = "+groupId+" and view_id = "+viewId+" and module = 'Reconciliation' and type = 'Target'";
	    	List<Long> appModSumIds = new ArrayList<Long>();
	    	appModSumIdsStmt = conn.prepareStatement(appModSumIdsQuery);
	    	appModSumIdsRS = appModSumIdsStmt.executeQuery();
	    	
		    while(appModSumIdsRS.next())
		    {
		    	appModSumIds.add(appModSumIdsRS.getLong(1));
		    }
		    log.info("App Module Summary Ids: "+appModSumIds.size());

	  		if(dv != null)
	  		{
	  			String dvQuery = "select Date(fileDate), count(*), sum(`"+amountQualifier+"`) from `"+dv.getDataViewName().toLowerCase()+"` group by Date(fileDate)";
	  			dvStmt = conn.createStatement();
	  			dvRS = dvStmt.executeQuery(dvQuery);
	  			HashMap dvMap = new HashMap();
	  			while(dvRS.next())
	  			{
	  				HashMap dateMap = new HashMap();
	  				dateMap.put("count", dvRS.getString(2));
	  				dateMap.put("amount", dvRS.getString(3));
	  				dvMap.put(dvRS.getString(1), dateMap);
	  			}
	  			log.info("DV Dates Count And Amounts Size: "+dvMap.size());
	  			
		  		String query = "select Date(dv.`fileDate`), count(*), sum(dv.`"+amountQualifier+"`), "
		  				+ "    recon.reconciliation_rule_id, recon.reconciliation_rule_group_id"
		  				+ "    from t_reconciliation_result recon,"
		  				+ "    `"+dv.getDataViewName().toLowerCase()+"` dv"
		  				+ "	   where reconciliation_rule_group_id = "+groupId+" "
		  				+ "		and target_view_id = "+viewId+""
		  				+ "    and current_record_flag is true"
		  				+ "		and recon.target_row_id = dv.scrIds  "
		  				+ "    and recon_status = 'RECONCILED' "
		  				+ "    group by Date(`fileDate`),reconciliation_rule_id, reconciliation_rule_group_id";
		  		
				countAmntsStmt = conn.createStatement();
		  		countAmntsRS = countAmntsStmt.executeQuery(query);
		  		
		  		while(countAmntsRS.next()){
		    		  String date = countAmntsRS.getString(1);
		    		  Long count = Long.parseLong(countAmntsRS.getString(2));
		    		  BigDecimal amount = new BigDecimal(countAmntsRS.getString(3));
		    		  Long ruleId = Long.parseLong(countAmntsRS.getString(4));
		    		  LocalDate localDate = LocalDate.parse(date);
		    		  HashMap getDVMap = (HashMap) dvMap.get(date);
		    		  Long dvCount = Long.parseLong(getDVMap.get("count").toString());
		    		  BigDecimal dvAmount = new BigDecimal(getDVMap.get("amount").toString());
/*		    		  
		    		  AppModuleSummary checkRecord = appModuleSummaryRepository.findByFileDateAndModuleAndRuleGroupIdAndRuleIdAndViewIdAndType(localDate, module, groupId, ruleId, viewId, type);
*/		    		  
	    		    	// Check to record exist in app_module_summary table or not
	    		    	String checkRecordquery = "select * from t_app_module_summary where file_date = '"+date+"' and module = 'Reconciliation' and rule_group_id = "+groupId+" and rule_id = "+ruleId+" and view_id = "+viewId+" and type = 'Target'";

	    		    	checkRecordStmt = conn.prepareStatement(checkRecordquery);
	    		    	checkRecordRS = checkRecordStmt.executeQuery();
	    		    	int size = 0;
	    		    	Long id = null;
	    		    	while(checkRecordRS.next())
	    		    	{
	    		    		id = Long.parseLong(checkRecordRS.getString("id"));
	    		    		size = size + 1;
	    		    	}
	    		    	log.info("AppModuleSummaryID: "+id+", Size: "+size);

	    		    	if(size > 0)
	    		    	{
	    		    		if(size == 1)
	    		    		{
	    		    			// Updating existing record
	    		    			String updateQuery =  "update t_app_module_summary set type_count = "+count+", type_amt = "+amount+", dv_count = "+dvCount+", dv_amt = "+dvAmount+", last_updated_date = '"+timeStamp+"', last_updated_by = "+userId+" where id = "+id;
	    		    			updateExistedRecordStmt = conn.createStatement();
	    		    			updateExistedRecordStmt.executeUpdate(updateQuery);
	    		    			log.info("Updated app module summary for id: "+id);
	    		    			appModSumIds.remove(id);	// Removing updated Record
	    		    		}
	    		    		else
	    		    		{
	    		    			log.info("Duplicate records exist while updating count and amounts for the group id: "+ groupId+", viewId: "+ viewId+", date: "+ date+", ruleId: "+ ruleId+", status: Target, module: Reconciliation");
	    		    		}
	    		    	}
	    		    	else
	    		    	{
	    		    		log.info("Need to insert a record once data transmission has been completed for group id: "+ groupId+", viewId: "+ viewId+", date: "+ date+", ruleId: "+ ruleId+", status: Target, module: Reconciliation");
	    		    
	    		    		String insertTableSQL = "INSERT INTO t_app_module_summary"
	    		    				+ "(file_date, module, rule_group_id, rule_id, view_id, type, type_count, created_date, last_updated_date, type_amt, dv_count, dv_amt) VALUES"
	    		    				+ "(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
	    				    PreparedStatement preparedStatement = conn.prepareStatement(insertTableSQL);
	    				    preparedStatement.setDate(1, java.sql.Date.valueOf(date));
	    				    preparedStatement.setString(2, "Reconciliation");
	    				    preparedStatement.setLong(3, groupId);
	    				    if(ruleId != null)
	    				    {
	    				    	preparedStatement.setLong(4, ruleId);	
	    				   	}
	    				   	else
	    				   	{
	    				    	preparedStatement.setNull(4, java.sql.Types.INTEGER);
	    				   	}
	    				    preparedStatement.setLong(5, viewId);
	    				    preparedStatement.setString(6, "Target");
	    				    preparedStatement.setLong(7, count);
	    				    preparedStatement.setTimestamp(8, new java.sql.Timestamp(System.currentTimeMillis()));
	    				   	preparedStatement.setTimestamp(9, new java.sql.Timestamp(System.currentTimeMillis()));
	    				  	preparedStatement.setBigDecimal(10, amount);
	    				  	preparedStatement.setLong(11, dvCount);
	    				  	preparedStatement.setBigDecimal(12, dvAmount);
	    			 		// execute insert SQL stetement
	    		    		preparedStatement .executeUpdate();
	    		    	}
		  		}
		  		log.info("AppModuleSummaryIds After removing Ids: "+appModSumIds);
		  		if(appModSumIds.size()>0)
		  		{
	  		    	for(Long id : appModSumIds)
	  		    	{
    		    		String dvCountAmtQuery = "select * from t_app_module_summary where id = "+id;
    		  			dvStmt = conn.createStatement();
    		  			dvRS = dvStmt.executeQuery(dvCountAmtQuery);
    		  			Long dvCount = 0L;
    		  			BigDecimal dvAmount = new BigDecimal("0.0");
    		  			String date = "";
    		  			while(dvRS.next())
    		  			{
    		  				date = dvRS.getString("file_date");
    		  			}
    		  			HashMap getDVMap = (HashMap) dvMap.get(date);
    		  			if(getDVMap != null)
    		  			{
        		  			dvCount = Long.parseLong(getDVMap.get("count").toString());
        		  			dvAmount = new BigDecimal(getDVMap.get("amount").toString());
    		  			}
    		  			
	  		    		String updateQuery = "update t_app_module_summary set type_count = 0, type_amt = 0.0, dv_count = "+dvCount+", dv_amt = "+dvAmount+", last_updated_date = '"+timeStamp+"', last_updated_by = "+userId+" where id = "+id;
	  		    		updateExistedRecordStmt = conn.createStatement();
	  		    		updateExistedRecordStmt.executeUpdate(updateQuery);
	  		    	}
	  		    	System.out.println("Updated Remainig Records: "+appModSumIds);
		  			log.info("Updated remaining app module summary ids: "+appModSumIds);
		  		}
	  		}
	  	}
	  	catch(Exception e)
	  	{
	  		// log.info("Exception while updating count and amounts in app_module_summary: "+e);
	  	}
	  	finally
	  	{
	  		// ResultSet
	  		if(countAmntsRS != null)
	  			countAmntsRS.close();
	  		if(appModSumIdsRS != null)
	  			appModSumIdsRS.close();
	  		if(checkRecordRS != null)
	  			checkRecordRS.close();
	  		if(dvRS != null)
				dvRS.close();
	  		// Statement
		  	if(countAmntsStmt != null)
		  		countAmntsStmt.close();
 	        if(appModSumIdsStmt != null)
 	        	appModSumIdsStmt.close();
 	        if(checkRecordStmt != null)
 	        	checkRecordStmt.close();
 	        if(updateExistedRecordStmt != null)
 	        	updateExistedRecordStmt.close();
 	       if(dvStmt != null)
  	        	dvStmt.close();
	  		// Connection
	  		if(conn != null)
	  			conn.close();
	  	}
	  	
	  	return finalMap;
  }
  
	public HashMap updateAppModuleSummaryInfoSource(String amountQualifier, String viewName, Long groupId, Long viewId, String status, Long ruleId, Long userId) throws ClassNotFoundException, SQLException
	{
		System.out.println("Updating count and amounts for for Source Reconciliation...");
		HashMap finalMap = new HashMap();
		Connection conn = null;	
		ResultSet countsAmountsRS = null;
		PreparedStatement fetchCountAmntsStmt = null;
		PreparedStatement checkRecordStmt = null;
		Statement updateStament = null;
		ResultSet checkRecordRS = null;
  	
		PreparedStatement appModSumIdsStmt = null;
		ResultSet appModSumIdsRS = null;
		Statement updateExistedRecordStmt = null;
		
		try
		{
			String timeStamp = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date());			
	    	// Fetching app_module_summary ids based on status
			List<Long> appSummaryIds = new ArrayList<Long>();
			String appModSumIdsQuery = "select id from t_app_module_summary where module = 'Reconciliation' and rule_group_id = "+groupId+" and view_id = "+viewId+" and type = 'Source'";
			appModSumIdsStmt = conn.prepareStatement(appModSumIdsQuery);
			appModSumIdsRS = appModSumIdsStmt.executeQuery();
  		
		    while(appModSumIdsRS.next())
		    {
		    	appSummaryIds.add(appModSumIdsRS.getLong(1));
		    }
		    System.out.println("AppModuleSummaryIds for "+status+" status: "+appSummaryIds);
			
			String countsAmntsQuery = "select Date(grp.`fileDate`), count(*), sum(grp.`"+amountQualifier+"`), grp.reconciliation_rule_id from ("
					+ " 	select dv.*, recon.recon_status,"
					+ "     recon.reconciliation_rule_id"
					+ "     from t_reconciliation_result recon,"
					+ "		t_rule_group_details rgd, "
					+ "     t_rules rl, "
					+ "     "+viewName+" dv"
					+ " 	where reconciliation_rule_group_id = "+groupId+" "
					+ " 	and original_view_id = "+viewId+""
					+ " 	and current_record_flag is true"
					+ "		and reconciliation_rule_group_id = rgd.rule_group_id"
					+ "		and rgd.rule_id = rl.id "
					+ "		and recon.reconciliation_rule_id = rl.id"
					+ "		and recon.original_row_id = dv.scrIds ) grp"
					+ "		where grp.recon_status = '"+status+"' and grp.reconciliation_rule_id = "+ruleId+" group by Date(grp.`fileDate`), grp.reconciliation_rule_id";
			fetchCountAmntsStmt = conn.prepareStatement(countsAmntsQuery);
			countsAmountsRS = fetchCountAmntsStmt.executeQuery();
			
		    while(countsAmountsRS.next())
		    {
		    	String date = countsAmountsRS.getString(1).toString();
		    	Long count = Long.parseLong(countsAmountsRS.getString(2).toString());
		    	Double amount = Double.parseDouble(countsAmountsRS.getString(3).toString());
		    	BigDecimal bdAmount = new BigDecimal(amount);
		    	bdAmount = bdAmount.setScale(2, BigDecimal.ROUND_HALF_UP);
		    	
		    	String query = "select * from t_app_module_summary where file_date = '"+date+"' and module = 'Reconciliation' and rule_group_id = "+groupId+" and rule_id = "+ruleId+" and view_id = "+viewId+" and type = 'Source'";

		    	checkRecordStmt = conn.prepareStatement(query);
		    	checkRecordRS = checkRecordStmt.executeQuery();
		    	int size = 0;
		    	Long id = null;
		    	while(checkRecordRS.next())
		    	{
		    		id = Long.parseLong(checkRecordRS.getString("id"));
		    		size = size + 1;
		    	}
		    	if(size > 0)
		    	{
		    		if(size == 1)
		    		{
		    			  String updateQuery = "UPDATE t_app_module_summary SET type_count = "+count+", type_amt = "+bdAmount+", last_updated_date = '"+timeStamp+"', last_updated_by = "+userId+" where id = "+id;  
		    			  updateStament = conn.createStatement();
		    			  updateStament.executeUpdate(updateQuery);
		    			  appSummaryIds.remove(id);
		    		}
		    		else
		    		{
		    			  System.out.println("Duplicate records exist while updating count and amounts for view id: "+ viewId+", group id: "+ groupId+", rule id: "+ ruleId+", date: "+date);
		    		}
		    	}
		    	else
		    	{
		    		log.info("Amount::: "+ bdAmount);
		    		System.out.println("Need to insert record once data transmission has been completed for "+ groupId+", viewId: "+ viewId+", date: "+ date+", ruleId: "+ ruleId+", status: "+ status+", module: Reconciliation");
		    		String insertTableSQL = "INSERT INTO t_app_module_summary"
		    				+ "(file_date, module, rule_group_id, rule_id, view_id, type, type_count, created_date, last_updated_date, type_amt) VALUES"
		    				+ "(?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
				    		PreparedStatement preparedStatement = conn.prepareStatement(insertTableSQL);
				    		preparedStatement.setDate(1, java.sql.Date.valueOf(date));
				    		preparedStatement.setString(2, "Reconciliation");
				    		preparedStatement.setLong(3, groupId);
				    		if(ruleId != null)
				    		{
				    			preparedStatement.setLong(4, ruleId);	
				    		}
				    		else
				    		{
				    			preparedStatement.setNull(4, java.sql.Types.INTEGER);
				    		}
				    		preparedStatement.setLong(5, viewId);
				    		preparedStatement.setString(6, "Source");
				    		preparedStatement.setLong(7, count);
				    		preparedStatement.setTimestamp(8, new java.sql.Timestamp(System.currentTimeMillis()));
				    		preparedStatement.setTimestamp(9, new java.sql.Timestamp(System.currentTimeMillis()));
				    		preparedStatement.setBigDecimal(10, bdAmount);
				    		// execute insert SQL stetement
				    		preparedStatement .executeUpdate();
		    	}
		    }
		    
		    System.out.println("AppModuleSummaryIds After removing ids: "+appSummaryIds);
		    if(appSummaryIds.size()>0)
		    {
		    	for(Long id : appSummaryIds)
		    	{
		    		String updateQuery = "update t_app_module_summary set type_count = 0, type_amt = 0.0, last_updated_date = '"+timeStamp+"', last_updated_by = "+userId+" where id = "+id;
		    		updateExistedRecordStmt = conn.createStatement();
		    		updateExistedRecordStmt.executeUpdate(updateQuery);
		    	}
		    	System.out.println("Updated Remainig Records: "+appSummaryIds);
		    }
		}
		catch(Exception e)
		{
			System.out.println("Exception while updating count and amounts: "+e);
		}
		finally
		{
			try{

				// ResultSet
				if(countsAmountsRS != null)
					countsAmountsRS.close();
				if(checkRecordRS != null)
					checkRecordRS.close();
				if(appModSumIdsRS != null)
					appModSumIdsRS.close();
				// Statemnt
				if(fetchCountAmntsStmt != null)
					fetchCountAmntsStmt.close();
				if(checkRecordStmt != null)
					checkRecordStmt.close();
				if(updateStament != null)
					updateStament.close();
				if(appModSumIdsStmt != null)
					appModSumIdsStmt.close();
				if(updateExistedRecordStmt != null)
					updateExistedRecordStmt.close();
				// Connection
				if(conn != null)
					conn.close();
			}
			catch(Exception e)
			{
				System.out.println("Exception while closing statements");
			}
		}
		return finalMap;
	}
	
	
	
	
	 @Transactional
	   public HashMap getOriginalIdsByTransDateApprovals(Long viewId, String rangeFrom, String rangeTo, String periodFactor,List<BigInteger> srcIds,String amountQualifier) throws SQLException, ClassNotFoundException
	 {
		 List<BigInteger> viewOriginalIds = new ArrayList<BigInteger>();
		 Connection conn = null;
		 Statement stmt = null;
		 ResultSet result = null; 
		 HashMap finalMap=new HashMap();
		 String srcId=srcIds.toString().replaceAll("\\[", "").replaceAll("\\]", "").replaceAll("\\s", "");

		 try{
			 DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
			 conn = ds.getConnection();
			 stmt = conn.createStatement();
			 DataViews dv=dataViewsRepository.findOne(viewId.longValue());
			 if(dv!= null)
			 {
				 String viewName = dv.getDataViewName();
				 String query = "";
				 if("fileDate".equalsIgnoreCase(periodFactor))
				 {
					 query = "SELECT count(scrIds),SUM(`"+amountQualifier+"`) FROM `"+viewName.toLowerCase()+"` where scrIds in ("+srcId+") and Date(fileDate) between '"+rangeFrom+"' AND '"+rangeTo+"'";
				 }
				 else if("dateQualifier".equalsIgnoreCase(periodFactor))
				 {
					 String dateQualifier = getTransDateQualifier(new BigInteger(viewId.toString()), "TRANSDATE"); 
					 if(dateQualifier.length()>0)
					 {
						 query = "SELECT count(scrIds),SUM(`"+amountQualifier+"`) FROM `"+viewName.toLowerCase()+"` where scrIds in ("+srcId+") and Date(`"+dateQualifier+"`) between '"+rangeFrom+"' AND '"+rangeTo+"'";
					 }
				 }
				 result=stmt.executeQuery(query);
				 while(result.next()){
					 finalMap.put("count", result.getString(1));
					 finalMap.put("amount", result.getString(2));
				 }  
			 }
			 else
			 {
				 log.info("View doen't not exist for the view id: "+viewId);
			 }
		 }
		 catch(SQLException se){
			 log.info("Error while executing query: "+se);
		 }
		 catch(Exception e)
		 {
			 log.info("Exception while getting databse properties");
		 }
		 finally{
			 if(result != null)
				 result.close();	
			 if(stmt != null)
				 stmt.close();
			 if(conn != null)
				 conn.close();
		 }
		  log.info("Ids Size: "+viewOriginalIds.size());
		 return finalMap;
	 }
	
	 public HashMap fileExport(String newFileName,String newFileName2,String updRes,String name,String localPath,Long tenantId) throws IOException
	 {
		 HashMap pathMap=new HashMap();


		 XSSFWorkbook workBook = new XSSFWorkbook();
		 XSSFSheet sheet1 = workBook.createSheet("sheet1");
		
		 String currentLine=null;
		 int RowNum=0;
		 int RowNumSheet2=0;
		 String xlsxFileAddress = localPath+name.replaceAll("\\s","")+"_"+updRes+".xlsx";

		 BufferedReader br = new BufferedReader(new FileReader(newFileName));
		 while ((currentLine = br.readLine()) != null) {
			 String str[] = currentLine.split(",");
			 XSSFRow currentRow=sheet1.createRow(RowNum);
			 for(int i=0;i<str.length;i++){
				
				 currentRow.createCell(i).setCellValue(str[i]);

			 }
			 RowNum++;
		 }

		 if(newFileName2!=null)
		 {
			 XSSFSheet sheet2 = workBook.createSheet("sheet2");

			 BufferedReader br2 = new BufferedReader(new FileReader(newFileName2));
			 while ((currentLine = br2.readLine()) != null) {
				 String str[] = currentLine.split(",");
				 XSSFRow currentRow=sheet2.createRow(RowNumSheet2);
				 for(int i=0;i<str.length;i++){

					 currentRow.createCell(i).setCellValue(str[i]);

				 }
				 RowNumSheet2++;
			 }
		 }
		 FileOutputStream fileOutputStream =  new FileOutputStream(xlsxFileAddress);
		 workBook.write(fileOutputStream);
		 fileOutputStream.close();

		 File file = new File(xlsxFileAddress);
		 InputStream inputStream=new FileInputStream(file);

		 String[] destPath=fileService.fileUpload(inputStream, name.replaceAll("\\s","")+"_"+updRes+".xlsx");

		 if(destPath[0].equalsIgnoreCase("success"))
		 {
			 pathMap.put("status", destPath[0]);
			 log.info("destPath[1] :"+destPath[1]);
			 String finalFSPath="";
			 TenantConfig fileServerUrl=tenantConfigRepository.findByTenantIdAndKey(tenantId, "File Server Path");

			 if(fileServerUrl!=null)
				 finalFSPath=fileServerUrl.getValue()+destPath[1];
			 else
			 {
				 fileServerUrl=tenantConfigRepository.findByTenantIdAndKey(0l, "File Server Path");
				 finalFSPath=fileServerUrl.getValue()+destPath[1];
			 }

			 pathMap.put("destPath", finalFSPath);
		 }
		 else
		 {
			 pathMap.put("status", "failure");
		 }
		 return pathMap;


	 }

	 
/*	 public HashMap getSuggestionSummaryForRules(ReconCountNAmountsDTO params, List<BigInteger> ruleIds, Long groupId, Long sViewId, Long tViewId) throws ClassNotFoundException, SQLException, ParseException
	 {
		 Long tenantId = params.getTenantId();
		 HashMap finalMap = new HashMap();
		 log.info("Fetching Suggestion counts and amounts for the tenant id: "+ tenantId+", group id: "+ groupId+", source view id: "+sViewId+", target view id "+ tViewId);
		 List<HashMap> groupedList = new ArrayList<HashMap>();
		 List<BigInteger> sTotalIds = new ArrayList<BigInteger>();
		 List<BigInteger> tTotalIds = new ArrayList<BigInteger>();
		 List<BigInteger> sRecIds = new ArrayList<BigInteger>();
		 List<BigInteger> tRecIds = new ArrayList<BigInteger>();
		 DataViews sdv = dataViewsRepository.findOne(sViewId);
		 DataViews tdv = dataViewsRepository.findOne(tViewId);
		 String sCurrencyCode = getTransDateQualifier(BigInteger.valueOf(sViewId), "CURRENCYCODE");
		 String tCurrencyCode = getTransDateQualifier(BigInteger.valueOf(tViewId), "CURRENCYCODE");
		  
		 String sAmountQualifier = getTransDateQualifier(BigInteger.valueOf(sViewId), "AMOUNT");
		 String tAmountQualifier = getTransDateQualifier(BigInteger.valueOf(tViewId), "AMOUNT");
		  
		 Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
		 String currencyFormat = props.getProperty("currencyFormat");
		 if(sdv != null && tdv != null)
		 {
			 try{
				 HashMap sTotalIdsMap = getTotalByPeriodFactor(sViewId, params.getPeriodFactor(), params.getRangeFrom(), params.getRangeTo());
				 HashMap tTotalIdsMap = getTotalByPeriodFactor(tViewId, params.getPeriodFactor(), params.getRangeFrom(), params.getRangeTo());
				 if("Success".equalsIgnoreCase(sTotalIdsMap.get("status").toString()) && "Success".equalsIgnoreCase(tTotalIdsMap.get("status").toString()))
				 {
					 sTotalIds = (List<BigInteger>) sTotalIdsMap.get("totalIds");
					 tTotalIds = (List<BigInteger>) tTotalIdsMap.get("totalIds");
				 }
				 else
				 {
					 log.info("Error while fetching total ids for the source view : "+params.getsViewId()+", or target view: "+params.gettViewId());
				 } 
			 }
			 catch(Exception e)
			 {
				 log.info("Error while fetching total ids for the source view : "+params.getsViewId()+", or target view: "+params.gettViewId());
			 }
			 if(sTotalIds.size()>0 && tTotalIds.size()>0)
			 {
				 for(BigInteger ruleId : ruleIds)
				 {
					 HashMap recMap = new HashMap();
					 Rules rule = rulesRepository.findOne(ruleId.longValue());
					 if(rule != null)
					 {
						 recMap.put("id", ruleId);
						 recMap.put("name", rule.getRuleCode());
					 }

					  List<Long> ruleIdSingle = new ArrayList<Long>();
					  ruleIdSingle.add(ruleId.longValue());

					  sRecIds = reconciliationDuplicateResultRepository.fetchSuggestionIdsWithRulesForSource(tenantId, ruleIdSingle, groupId, sTotalIds, sViewId);
					  tRecIds = reconciliationDuplicateResultRepository.fetchSuggestionIdsWithRulesForTarget(tenantId, ruleIdSingle, groupId, tTotalIds, tViewId);

					  String sRecCurrencySymbol = "";
					  List<String> sRecCurrencies = getDistColumnValues(sRecIds,sCurrencyCode,sdv.getDataViewName());
					  if(sRecCurrencies.size()==1)
					  {
						  sRecCurrencySymbol = sRecCurrencySymbol+getCurrencySymbol(sRecCurrencies.get(0));
					  }
					  else if(sRecCurrencies.size()>1)
					  {
						  sRecCurrencySymbol = sRecCurrencySymbol+"*";
					  }
					  
					  String tRecCurrencySymbol = "";
					  List<String> tRecCurrencies = getDistColumnValues(tRecIds,tCurrencyCode,tdv.getDataViewName());
					  if(tRecCurrencies.size()==1)
					  {
						  tRecCurrencySymbol = tRecCurrencySymbol+getCurrencySymbol(tRecCurrencies.get(0));
					  }
					  else if(tRecCurrencies.size()>1)
					  {
						  tRecCurrencySymbol = tRecCurrencySymbol+"*";
					  }
				  		
					  HashMap sRecCountNAmount = reconciliationResultService.getCountNAmountForDVId(BigInteger.valueOf(sViewId), tenantId, sAmountQualifier,sRecIds);
					  recMap.put("sAmount", sRecCurrencySymbol+" "+reconciliationResultService.getAmountInFormat(sRecCountNAmount.get("totalAmount").toString(),currencyFormat));
					  recMap.put("sCount", sRecCountNAmount.get("totalCount"));
					  recMap.put("dsCount", sRecIds.size());
					  recMap.put("sCurrency", sRecCurrencySymbol);
					  recMap.put("sAmountValue", sRecCountNAmount.get("totalAmount"));
						
					  HashMap tRecCountNAmount = reconciliationResultService.getCountNAmountForDVId(BigInteger.valueOf(tViewId), tenantId, tAmountQualifier,tRecIds);
					  recMap.put("tAmount", tRecCurrencySymbol+" "+reconciliationResultService.getAmountInFormat(tRecCountNAmount.get("totalAmount").toString(),currencyFormat));
					  recMap.put("tCount", tRecCountNAmount.get("totalCount"));
					  recMap.put("dtCount", tRecIds.size());
					  recMap.put("tCurrency", tRecIds.size());
					  recMap.put("tAmountValue", tRecCountNAmount.get("totalAmount"));

					  groupedList.add(recMap);

				  	}
			  }
			  else
			  {
				  log.info("No records fournd for the source view id: "+params.getsViewId()+", or target view id: "+params.gettViewId());
			  }
		  }
		  else
		  {
			  log.info("Source view i: "+ params.getsViewId()+" or target view id: "+ params.gettViewId()+" doesn't exist");
		  }
		  finalMap.put("summary", groupedList);
		  finalMap.put("status", "");
		  return finalMap;
	 }*/

/*	  public HashMap getSuggestionSummaryForBatches(ReconCountNAmountsDTO params, List<String> batches, Long groupId, Long sViewId, Long tViewId) throws ClassNotFoundException, SQLException, ParseException
	  {	
		  Long tenantId = params.getTenantId();
		  HashMap finalMap = new HashMap();
		  log.info("Fetching Suggestion Data counts and amounts for the tenant id: "+ tenantId+", group id: "+ groupId+", source view id: "+sViewId+", target view id "+ tViewId);
		  List<HashMap> groupedList = new ArrayList<HashMap>();
		  List<BigInteger> sTotalIds = new ArrayList<BigInteger>();
		  List<BigInteger> tTotalIds = new ArrayList<BigInteger>();
		  List<BigInteger> sRecIds = new ArrayList<BigInteger>();
		  List<BigInteger> tRecIds = new ArrayList<BigInteger>();
		  DataViews sdv = dataViewsRepository.findOne(sViewId);
		  DataViews tdv = dataViewsRepository.findOne(tViewId);
		  String sCurrencyCode = getTransDateQualifier(BigInteger.valueOf(sViewId), "CURRENCYCODE");
		  String tCurrencyCode = getTransDateQualifier(BigInteger.valueOf(tViewId), "CURRENCYCODE");
		  
		  String sAmountQualifier = getTransDateQualifier(BigInteger.valueOf(sViewId), "AMOUNT");
		  String tAmountQualifier = getTransDateQualifier(BigInteger.valueOf(tViewId), "AMOUNT");
		  log.info("sCurrencyCode: "+sCurrencyCode+", tCurrencyCode: "+tCurrencyCode+", sAmountQualifier: "+sAmountQualifier+". "+tAmountQualifier);
		  Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
		  String currencyFormat = props.getProperty("currencyFormat");
		   
		  if(sdv != null && tdv != null)
		  {
			  try{
				  HashMap sTotalIdsMap = getTotalByPeriodFactor(sViewId, params.getPeriodFactor(), params.getRangeFrom(), params.getRangeTo());
				  HashMap tTotalIdsMap = getTotalByPeriodFactor(tViewId, params.getPeriodFactor(), params.getRangeFrom(), params.getRangeTo());
				  if("Success".equalsIgnoreCase(sTotalIdsMap.get("status").toString()) && "Success".equalsIgnoreCase(tTotalIdsMap.get("status").toString()))
				  {
					  sTotalIds = (List<BigInteger>) sTotalIdsMap.get("totalIds");
					  tTotalIds = (List<BigInteger>) tTotalIdsMap.get("totalIds");
				  }
				  else
				  {
					  log.info("Error while fetching total ids for the source view : "+sViewId+", or target view: "+tViewId);
				  } 
			  }
			  catch(Exception e)
			  {
				  log.info("Error while fetching total ids for the source view : "+sViewId+", or target view: "+tViewId);
			  }
			  log.info("sTotalIds.size(): "+sTotalIds.size()+", tTotalIds.size(): "+tTotalIds.size());
			  if(sTotalIds.size()>0 && tTotalIds.size()>0)
			  {
				  for(String batch : batches)
				  {
					  HashMap recMap = new HashMap();
					  recMap.put("name", batch);

					  sRecIds = reconciliationDuplicateResultRepository.fetchReconciledIdswithJobReferenceForSource(tenantId, groupId, sTotalIds, batch, sViewId);
					  tRecIds = reconciliationDuplicateResultRepository.fetchReconciledIdswithJobReferenceForTarget(tenantId, groupId, tTotalIds, batch, tViewId);
					  
					  log.info("Batch: "+batch+", sRecIds.size(): "+sRecIds.size()+", tRecIds: "+tRecIds.size());
					  
					  String sRecCurrencySymbol = "";
					  List<String> sRecCurrencies = getDistColumnValues(sRecIds,sCurrencyCode,sdv.getDataViewName());
					  if(sRecCurrencies.size()==1)
					  {
						  sRecCurrencySymbol = sRecCurrencySymbol+getCurrencySymbol(sRecCurrencies.get(0));
					  }
					  else if(sRecCurrencies.size()>1)
					  {
						  sRecCurrencySymbol = sRecCurrencySymbol+"*";
					  }
				  		
					  String tRecCurrencySymbol = "";
					  List<String> tRecCurrencies = getDistColumnValues(tRecIds,tCurrencyCode,tdv.getDataViewName());
					  if(tRecCurrencies.size()==1)
					  {
						  tRecCurrencySymbol = tRecCurrencySymbol+getCurrencySymbol(tRecCurrencies.get(0));
					  }
					  else if(tRecCurrencies.size()>1)
					  {
						  tRecCurrencySymbol = tRecCurrencySymbol+"*";
					  }

					  HashMap sRecCountNAmount = reconciliationResultService.getCountNAmountForDVId(BigInteger.valueOf(sViewId), tenantId, sAmountQualifier,sRecIds);
					  recMap.put("sAmount", sRecCurrencySymbol+" "+reconciliationResultService.getAmountInFormat(sRecCountNAmount.get("totalAmount").toString(),currencyFormat));
					  recMap.put("sCount", sRecCountNAmount.get("totalCount"));
					  recMap.put("dsCount", sRecIds.size());
					  recMap.put("sCurrency", sRecCurrencySymbol);
					  recMap.put("sAmountValue", sRecCountNAmount.get("totalAmount"));
						
					  HashMap tRecCountNAmount = reconciliationResultService.getCountNAmountForDVId(BigInteger.valueOf(tViewId), tenantId, tAmountQualifier,tRecIds);
					  recMap.put("tAmount", tRecCurrencySymbol+" "+reconciliationResultService.getAmountInFormat(tRecCountNAmount.get("totalAmount").toString(),currencyFormat));
					  recMap.put("tCount", tRecCountNAmount.get("totalCount"));
					  recMap.put("dtCount", tRecIds.size());
					  recMap.put("tCurrency", tRecCurrencySymbol);
					  recMap.put("tAmountValue", tRecCountNAmount.get("totalAmount"));
					  log.info("Batch: "+ batch+", map: "+recMap);
					  groupedList.add(recMap);
				  }
			  }
			  else
			  {
				  log.info("No records fournd for the source view id: "+params.getsViewId()+", or target view id: "+params.gettViewId());
			  }
		  }
		  else
		  {
			  log.info("Source view i: "+ params.getsViewId()+" or target view id: "+ params.gettViewId()+" doesn't exist");
		  }
		  finalMap.put("summary", groupedList);
		  finalMap.put("status", "");
		  log.info("Final Map Size: "+groupedList.size());
		  return finalMap;
	 }*/
	 
	    public String jsonToCSV(List<LinkedHashMap> finalList,String newFileName) throws IOException
	    { 	LinkedHashMap keysList=finalList.get(0);
	    List<String> keyList=new ArrayList<String>();
	    Set<String> keyset=keysList.keySet();
	    log.info("keyset :"+keyset.remove("Id"));

	    String commaSeparated = keyset.stream()
	    		.collect(Collectors.joining(","));


	    HashMap pathMap=new  HashMap();

	    //String newFileName = prog.getGeneratedPath()+rg.getName().replaceAll("\\s","")+"_"+updRes+".csv";


	    try (

	    		BufferedWriter writer = Files.newBufferedWriter(Paths.get(newFileName));

	    		CSVPrinter csvPrinter = new CSVPrinter(writer, CSVFormat.DEFAULT
	    				.withHeader(commaSeparated));
	    		) {

	    	for(int j=0;j<finalList.size();j++)
	    	{
	    		List<String> valuesList=new ArrayList<String>();
	    		for(String hea:keyset)
	    		{
	    			//log.info("hea: "+hea);
	    			if(finalList.get(j).containsKey(hea)){
	    				//log.info("values.get(j).get(hea): "+values.get(j).get(hea));
	    				if(finalList.get(j).get(hea)!=null)
	    					valuesList.add(finalList.get(j).get(hea).toString());
	    				else
	    					valuesList.add("");
	    			}
	    			else{
	    				valuesList.add("");
	    			}
	    		}

	    		commaSeparated=valuesList.stream()
	    				.collect(Collectors.joining(","));

	    		csvPrinter.printRecord(commaSeparated);
	    	}
	    	csvPrinter.flush();    
	    }
		
	    return newFileName;
	    }
	    
	    public List<LinkedHashMap> getSuggestedDataGroupById(Long viewId, String sourceOrTarget, String amountQualifier, Long groupId, Long tenantId, String sortBy,
	    		Long pageIndx, Long pageSize, String groupByValues, String columnsAsString, HashMap headerColumns,
	    		String columnSearchQuery, String statusNReconRefQuery)
	    {
	    	String reconColString = columnsAsString.replaceAll("dv.", "recon.");
	    	List<LinkedHashMap> finalList = new ArrayList<LinkedHashMap>();
    		Connection conn = null;
    		Statement stmt = null;
    		Statement stmt2 = null;
    		ResultSet result = null;
    		ResultSet result2 = null;
    		LinkedHashMap info = new LinkedHashMap();
	    	LinkedHashMap recMain = new LinkedHashMap();
	    	info.put("amountQualifier", amountQualifier);
	    	try{
	    		String withLimit =  "";
	    		String withoutLimit = "";
	    		String query = "";
		    	DataViews dv = dataViewsRepository.findById(viewId.longValue());
		    	String id = "";
		    	if(dv != null)
		    	{
		    		if("source".equalsIgnoreCase(sourceOrTarget))
		    		{
		    			id = "original_row_id";
		    			query = "select recon.original_row_id, recon.recon_reference, recon.reconciliation_rule_group_id, recon.count, recon.amount_sum, v_recon.variance_amount "+reconColString
		    					+ " from (select original_row_id, GROUP_CONCAT(DISTINCT recon_reference"
		    					+ " ORDER BY recon_reference DESC SEPARATOR ',') as recon_reference, reconciliation_rule_group_id, count(*) count,  avg(dv.`"+amountQualifier+"`) amount_sum"
		    					+ " "+columnsAsString
		    					+ "	from t_reconciliation_suggestion_result recon,"
		    					+ "	`"+dv.getDataViewName().toLowerCase()+"` dv"
		    					+ "	where reconciliation_rule_group_id = "+groupId+" "
		    					+ " and original_view_id = "+viewId+""
		    					+ "	and current_record_flag is true"
		    					+ "	and recon.original_row_id = dv.scrIds"
		    					+ "	and recon_status = 'RECONCILED'"
		    					+ " and tenant_id = "+tenantId+""
		    					+ " and sign(original_row_id) = 1"
				    			+ columnSearchQuery
				    			+ statusNReconRefQuery
		    					+ "	and "+groupByValues+""	// Need to Write Code
		    					+ "	group by original_row_id, reconciliation_rule_group_id ) recon"
		    					+ " left outer join (select original_row_id, GROUP_CONCAT(DISTINCT recon_reference"
		    					+ " ORDER BY recon_reference DESC SEPARATOR ',') as recon_reference, reconciliation_rule_group_id, count(*) count, avg(dv.`"+amountQualifier+"`) variance_amount"
		    					+ "	from t_reconciliation_suggestion_result recon,"
		    					+ "	`"+dv.getDataViewName().toLowerCase()+"` dv"
		    					+ "	where reconciliation_rule_group_id = "+groupId+" "
		    					+ " and original_view_id = "+viewId+""
		    					+ "	and current_record_flag is true"
		    					+ "	and recon.original_row_id = dv.scrIds"
		    					+ "	and recon_status = 'RECONCILED'"
		    					+ " and tenant_id = "+tenantId+""
		    					+ " and sign(original_row_id) = -1"
				    			+ columnSearchQuery
				    			+ statusNReconRefQuery
		    					+ "	and "+groupByValues+""	// Need to Write Code
		    					+ "	group by original_row_id, reconciliation_rule_group_id"
		    					+ " ) v_recon on recon.recon_reference = v_recon.recon_reference order by original_row_id "+sortBy+"";
		    		}
		    		else if("target".equalsIgnoreCase(sourceOrTarget))
		    		{
		    			id = "target_row_id";
		    			query = " select recon.target_row_id,recon.recon_reference,recon.reconciliation_rule_group_id,recon.count,recon.amount_sum,v_recon.variance_amount "+reconColString
		    					+ " from (select target_row_id,GROUP_CONCAT(DISTINCT recon_reference"
		    					+ " ORDER BY recon_reference DESC SEPARATOR ',') as recon_reference, reconciliation_rule_group_id, count(*) count,  avg(dv.`"+amountQualifier+"`) amount_sum"
		    					+ " "+columnsAsString
		    					+ "	from t_reconciliation_suggestion_result recon,"
		    					+ "	`"+dv.getDataViewName().toLowerCase()+"` dv"
		    					+ "	where reconciliation_rule_group_id = "+groupId+" "
		    					+ " and target_view_id = "+viewId+""
		    					+ "	and current_record_flag is true"
		    					+ "	and recon.target_row_id = dv.scrIds"
		    					+ "	and recon_status = 'RECONCILED'"
		    					+ " and tenant_id = "+tenantId+""
		    					+ " and sign(target_row_id) = 1"
				    			+ columnSearchQuery
				    			+ statusNReconRefQuery
		    					+ "	and "+groupByValues+""	// Need to Write Code
		    					+ "	group by target_row_id, reconciliation_rule_group_id"
		    					+ " ) recon left outer join (select target_row_id, GROUP_CONCAT(DISTINCT recon_reference"
		    					+ " ORDER BY recon_reference DESC SEPARATOR ',') as recon_reference, reconciliation_rule_group_id, count(*) count, avg(dv.`"+amountQualifier+"`) variance_amount"
		    					+ "	from t_reconciliation_suggestion_result recon,"
		    					+ "	`"+dv.getDataViewName().toLowerCase()+"` dv"
		    					+ "	where reconciliation_rule_group_id = "+groupId+" "
		    					+ " and target_view_id = "+viewId+""
		    					+ "	and current_record_flag is true"
		    					+ "	and recon.target_row_id = dv.scrIds"
		    					+ "	and recon_status = 'RECONCILED'"
		    					+ " and tenant_id = "+tenantId+""
		    					+ " and sign(target_row_id) = -1"
				    			+ columnSearchQuery
				    			+ statusNReconRefQuery
		    					+ "	and "+groupByValues+""	// Need to Write Code
		    					+ "	group by target_row_id, reconciliation_rule_group_id"
		    					+ " ) v_recon on recon.recon_reference = v_recon.recon_reference order by target_row_id "+sortBy+"";
		    		}
			    	
			    	withLimit = query +" limit "+pageIndx+", "+pageSize+"";
			    	withoutLimit = query;
			    	log.info(sourceOrTarget.toUpperCase()+" query to fetching original row id grouping info: "+withLimit);
					DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
					conn = ds.getConnection();
		     	    stmt = conn.createStatement();
		     	    result=stmt.executeQuery(withLimit);
		     	    
			    	stmt2 = conn.createStatement();
			    	result2 = stmt2.executeQuery(withoutLimit);
			    	int totalCount = 0;
			    	while(result2.next())
			    	{
			    		totalCount = totalCount+1;
			    	}
			    	info.put("totalCount", totalCount);
			        while(result.next()){
			        	LinkedHashMap reconRecord = new LinkedHashMap();
			        	Iterator it = headerColumns.entrySet().iterator();
			        	while(it.hasNext())	// header columns
 	 	    	    	{
 	 	    	    		Map.Entry pair = (Map.Entry)it.next();
 	 	    	    		reconRecord.put(pair.getValue().toString(), result.getString(pair.getKey().toString()));	    		
 	 	    	    	}
			        	reconRecord.put("Id", result.getString(id));
			        	reconRecord.put("reconReference", result.getString("recon_reference"));
			        	reconRecord.put("count", result.getString("count"));
			        	reconRecord.put("amount", result.getString("amount_sum"));
			        	reconRecord.put("varianceAmount", result.getString("variance_amount"));
			        	finalList.add(reconRecord);			        	
			       	}
		    	}
	    	}
	    	catch(Exception e)
	    	{
	    		log.info("Exception while fetching recon grouping by recon reference info: "+e);
	    	}
	    	finally
	    	{
	    		try{
					if(result != null)
						result.close();
					if(result2 != null)
						result2.close();
					if(stmt != null)
						stmt.close();
					if(stmt2 != null)
						stmt2.close();
					if(conn != null)
						conn.close();	    			
	    		}
	    		catch(Exception e)
	    		{
	    			log.info("Exception while closing jdbc statements.(Grouping ReconRefId Info)"+e);
	    		}
	    	}
	    	log.info("Service for fetching reconciled transaction with group by recon reference id end....");
	    	recMain.put("info", info);
	    	finalList.add(recMain);
	    	return finalList;
	    }
	    
	    public List<BigInteger> getRowIdsForChildData(String srcOrTrgt, Long viewId, Long groupId, Long tenantId, String reconReference)
	    {
	    	List<BigInteger> rowIds  = new ArrayList<BigInteger>();
    		Connection conn = null;
    		Statement stmt = null;
    		ResultSet result = null;
    		try
    		{
    			DataViews dv = dataViewsRepository.findById(viewId);
    			String query  = "";
    			if("source".equalsIgnoreCase(srcOrTrgt))
    			{
    				query = "select distinct original_row_id from t_reconciliation_result rs,"
    						+ "	`"+dv.getDataViewName().toLowerCase()+"` dv where recon_reference in('"+reconReference+"') and "
    						+ " original_view_id = "+viewId+" and target_view_id is null and  "
    						+ " upper(IFNULL(adjustmentType,'X'))!='VARIANCE' and rs.original_row_id = dv.scrIds  "
    						+ "  and tenant_id = "+tenantId+" and reconciliation_rule_group_id = "+groupId;
    			}
    			else
    			{
    				query = "select distinct target_row_id from "
    						+ " t_reconciliation_result rs,	"
    						+ " `"+dv.getDataViewName().toLowerCase()+"` dv where "
    						+ " recon_reference in('"+reconReference+"') and target_view_id = "+viewId+" and original_view_id is null "
    						+ " and upper(IFNULL(adjustmentType,'X'))!='VARIANCE' "
    						+ " and tenant_id = "+tenantId+" and reconciliation_rule_group_id = "+groupId+""
    						+ " and rs.target_row_id = dv.scrIds";
    			}
				DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
				conn = ds.getConnection();
	     	    stmt = conn.createStatement();
	     	    result=stmt.executeQuery(query);
	     	    while(result.next())
	     	    {
	     	    	if(result.getString(1) != null)
	     	    	{
	     	    		rowIds.add(new BigInteger(result.getString(1).toString()));
	     	    	}
	     	    }
    		}
    		catch(Exception e)
    		{
    			log.info("Exception while fetching row ids for child data in reconciliation"+e);
    		}
    		finally
    		{
	    		try{
					if(result != null)
						result.close();
					if(stmt != null)
						stmt.close();
					if(conn != null)
						conn.close();	    			
	    		}
	    		catch(Exception e)
	    		{
	    			log.info("Exception while closing jdbc statements.(Fetching child row ids)"+e);
	    		}
    		}
	    	return rowIds;
	    }
	    
	    public List<LinkedHashMap> getGroupByReconRefDetailInfo(Long tenantId, Long groupId, Long viewId,String groupByValues,
	    		Long pageIndx, Long pageSize, String rangeFrom, String rangeTo, String periodFactor, String amountQualifier, 
	    		String sourceOrTarget, String typeOfReconData, String sortBy, String columnSearchQuery, String statusNReconRefQuery,
	    		String groupByField, String dvOrRecon) throws SQLException, ClassNotFoundException
	    {
	    	log.info("Service for fetching reconciled transaction with group by recon reference id start....");
	    	List<LinkedHashMap> finalList = new ArrayList<LinkedHashMap>();
	    	LinkedHashMap info = new LinkedHashMap();
	    	LinkedHashMap recMain = new LinkedHashMap();
	    	info.put("amountQualifier", amountQualifier);
    		Connection conn = null;
    		Statement stmt = null;
    		Statement stmt2 = null;
    		ResultSet result = null;
    		ResultSet result2 = null;
    		String reconResultTable = "";
    		if("suggestion".equalsIgnoreCase(typeOfReconData))
    		{
    			reconResultTable = "t_reconciliation_suggestion_result";
    		}
    		else 
    		{
    			reconResultTable = "t_reconciliation_result";    			
    		}
	    	try{
	    		HashMap apprStatusLookups = new HashMap();
    			List<LookUpCode> lcs = lookUpCodeRepository.findByTenantIdAndLookUpType(tenantId, "APPROVAL_STATUS");
    			for(LookUpCode lc : lcs)
    			{
    				apprStatusLookups.put(lc.getLookUpCode(), lc.getMeaning());
    			}
				DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
				conn = ds.getConnection();
	    		String withLimit =  "";
	    		String withoutLimit = "";
		    	DataViews dv = dataViewsRepository.findById(viewId.longValue());
	    		String groupingField = "";
	    		String innerGroupingField = "";
	    		String ruleCodeQuery = " recon.rule_code ";
	    		String ruleCodeColumn = "reconciliation_rule_id";
	    		if("final_action_date".equalsIgnoreCase(groupByField))
	    		{
	    			groupingField = ", Date(recon.final_action_date)";
	    			innerGroupingField = ", "+groupByField;
	    		}
	    		else if("reconciliation_rule_id".equalsIgnoreCase(groupByField))
	    		{
	    			groupingField = "";	
	    			innerGroupingField = "";
	    			ruleCodeQuery = " (case when recon.rule_code is null then 'Manual' else recon.rule_code end) rule_code ";
	    		}
	    		else if("approval_rule_id".equalsIgnoreCase(groupByField)){
	    			groupingField = ", recon."+groupByField+"";
	    			if("dv".equalsIgnoreCase(dvOrRecon))
	    			{
	    				innerGroupingField = ", dv."+groupByField+"";
	    			}
	    			else
	    			{
	    				innerGroupingField = ", "+groupByField;
	    			}
	    			ruleCodeColumn = "approval_rule_id";
	    		} 
	    		else 
	    		{
	    			if("recon_job_reference".equalsIgnoreCase(groupByField))
		    		{
		    			groupingField = ", (CASE WHEN Substring(recon.recon_job_reference, 1, 7) = 'MANUAL_' 	THEN 'Manual' ELSE recon.recon_job_reference end ) recon_job_reference";
		    		}
	    			else
	    			{
		    			groupingField = ", recon."+groupByField+"";	    				
	    			}
	    			if("dv".equalsIgnoreCase(dvOrRecon))
	    			{
	    				innerGroupingField = ", dv."+groupByField+"";
	    			}
	    			else
	    			{
	    				innerGroupingField = ", "+groupByField;
	    			}
	    		}
		    	if(dv != null)
		    	{
		    		String query = "";
		    		if("source".equalsIgnoreCase(sourceOrTarget))
		    		{
				    	query = "select recon.recon_reference,recon.reconciliation_rule_id,recon.count,recon.amount_sum,v_recon.variance_amount, "+ruleCodeQuery+" "+groupingField+" from "
				    			+ " (select recon_reference, reconciliation_rule_id, rl.rule_code "+innerGroupingField+", count(*) count,  sum(dv.`"+amountQualifier+"`)  amount_sum"
				    			+ " from "+reconResultTable+" recon"
				    			+ " LEFT JOIN t_rules rl ON recon."+ruleCodeColumn+" = rl.id,"
				    			+ " `"+dv.getDataViewName().toLowerCase()+"` dv " 
				    			+ "	where reconciliation_rule_group_id = "+ groupId +" "
				    			+ " and Date(dv.`"+periodFactor+"`) between '"+rangeFrom+"' and '"+rangeTo+"'"
				    			+ "	and original_view_id = "+viewId+""
				    			+ "	and current_record_flag is true"
				    			+ "	and recon.original_row_id = dv.scrIds"
				    			+ "	and recon_status = 'RECONCILED'"
				    			+ " and recon.tenant_id = "+tenantId+""
				    			+ " and upper(IFNULL(adjustmentType,'X'))!='VARIANCE' "
				    			+ " "+groupByValues+" "
				    			+ 	columnSearchQuery
				    			+ 	statusNReconRefQuery
				    			+ "	group by recon_reference, reconciliation_rule_id "+innerGroupingField+""
				    			+ " ) recon"
				    			+ " left outer join (select recon_reference, reconciliation_rule_id "+innerGroupingField+", count(*) count,  sum(dv.`"+amountQualifier+"`) variance_amount"
				    			+ "	from "+reconResultTable+" recon,"
				    			+ "	`"+dv.getDataViewName().toLowerCase()+"` dv"
				    			+ "	where reconciliation_rule_group_id = "+groupId+" "
				    			+ " and Date(dv.`"+periodFactor+"`) between '"+rangeFrom+"' and '"+rangeTo+"'"
				    			+ "	and original_view_id = "+viewId+""
				    			+ "	and current_record_flag is true"
				    			+ "	and recon.original_row_id = dv.scrIds"
				    			+ "	and recon_status = 'RECONCILED'"
				    			+ " and tenant_id = "+tenantId+""
				    			+ " and sign(original_row_id) = -1"
				    			+ " and upper(IFNULL(adjustmentType,'X'))='VARIANCE' "
				    			+ "	"+groupByValues+" "
				    			+ columnSearchQuery
				    			+ statusNReconRefQuery
				    			+ "	group by recon_reference, reconciliation_rule_id "+innerGroupingField+""
				    			+ " ) v_recon on recon.recon_reference = v_recon.recon_reference order by recon.recon_reference "+sortBy+" ";
		    		}
		    		else if("target".equalsIgnoreCase(sourceOrTarget))
		    		{
				    	query = "select recon.recon_reference,recon.reconciliation_rule_id,recon.count,recon.amount_sum,v_recon.variance_amount, "+ruleCodeQuery+" "+groupingField+""
				    			+ " from "
				    			+ " (select recon_reference, reconciliation_rule_id, rl.rule_code "+innerGroupingField+", count(*) count,  sum(dv.`"+amountQualifier+"`) amount_sum"
				    			+ "	from "+reconResultTable+" recon"
				    			+ " LEFT JOIN t_rules rl ON recon."+ruleCodeColumn+" = rl.id,"
				    			+ " `"+dv.getDataViewName().toLowerCase()+"` dv " 
				    			+ "	where reconciliation_rule_group_id = "+groupId+" "
				    			+ " and Date(dv.`"+periodFactor+"`) between '"+rangeFrom+"' and '"+rangeTo+"'"
				    			+ "	and target_view_id = "+viewId+""
				    			+ "	and current_record_flag is true"
				    			+ "	and recon.target_row_id = dv.scrIds"
				    			+ "	and recon_status = 'RECONCILED'"
				    			+ " and recon.tenant_id = "+tenantId+""
				    			+ " and upper(IFNULL(adjustmentType,'X'))!='VARIANCE' "
				    			+ " "+groupByValues+" "
				    			+ columnSearchQuery
				    			+ statusNReconRefQuery
				    			+ "	group by recon_reference, reconciliation_rule_id "+innerGroupingField+""
				    			+ " ) recon"
				    			+ " left outer join (select recon_reference, reconciliation_rule_id, count(*) count,  sum(dv.`"+amountQualifier+"`) variance_amount"
				    			+ "	from "+reconResultTable+" recon,"
				    			+ "	`"+dv.getDataViewName().toLowerCase()+"` dv"
				    			+ "	where reconciliation_rule_group_id = "+groupId+" "
				    			+ " and Date(dv.`"+periodFactor+"`) between '"+rangeFrom+"' and '"+rangeTo+"'"
				    			+ "	and target_view_id = "+viewId+""
				    			+ "	and current_record_flag is true"
				    			+ "	and recon.target_row_id = dv.scrIds"
				    			+ "	and recon_status = 'RECONCILED'"
				    			+ " and tenant_id = "+tenantId+""
				    			+ " and sign(target_row_id) = -1"
				    			+ " and upper(IFNULL(adjustmentType,'X'))='VARIANCE' "
				    			+ " "+groupByValues+" "
				    			+ columnSearchQuery
				    			+ statusNReconRefQuery
				    			+ "	group by recon_reference, reconciliation_rule_id "+innerGroupingField+""
				    			+ " ) v_recon on recon.recon_reference = v_recon.recon_reference order by recon.recon_reference "+sortBy+" ";
		    		}
			    	
			    	withLimit = query +" limit "+pageIndx+", "+pageSize+"";
			    	withoutLimit = query;
			    	log.info(sourceOrTarget.toUpperCase()+" query to fetching recon ref id grouping info: "+withLimit);
		     	    stmt = conn.createStatement();
		     	    result=stmt.executeQuery(withLimit);
		     	    
			    	stmt2 = conn.createStatement();
			    	result2 = stmt2.executeQuery(withoutLimit);
			    	int totalCount = 0;
			    	while(result2.next())
			    	{
			    		totalCount = totalCount+1;
			    	}
			    	info.put("totalCount", totalCount);
			    	if("source".equalsIgnoreCase(sourceOrTarget))
			    	{
			    		HashMap headerColumns = reconciliationResultService.getColHeadersMapInSequence(viewId, groupId, tenantId,"source");
			        	while(result.next()){
			        		LinkedHashMap reconRecord = new LinkedHashMap();
			        		// Need to add data
			        		reconRecord.put("reconReference", result.getString(1).toString());
			        		reconRecord.put("ruleId", result.getString(2));
			        		reconRecord.put("count", result.getString(3));
			        		reconRecord.put("amount", result.getString(4));
			        		reconRecord.put("varianceAmount", result.getString(5));
			        		reconRecord.put("ruleCode", result.getString(6));
			        		if("reconciliation_rule_id".equalsIgnoreCase(groupByField) || "approval_rule_id".equalsIgnoreCase(groupByField))
			        		{
			        			reconRecord.put("groupByColumn", result.getString(6));
			        		}
			        		else if("final_status".equalsIgnoreCase(groupByField))
			        		{
			        			if(result.getString(7) !=null)
			        			{
				        			reconRecord.put("groupByColumn", apprStatusLookups.get(result.getString(7)));
			        			}
			        			else
			        			{
				        			reconRecord.put("groupByColumn", "");			        				
			        			}			        			
			        		}
			        		else
			        		{
			        			if(result.getString(7) !=null)
			        			{
				        			reconRecord.put("groupByColumn", result.getString(7));
			        			}
			        			else
			        			{
				        			reconRecord.put("groupByColumn", "");			        				
			        			}
			        		}
			        		finalList.add(reconRecord);
			        	}
			    	}
			    	else if("target".equalsIgnoreCase(sourceOrTarget))
			    	{
			    		HashMap headerColumns = reconciliationResultService.getColHeadersMapInSequence(viewId, groupId, tenantId,"target");
			        	while(result.next()){
			        		LinkedHashMap reconRecord = new LinkedHashMap();
			        		// Need to add data
			        		reconRecord.put("reconReference", result.getString(1).toString());
			        		reconRecord.put("ruleId", result.getString(2));
			        		reconRecord.put("count", result.getString(3));
			        		reconRecord.put("amount", result.getString(4));
			        		reconRecord.put("varianceAmount", result.getString(5));
			        		reconRecord.put("ruleCode", result.getString(6));
			        		if("reconciliation_rule_id".equalsIgnoreCase(groupByField) || "approval_rule_id".equalsIgnoreCase(groupByField))
			        		{
			        			reconRecord.put("groupByColumn", result.getString(6));
			        		}
			        		else if("final_status".equalsIgnoreCase(groupByField))
			        		{
			        			if(result.getString(7) !=null)
			        			{
				        			reconRecord.put("groupByColumn", apprStatusLookups.get(result.getString(7)));
			        			}
			        			else
			        			{
				        			reconRecord.put("groupByColumn", "");			        				
			        			}			        			
			        		}
			        		else
			        		{
			        			if(result.getString(7) !=null)
			        			{
				        			reconRecord.put("groupByColumn", result.getString(7));
			        			}
			        			else
			        			{
				        			reconRecord.put("groupByColumn", "");			        				
			        			}
			        		}		        
			        		finalList.add(reconRecord);
			        	}
			    	}
		    	}
		    	else
		    	{
		    		log.info("View Doesn't exist for the view id: "+viewId);
		    	}
		    }
	    	catch(Exception e)
	    	{
	    		log.info("Exception while fetching recon grouping by recon reference info: "+e);
	    	}
	    	finally
	    	{
	    		try{
					if(result != null)
						result.close();
					if(result2 != null)
						result2.close();
					if(stmt != null)
						stmt.close();
					if(stmt2 != null)
						stmt2.close();
					if(conn != null)
						conn.close();	    			
	    		}
	    		catch(Exception e)
	    		{
	    			log.info("Exception while closing jdbc statements.(Grouping ReconRefId Info)"+e);
	    		}
	    	}
	    	log.info("Service for fetching reconciled transaction with group by recon reference id end....");
	    	recMain.put("info", info);
	    	finalList.add(recMain);
	    	return finalList;
	    }
	    
	    public List<LinkedHashMap> getManualReconData(Long viewId, String sourceOrTarget, String amountQualifier, Long groupId, String periodFactor,
	    		String rangeFrom, String rangeTo, Long tenantId, HashMap headerColumns, String typeOfReconData)
	    {
	    	List<LinkedHashMap> finalMap = new ArrayList<LinkedHashMap>();
    		Connection conn = null;
    		Statement stmt = null;
    		ResultSet result = null;
	    	try{
		    	DataViews dv = dataViewsRepository.findById(viewId);
		    	if(dv != null)
		    	{
		    		String query = "";
		    		if("source".equals(sourceOrTarget))
		    		{
		    			query = " select recon.recon_reference, recon.reconciliation_rule_id, recon.count, recon.amount_sum, v_recon.variance_amount from"
		    					+ " (select recon_reference, reconciliation_rule_id, count(*) count,  sum(dv.`"+amountQualifier+"`) amount_sum	"
		    					+ " from t_reconciliation_result recon,"
		    					+ " `"+dv.getDataViewName().toLowerCase()+"` dv"
		    					+ " where reconciliation_rule_group_id = "+groupId+"  and Date(dv.`"+periodFactor+"`) between '"+rangeFrom+"' and '"+rangeTo+"' and original_view_id = "+viewId+"	"
		    					+ " and current_record_flag is true and recon.original_row_id = dv.scrIds	"
		    					+ " and recon_status = 'RECONCILED' and recon.tenant_id = "+tenantId+" and upper(IFNULL(adjustmentType,'X'))!='VARIANCE' "
		    					+ " and reconciliation_rule_id in (0) group by recon_reference, reconciliation_rule_id) recon  "
		    					+ " left outer join "
		    					+ " (select recon_reference, reconciliation_rule_id, count(*) count, sum(dv.`"+amountQualifier+"`) variance_amount"
		    					+ " from t_reconciliation_result recon,"
		    					+ " `"+dv.getDataViewName().toLowerCase()+"` dv "
		    					+ " where reconciliation_rule_group_id = "+groupId+"  and Date(dv.`"+periodFactor+"`) between '"+rangeFrom+"' and '"+rangeTo+"'"
		    					+ " and original_view_id = "+viewId+"	and current_record_flag is true	and recon.original_row_id = dv.scrIds	"
		    					+ " and recon_status = 'RECONCILED' and tenant_id = "+tenantId+" and sign(original_row_id) = -1"
		    					+ " and upper(IFNULL(adjustmentType,'X'))='VARIANCE' "
		    					+ " and reconciliation_rule_id in (0) group by recon_reference, reconciliation_rule_id) v_recon "
		    					+ " on recon.recon_reference = v_recon.recon_reference order by recon. recon_reference desc";

		    		}
		    		else if("target".equals(sourceOrTarget))
		    		{
		    			query = " select recon.recon_reference, recon.reconciliation_rule_id, recon.count, recon.amount_sum, v_recon.variance_amount from"
		    					+ " (select recon_reference, reconciliation_rule_id, count(*) count,  sum(dv.`"+amountQualifier+"`) amount_sum	"
		    					+ " from t_reconciliation_result recon,"
		    					+ " `"+dv.getDataViewName().toLowerCase()+"` dv"
		    					+ " where reconciliation_rule_group_id = "+groupId+"  and Date(dv.`"+periodFactor+"`) between '"+rangeFrom+"' and '"+rangeTo+"' and target_view_id = "+viewId+"	"
		    					+ " and current_record_flag is true and recon.target_row_id = dv.scrIds	"
		    					+ " and recon_status = 'RECONCILED' and recon.tenant_id = "+tenantId+" and upper(IFNULL(adjustmentType,'X'))!='VARIANCE' "
		    					+ " and reconciliation_rule_id in (0) group by recon_reference, reconciliation_rule_id) recon  "
		    					+ " left outer join "
		    					+ " (select recon_reference, reconciliation_rule_id, count(*) count, sum(dv.`"+amountQualifier+"`) variance_amount"
		    					+ " from t_reconciliation_result recon,"
		    					+ " `"+dv.getDataViewName().toLowerCase()+"` dv "
		    					+ " where reconciliation_rule_group_id = "+groupId+"  and Date(dv.`"+periodFactor+"`) between '"+rangeFrom+"' and '"+rangeTo+"'"
		    					+ " and target_view_id = "+viewId+"	and current_record_flag is true	and recon.target_row_id = dv.scrIds	"
		    					+ " and recon_status = 'RECONCILED' and tenant_id = "+tenantId+" and sign(target_row_id) = -1"
		    					+ " and upper(IFNULL(adjustmentType,'X'))='VARIANCE' "
		    					+ " and reconciliation_rule_id in (0) group by recon_reference, reconciliation_rule_id) v_recon "
		    					+ " on recon.recon_reference = v_recon.recon_reference order by recon. recon_reference desc";
		    		}
		    		
		    		log.info(sourceOrTarget + " Fetching Manual Recon Data Query: "+query);
					DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
					conn = ds.getConnection();
		     	    stmt = conn.createStatement();
		     	    result=stmt.executeQuery(query);		     	    
		        	while(result.next()){
		        		LinkedHashMap reconRecord = new LinkedHashMap();
		        		// Need to add data
		        		reconRecord.put("reconReference", result.getString(1).toString());
		        		reconRecord.put("ruleId", result.getString(2));
		        		reconRecord.put("count", result.getString(3));
		        		reconRecord.put("amount", result.getString(4));
		        		reconRecord.put("varianceAmount", result.getString(5));
		        		reconRecord.put("ruleCode", "Manual");
		        		reconRecord.put("groupByColumn", "Manual");
		        		//log.info("ReconReference: "+recRefs);
		        		if("source".equalsIgnoreCase(sourceOrTarget))
		        		{
			        		List<BigInteger> scrIds = new ArrayList<BigInteger>();
			        		scrIds = getRowIdsForChildData("source", viewId, groupId, tenantId, result.getString(1).toString());
			        		List<LinkedHashMap> childData = fetchDataByViewIdInSequence(viewId, scrIds, null, null, headerColumns, sourceOrTarget, tenantId, groupId, "", "Yes", "", "", "", typeOfReconData);
			        		reconRecord.put("children", childData);
			        		//log.info("Source Children Data: "+ childData.size());
		        		}
		        		else if("target".equalsIgnoreCase(sourceOrTarget))
		        		{
			        		List<BigInteger> scrIds = new ArrayList<BigInteger>();
			        		scrIds = getRowIdsForChildData("target", viewId, groupId, tenantId, result.getString(1).toString());
			        		List<LinkedHashMap> childData = fetchDataByViewIdInSequence(viewId, scrIds, null, null, headerColumns, sourceOrTarget, tenantId, groupId, "", "Yes", "", "", "", typeOfReconData);
			        		reconRecord.put("children", childData);
			        		//log.info("Target Children Data: "+ childData.size());
		        		}
		        		finalMap.add(reconRecord);
		        	}
		    	}
	    	}
	    	catch(Exception e)
	    	{
	    		log.info("Exception while fetching manual reconciliation data : "+e);
	    	}
	    	finally
	    	{
	    		try{
					if(result != null)
						result.close();
					if(stmt != null)
						stmt.close();
					if(conn != null)
						conn.close();	    			
	    		}
	    		catch(Exception e)
	    		{
	    			log.info("Exception while closing jdbc statements.(Fetching Manual Data: )"+e);
	    		}	
	    	}	    	
	    	return finalMap;
	    }
	    
	    public String getStringWithNumbers(List<Long> values)
	    {
	    	String finalString = "";
	    	for(int i=0; i<values.size(); i++)
	    	{
	    		if(i == values.size()-1)
	    		{
	    			finalString = finalString + values.get(i);
	    		}
	    		else
	    		{
	    			finalString = finalString + values.get(i)+", ";
	    		}
	    	}
	    	return finalString;
	    }
	    public String getStringWithStrings(List<String> values)
	    {
	    	String finalString = "";
	    	for(int i=0; i<values.size(); i++)
	    	{
	    		if(i == values.size()-1)
	    		{
	    			finalString = finalString + "'"+values.get(i)+"'";
	    		}
	    		else
	    		{
	    			finalString = finalString+ "'" +values.get(i)+"', ";	    			
	    		}	    		
	    	}
	    	return finalString;
	    }
	    
	    public String getReconRefsAsString(List<String> values)
	    {
	    	String finalString = "";
			for(int i=0; i<values.size(); i++)	// looing column values
			{
				if(i == values.size()-1)
				{
					finalString = finalString +  " LIKE '%"+values.get(i)+"%' ";
				}
				else
				{
					finalString = finalString + " LIKE '%"+values.get(i) +"%', ";
				}
			}
	    	return finalString;
	    }
	    
	    public List<BigInteger> getScrIdsByReconReference(String sourceOrTarget, Long viewId, String recRefsAsString, Long tenantId, Long groupId, String typeOfReconData, String varianceType)
	    {
	    	List<BigInteger> scrIds = new ArrayList<BigInteger>();
    		String varianceCondition = "";
    		Connection conn = null;
    		Statement stmt = null;
    		ResultSet result = null;
    		String reconResultTable = "";
    		
    		String srcVarType = "";
    		String trgVarType = "";
    		
    		if("variance".equalsIgnoreCase(varianceType))
    		{
    			srcVarType = " sign(original_row_id) = -1";
    			trgVarType = " sign(target_row_id) = -1";
    			varianceCondition = " dv.adjustmentType = 'VARIANCE' ";
    		}
    		else
    		{
    			srcVarType = " upper(IFNULL(adjustmentType,'X'))!='VARIANCE' ";
    			trgVarType = " upper(IFNULL(adjustmentType,'X'))!='VARIANCE' "; 	
    			varianceCondition = " 1=1 "; 
    		}
    		
    		if("suggestion".equalsIgnoreCase(typeOfReconData))
    		{
    			reconResultTable = "t_reconciliation_suggestion_result";
    		}
    		else 
    		{
    			reconResultTable = "t_reconciliation_result";    			
    		}    	
    		try
    		{
    	    	String query = "";
    	    	DataViews dv = dataViewsRepository.findById(viewId);
    	    	if(dv != null)
    	    	{
    		    	if("source".equalsIgnoreCase(sourceOrTarget))
    		    	{
    		    		query = "select original_row_id from "+reconResultTable+" rs,"
    		    				+ "	`"+dv.getDataViewName().toLowerCase()+"` dv"
    		    				+ " where recon_reference in("+recRefsAsString+") and original_view_id = "+viewId+" and target_view_id is null and "+srcVarType+""
    		    				+ "	and "+varianceCondition
    		    				+ " and tenant_id = "+tenantId+""
    		    				+ " and rs.original_row_id = dv.scrIds "
    		    				+ " and reconciliation_rule_group_id = "+groupId+""
    		    				+ " group by original_row_id";	    	
    		    	}
    		    	else if("target".equalsIgnoreCase(sourceOrTarget))
    		    	{
    		    		query = "select target_row_id from "+reconResultTable+" rs,"
    		    				+ "	`"+dv.getDataViewName().toLowerCase()+"` dv"
    		    				+ " where recon_reference in("+recRefsAsString+") and target_view_id = "+viewId+" and original_view_id is null and "+trgVarType+""
    		    				+ "	and "+varianceCondition
    		    				+ " and tenant_id = "+tenantId+""
    		    				+ " and rs.target_row_id = dv.scrIds "
    		    				+ " and reconciliation_rule_group_id = "+groupId+""
    		    				+ " group by target_row_id";
    		    	}
    		    	log.info("Query to fetch variance/non-variance ids based on recon reference: "+query);
    				DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
    				conn = ds.getConnection();
    	     	    stmt = conn.createStatement();
    	     	    result=stmt.executeQuery(query);
    	     	    
    	     	   while(result.next()){
    	     		   scrIds.add(new BigInteger(result.getString(1).toString()));
    	     	   }
    	    	}
    		}
    		catch(Exception e)
    		{
    			log.info("Exception while fetching row ids: "+e);
    		}
    		finally
    		{
	    		try{
					if(result != null)
						result.close();
					if(stmt != null)
						stmt.close();
					if(conn != null)
						conn.close();	    			
	    		}
	    		catch(Exception e)
	    		{
	    			log.info("Exception while closing jdbc statements.(Grouping ReconRefId Info)"+e);
	    		}
	    	}
	    	return scrIds;
	    }
	    
	    
	    public HashMap getReconSummaryByRuleGroup(Long tenantId) throws SQLException, ClassNotFoundException
	    {
     	    HashMap grpsMap = new HashMap();

    		Connection conn = null;
    		Statement stmt = null;
    		ResultSet result = null;
    		try
    		{
    			String query = "SELECT DISTINCT det.rule_group_id, det.name,  det.s_view_name, det.t_view_name, det.source_view_id, "
    					+ " det.target_view_id, det.source_view_display_id,det.target_view_display_id,recon_src.src_recon_amount, recon_tr.tr_recon_amount,det.rgd_for_display "
    					+ " FROM "
    					+ " (SELECT rg.id rule_group_id, rg.name, ru.source_data_view_id  source_view_id, ru.target_data_view_id  target_view_id, "
    					+ " sdv.data_view_disp_name s_view_name, tdv.data_view_disp_name t_view_name, "
    					+ " sdv.id_for_display source_view_display_id,tdv.id_for_display target_view_display_id,rg.id_for_display rgd_for_display "
    					+ " FROM t_rule_group rg, t_rule_group_details rgd, t_rules ru, t_data_views sdv, t_data_views tdv "
    					+ " WHERE rg.id = rgd.rule_group_id "
    					+ " AND rgd.rule_id = ru.id AND ru.tenant_id = "+tenantId+" AND ru.source_data_view_id = sdv.id AND ru.target_data_view_id = tdv.id "
    					+ " AND rg.rule_purpose = 'RECONCILIATION') det "
    					+ " LEFT JOIN (SELECT reconciliation_rule_group_id, original_view_id, Sum(original_amount) AS src_recon_amount "
    					+ " FROM t_reconciliation_result WHERE original_view_id IS NOT NULL AND current_record_flag IS TRUE "
    					+ " AND tenant_id = "+tenantId+" AND recon_status = 'RECONCILED' "
    					+ " GROUP  BY reconciliation_rule_group_id, original_view_id) recon_src "
    					+ " ON det.rule_group_id = recon_src.reconciliation_rule_group_id AND recon_src.original_view_id = det.source_view_id "
    					+ " LEFT JOIN (SELECT reconciliation_rule_group_id, "
    					+ " target_view_id, Sum(target_amount) AS tr_recon_amount FROM t_reconciliation_result "
    					+ " WHERE target_view_id IS NOT NULL AND current_record_flag IS TRUE AND tenant_id = "+tenantId+" "
    					+ " AND recon_status = 'RECONCILED' GROUP  BY reconciliation_rule_group_id, target_view_id) recon_tr "
    					+ " ON det.rule_group_id = recon_tr.reconciliation_rule_group_id  AND recon_tr.target_view_id = det.target_view_id order by det.name asc";
    			
    			log.info("Query to fetch summary info for all rule groups: "+ query);
    			
    			DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
    			conn = ds.getConnection();
    			
	     	    stmt = conn.createStatement();
	     	    result=stmt.executeQuery(query);
		     	while(result.next()){
		     		String grpId = result.getString(1).toString();
		     		String grpName = result.getString(2).toString();
		     		if(grpsMap.containsKey(grpId))
		     		{
		     			HashMap grpInfo = (HashMap) grpsMap.get(grpId);
		     			List<HashMap> summary = (List<HashMap>) grpInfo.get("summary");
		     			HashMap recInfo = new HashMap();
		     			recInfo.put("sViewId", result.getString(7).toString());
		     			recInfo.put("tViewId", result.getString(8).toString());
		     			recInfo.put("sViewName", result.getString(3).toString());
		     			recInfo.put("tViewName", result.getString(4).toString());
/*		     			recInfo.put("sDisplayId", result.getString(7).toString());
		     			recInfo.put("tDisplayId", result.getString(8).toString());*/
		     			/*recInfo.put("rgForDisplay",result.getString(11).toString());*/
		     			if(result.getString(9) != null && result.getString(10) != null)
		     			{
		     				recInfo.put("sRecAmount", Double.parseDouble(result.getString(9).toString()));
		     				recInfo.put("tRecAmount", Double.parseDouble(result.getString(10).toString()));
		     			}
		     			else
		     			{
		     				recInfo.put("sRecAmount", 0.0);
		     				recInfo.put("tRecAmount", 0.0);		     				
		     			}
		     			summary.add(recInfo);
		     		}
		     		else
		     		{
		     			HashMap groupMap = new HashMap();
		     			groupMap.put("groupId", result.getString(11).toString());
		     			groupMap.put("groupName", grpName);
		     			List<HashMap> summary = new ArrayList<HashMap>();
		     			HashMap rec = new HashMap();
		     			rec.put("sViewId", result.getString(7).toString());
		     			rec.put("tViewId", result.getString(8).toString());
		     			rec.put("sViewName", result.getString(3).toString());
		     			rec.put("tViewName", result.getString(4).toString());
		     			/*rec.put("sDisplayId", result.getString(7).toString());
		     			rec.put("tDisplayId", result.getString(8).toString());
		     			rec.put("rgForDisplay",result.getString(11).toString());*/
		     			if(result.getString(9) != null && result.getString(10) != null)
		     			{
		     				rec.put("sRecAmount", Double.parseDouble(result.getString(9).toString()));
		     				rec.put("tRecAmount", Double.parseDouble(result.getString(10).toString()));
		     			}
		     			else
		     			{
		     				rec.put("sRecAmount", 0.0);
		     				rec.put("tRecAmount", 0.0);		     				
		     			}
		     			summary.add(rec);
		     			groupMap.put("summary", summary);
		     			grpsMap.put(grpId, groupMap);
		     		}
		     	}
    		}
    		catch(Exception e)
    		{
    			log.info("Exception while fetching summary info for all groups. "+e);
    		}
    		finally
    		{
	    		try{
					if(result != null)
						result.close();
					if(stmt != null)
						stmt.close();
					if(conn != null)
						conn.close();	    			
	    		}
	    		catch(Exception e)
	    		{
	    			log.info("Exception while closing jdbc statements.(Grouping ReconRefId Info)"+e);
	    		}
    		}
	    	return grpsMap;
	    }

	    
	    // Outbound API's
	    public HashMap getReconSrcTrgtRulesInfo(String ruleGroupName, String sViewName, String tViewName, String rulesCondition)
	    {
	    	HashMap finalMap = new HashMap();
    		Connection conn = null;
    		Statement stmt = null;
    		ResultSet result = null;    		
    		try
    		{
    			String query = "select distinct rg.id rule_group_id, rg.name rule_group_name, ru.id rule_id, ru.rule_code,"
    					+ " ru.source_data_view_id, ru.target_data_view_id, s_dv.data_view_name source_data_view, t_dv.data_view_name target_data_view"
    					+ " from t_rule_group_details rgd, t_rule_group rg, "
    					+ " t_rules ru, t_data_views s_dv, t_data_views t_dv"
    					+ " where rg.id = rgd.rule_group_id"
    					+ " and rgd.rule_id = ru.id"
    					+ " and rg.rule_purpose = 'Reconciliation'"
    					+ " and ru.source_data_view_id = s_dv.id"
    					+ " and ru.target_data_view_id = t_dv.id"
    					+ " and rg.name = '"+ruleGroupName+"' "
    					+ " and s_dv.data_view_name = '"+sViewName+"' "
    					+ " and t_dv.data_view_name = '"+tViewName+"' "+rulesCondition;
    			log.info("Query for fetching recon view ids, rule ids: "+query);
				DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
				conn = ds.getConnection();
	     	    stmt = conn.createStatement();
	     	    result=stmt.executeQuery(query);
	     	    List<Long> ruleIds = new ArrayList<Long>();
		     	while(result.next()){
		     		ruleIds.add(Long.parseLong(result.getString("rule_id").toString()));
		     		finalMap.put("groupId", Long.parseLong(result.getString("rule_group_id").toString()));
		     		finalMap.put("sViewId", Long.parseLong(result.getString("source_data_view_id").toString()));
		     		finalMap.put("tViewId", Long.parseLong(result.getString("target_data_view_id").toString()));
		     		finalMap.put("sViewName", result.getString("source_data_view").toString());
		     		finalMap.put("tViewName", result.getString("target_data_view").toString());
		     	}
		     	finalMap.put("ruleIds", ruleIds);
    		}
    		catch(Exception e)
    		{
    			log.info("Exception while getting recon view ids, rule ids: "+e);
    		}
    		finally
    		{
	    		try{
					if(result != null)
						result.close();
					if(stmt != null)
						stmt.close();
					if(conn != null)
						conn.close();	    			
	    		}
	    		catch(Exception e)
	    		{
	    			log.info("Exception while closing jdbc statements.(Fetching recon source, target, rule ids)"+e);
	    		}    			
    		}
	    	return finalMap;
	    }
	    
	    public List<LinkedHashMap> getReconciledTransactionData(String sViewName, String tViewName, Long groupId, Long sViewId, Long tViewId, String rulesCondition,
	    		String paginationCondition, String srcQuery, String trgtQuery)
	    {
	    	List<LinkedHashMap> finalList = new ArrayList<LinkedHashMap>();
    		Connection conn = null;
    		Statement stmt = null;
    		ResultSet result = null;
    		try
    		{
				DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
				conn = ds.getConnection();
				
				String query = "select src.*, target.* from (select recon.recon_reference src_rec_ref, sdv.* from t_reconciliation_result recon, `"+sViewName.toLowerCase()+"` sdv"
						+ " where recon.reconciliation_rule_group_id = "+groupId+""
						+ " and reconciliation_rule_id in ("+rulesCondition+")"
						+ " and original_view_id = "+sViewId+""
						+ " and recon_status = 'RECONCILED'"
						+ " and current_record_flag is true"
						+ " "+srcQuery
						+ " and recon.original_row_id = sdv.scrids"
						+ " ) src,"
						+ " (select recon.recon_reference target_rec_ref, tdv.* from t_reconciliation_result recon, `"+tViewName.toLowerCase()+"` tdv"
						+ " where recon.reconciliation_rule_group_id = "+groupId+""
						+ " and reconciliation_rule_id in ("+rulesCondition+")"
						+ " and target_view_id = "+tViewId+""
						+ " and recon_status = 'RECONCILED'"
						+ " and current_record_flag is true"
						+ " "+trgtQuery
						+ " and recon.target_row_id = tdv.scrids"
						+ " ) target"
						+ " where src.src_rec_ref = target.target_rec_ref "+paginationCondition+"";
				log.info("Query to fetching reconciled transactions data (Outbound data. Reconciled) "+query);
	     	    stmt = conn.createStatement();
	     	    result=stmt.executeQuery(query);
				ResultSetMetaData rsmd = result.getMetaData();
     	    	int colCount = rsmd.getColumnCount();
     	    	log.info("Column Count: "+ colCount);	
				while(result.next()){
					LinkedHashMap mp = new LinkedHashMap();
					for(int i=1; i<=colCount; i++)
     	    		{
						mp.put(rsmd.getColumnName(i).toString(), result.getString(i));
     	    		}
					finalList.add(mp);
				}
    		}
    		catch(Exception e)
    		{
    			log.info("Exception while fetching reconciled transactional data. "+e);
    		}
    		finally
    		{
	    		try{
					if(result != null)
						result.close();
					if(stmt != null)
						stmt.close();
					if(conn != null)
						conn.close();	    			
	    		}
	    		catch(Exception e)
	    		{
	    			log.info("Exception while closing jdbc statements.(Fetching recon source, target, rule ids) "+e);
	    		}    			
    		}
    		return finalList;
	    }
	    
	    public HashMap getReconInputsInfo(String sourceOrTarget, String groupName, String viewName)
	    {
	    	HashMap finalMap = new HashMap();
    		Connection conn = null;
    		Statement stmt = null;
    		ResultSet result = null;
    		try
    		{
				DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
				conn = ds.getConnection();
				String query = "";
				if("source".equalsIgnoreCase(sourceOrTarget))
				{
					query = "select distinct rg.id rule_group_id, rg.name rule_group_name, ru.id rule_id, ru.rule_code,"
							+ " ru.source_data_view_id view_id, s_dv.data_view_name view_name"
							+ " from t_rule_group_details rgd, t_rule_group rg, t_rules ru, t_data_views s_dv"
							+ " where rg.id = rgd.rule_group_id"
							+ " and rgd.rule_id = ru.id"
							+ " and rg.rule_purpose = 'Reconciliation'"
							+ " and ru.source_data_view_id = s_dv.id"
							+ " and rg.name = '"+groupName+"' "
							+ " and s_dv.data_view_name = '"+viewName+"'";
				}
				else
				{
					query = "select distinct rg.id rule_group_id, rg.name rule_group_name, ru.id rule_id, ru.rule_code,"
							+ " ru.target_data_view_id view_id, t_dv.data_view_name view_name"
							+ " from t_rule_group_details rgd, t_rule_group rg, t_rules ru, t_data_views t_dv"
							+ " where rg.id = rgd.rule_group_id"
							+ " and rgd.rule_id = ru.id"
							+ " and rg.rule_purpose = 'Reconciliation'"
							+ " and ru.target_data_view_id = t_dv.id"
							+ " and rg.name = '"+groupName+"' "
							+ " and t_dv.data_view_name = '"+viewName+"'";
					
				}
				log.info("Query to fetch recon inputs: "+query);
				
	     	    stmt = conn.createStatement();
	     	    result=stmt.executeQuery(query);
	     	    while(result.next()){
	     	    	finalMap.put("groupId", result.getString("rule_group_id"));
	     	    	finalMap.put("groupName", result.getString("rule_group_name"));
	     	    	finalMap.put("viewName", result.getString("view_name"));
	     	    	finalMap.put("viewId", result.getString("view_id"));
	     	    }
    		}
    		catch(Exception e)
    		{
    			log.info("Exception while fetching recon inputs info. "+e);
    		}
    		finally
    		{
	    		try{
					if(result != null)
						result.close();
					if(stmt != null)
						stmt.close();
					if(conn != null)
						conn.close();	    			
	    		}
	    		catch(Exception e)
	    		{
	    			log.info("Exception while closing jdbc statements.(Fetching recon inputs info.) "+e);
	    		}    			
    		}
	    	return finalMap;
	    }
	    
	    public List<LinkedHashMap> getUnReconciledTransactions(String sourceOrTarget, Long groupId, Long viewId, String viewName,
	    		String paginationCondition, String filterQuery)
	    {
	    	List<LinkedHashMap> finalList = new ArrayList<LinkedHashMap>();
    		Connection conn = null;
    		Statement stmt = null;
    		ResultSet result = null;
    		try
    		{
				DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
				conn = ds.getConnection();
				String query = "";
				if("source".equalsIgnoreCase(sourceOrTarget))
				{
					query = "select det.* from (select dv.*,"
							+ " (case when rs.recon_status is null"
							+ " then 'Not Reconciled'"
							+ " else 'Reconciled' end) as status"
							+ " from "
							+ " (select * from `"+viewName.toLowerCase()+"` "+filterQuery+") dv"
							+ " left outer join"
							+ " (select * from t_reconciliation_result where reconciliation_rule_group_id = "+groupId+" and original_view_id = "+viewId+""
							+ " and recon_status = 'RECONCILED' and current_record_flag is true) rs"
							+ " on dv.scrIds = rs.original_row_id) det where status = 'Not Reconciled' "+paginationCondition;
				}
				else if("target".equalsIgnoreCase(sourceOrTarget))
				{
					query = "select det.* from (select dv.*,"
							+ " (case when rs.recon_status is null"
							+ " then 'Not Reconciled'"
							+ " else 'Reconciled' end) as status from "
							+ " (select * from `"+viewName.toLowerCase()+"` "+filterQuery+") dv"
							+ " left outer join"
							+ " (select * from t_reconciliation_result where reconciliation_rule_group_id = "+groupId+" and target_view_id = "+viewId+""
							+ " and recon_status = 'RECONCILED' and current_record_flag is true) rs"
							+ " on dv.scrIds = rs.target_row_id) det where status = 'Not Reconciled' "+paginationCondition;
				}
				log.info("Query to fetch un reconciled transactions data: "+query);
	     	    stmt = conn.createStatement();
	     	    result=stmt.executeQuery(query);
	     	    
				ResultSetMetaData rsmd = result.getMetaData();
     	    	int colCount = rsmd.getColumnCount();
     	    	log.info("Column Count: "+ colCount);	
				
     	    	while(result.next()){
					LinkedHashMap mp = new LinkedHashMap();
					for(int i=1; i<=colCount; i++)
     	    		{
						mp.put(rsmd.getColumnName(i).toString(), result.getString(i));
     	    		}
					finalList.add(mp);
				}
    		}
    		catch(Exception e)
    		{
    			log.info("Exception while fetching un reconciled transactions "+e);
    		}
    		finally
    		{
	    		try{
					if(result != null)
						result.close();
					if(stmt != null)
						stmt.close();
					if(conn != null)
						conn.close();	    			
	    		}
	    		catch(Exception e)
	    		{
	    			log.info("Exception while closing jdbc statements.(Fetching un reconciled transactions.) "+e);
	    		}    			
    		}
    		return finalList;
	    }
	    
	    public List<String> getColumnsAsList(HashMap headerColumns)
	    {
	    	List<String> columns = new ArrayList<String>();
	    	Iterator it = headerColumns.entrySet().iterator();
    		while (it.hasNext())
    		{
    			Map.Entry pair = (Map.Entry)it.next();
    			columns.add(pair.getKey().toString());
    		}
	    	return columns;
	    }
	    
	    public HashMap getReconGroupingSummaryInfo(String groupBy, String sColumnName, String tColumnName, Long groupId,
	    		String periodFactor, String rangeFrom, String rangeTo, Long tenantId, Long sViewId, Long tViewId, String reconTable) throws ClassNotFoundException, java.text.ParseException
	    {
	    	HashMap finalMap = new HashMap();
	    	log.info("In Service of fetching reconciled grouping summary info");
	    	List<HashMap> finalList = new ArrayList<HashMap>();
	    	String sGroupingColumn = "";
	    	String tGroupingColumn = "";
	    	String ruleCodeQuery = "";
	    	String ruleCodeQueryInside = "";
	    	String ruleCodeQueryInside2 = "";
	    	
	    	if("rules".equalsIgnoreCase(groupBy))
	    	{
	    		sGroupingColumn = "reconciliation_rule_id";
	    		tGroupingColumn = "reconciliation_rule_id";
	    		ruleCodeQuery = "(case when source.rule_code is null then 'Manual' else source.rule_code end) as rule_code, ";
	    		ruleCodeQueryInside = "recon.rule_code,";
	    		ruleCodeQueryInside2 = "rl.rule_code";
	    	}
	    	else if("batch".equalsIgnoreCase(groupBy))
	    	{
	    		sGroupingColumn = "recon_job_reference";
	    		tGroupingColumn = "recon_job_reference";
	    	}
	    	else if("columnName".equalsIgnoreCase(groupBy))
	    	{
	    		sGroupingColumn = sColumnName;
	    		tGroupingColumn = tColumnName;
	    	}
	    	String sPeriodFactor = "";
	    	String tPeriodFactor = "";
	    	
	    	if("fileDate".equalsIgnoreCase(periodFactor))
	    	{
	    		sPeriodFactor = "fileDate";
	    		tPeriodFactor = "fileDate";
	    	}
	    	else if("dateQualifier".equalsIgnoreCase(periodFactor))
	    	{
	    		sPeriodFactor = getTransDateQualifier(BigInteger.valueOf(sViewId), "TRANSDATE");
	    		tPeriodFactor = getTransDateQualifier(BigInteger.valueOf(tViewId), "TRANSDATE");
	    	}
	    	
    		String sAmountCol = getTransDateQualifier(BigInteger.valueOf(sViewId), "AMOUNT");
    		String tAmountCol = getTransDateQualifier(BigInteger.valueOf(tViewId), "AMOUNT");
	    	
			Connection conn = null;
			Statement stmt = null;
			ResultSet result = null;
			
			Double totalSrcAmount = 0.0;
			Long totalSrcCount = 0L;
			
			Double totalTrAmount = 0.0;
			Long totalTrCount = 0L;		
			HashMap info = new HashMap();
			
			try
			{
				DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
				conn = ds.getConnection();
				stmt = conn.createStatement();
				
				DataViews sdv = dataViewsRepository.findOne(sViewId.longValue());
				DataViews tdv = dataViewsRepository.findOne(tViewId.longValue());
				
				String sJobReferenceGroupBySelect = "";
				String tJobReferenceGroupBySelect = "";	
				
				String sJobReferenceGroupBy = "";
				String tJobReferenceGroupBy = "";
				
				String fieldsQuery = "";
				if("batch".equalsIgnoreCase(groupBy))
				{
					fieldsQuery = " select CASE WHEN Substring(source.recon_job_reference, 1, 7) = 'MANUAL_' THEN 'Manual' ELSE source.recon_job_reference "
						+ " end name,"+ruleCodeQuery+" source.count src_count, target.count tr_count, source.total_amt src_amount, target.total_amt tr_amount, "
						+ " source.variance_amount src_var_amount, target.variance_amount tr_var_amount from ";
					
					sJobReferenceGroupBySelect = " (CASE "
							+ "	WHEN Substring(recon_job_reference, 1, 7) = 'MANUAL_' THEN 'Manual' "
							+ " ELSE recon_job_reference end) recon_job_reference ";
					
					tJobReferenceGroupBySelect = " (CASE "
							+ "	WHEN Substring(recon_job_reference, 1, 7) = 'MANUAL_' THEN 'Manual' "
							+ " ELSE recon_job_reference end) recon_job_reference ";
					
					sJobReferenceGroupBy = " (CASE "
							+ "	WHEN Substring(recon_job_reference, 1, 7) = 'MANUAL_' THEN 'Manual' "
							+ " ELSE recon_job_reference end) ";
					
					tJobReferenceGroupBy = " (CASE "
							+ "	WHEN Substring(recon_job_reference, 1, 7) = 'MANUAL_' THEN 'Manual' "
							+ " ELSE recon_job_reference end) ";
					
				}
				else
				{
					fieldsQuery = "select source."+sGroupingColumn+" name,"+ruleCodeQuery+" source.count src_count, target.count tr_count, source.total_amt src_amount, target.total_amt tr_amount, "
						+ " source.variance_amount src_var_amount, target.variance_amount tr_var_amount from ";
					
					if("rules".equalsIgnoreCase(groupBy))
					{						
						sJobReferenceGroupBySelect = sGroupingColumn+","+ruleCodeQueryInside2;
						tJobReferenceGroupBySelect = tGroupingColumn;
						sJobReferenceGroupBy = sGroupingColumn;
						tJobReferenceGroupBy = tGroupingColumn;
					}
					else
					{
						sJobReferenceGroupBySelect = sGroupingColumn;
						tJobReferenceGroupBySelect = tGroupingColumn;
						sJobReferenceGroupBy = sGroupingColumn;
						tJobReferenceGroupBy = tGroupingColumn;
					}
				}
				String query = "";
				
				if("approvalStatus".equalsIgnoreCase(groupBy) || "approvalDate".equalsIgnoreCase(groupBy) || "approvalRule".equalsIgnoreCase(groupBy))
				{
					String approvalNullCondition = "";
					String ruleCodeSource = "";
					String ruleCodeRecon = "";
					String ruleCodeRl = "";
			    	if("approvalStatus".equalsIgnoreCase(groupBy))
			    	{
			    		sGroupingColumn = "final_status";
			    		tGroupingColumn = "final_status";
			    	}
			    	else if("approvalDate".equalsIgnoreCase(groupBy))
			    	{
			    		sGroupingColumn = "Date(final_action_date)";
			    		tGroupingColumn = "Date(final_action_date)";
			    		approvalNullCondition = " and recon.approval_rule_id is not null";
			    	}
			    	else if("approvalRule".equalsIgnoreCase(groupBy))
			    	{
			    		sGroupingColumn = "approval_rule_id";
			    		tGroupingColumn = "approval_rule_id";
			    		approvalNullCondition = " and recon.approval_rule_id is not null";
			    		ruleCodeSource = " source.rule_code, ";
			    		ruleCodeRecon = " recon.rule_code, ";
			    		ruleCodeRl = " rl.rule_code, ";
			    	}

			    	if("approvalDate".equalsIgnoreCase(groupBy))
			    	{
				    	query = " select"
				    			+ " source.final_action_date name,"
				    			+ ruleCodeSource
				    			+ " source.count src_count,"
				    			+ " target.count tr_count,"
				    			+ " source.total_amt src_amount, "
				    			+ " target.total_amt tr_amount, "
				    			+ " source.variance_amount src_var_amount, "
				    			+ " target.variance_amount tr_var_amount "
				    			+ " from "
				    			+ " ("
				    			+ " select "
				    			+ " Date(recon.final_action_date) final_action_date, "
				    			+ ruleCodeRecon
				    			+ " recon.count, "
				    			+ " recon.amount_sum, "
				    			+ " v_recon.variance_amount, "
				    			+ " recon.amount_sum + IFNULL(v_recon.variance_amount, 0) total_amt "
				    			+ " from "
				    			+ " ("
				    			+ " select "
				    			+ " Date(recon.final_action_date) final_action_date, "
				    			+ ruleCodeRl
				    			+ " count(*) count, "
				    			+ " sum(dv.`"+sAmountCol+"`) amount_sum "
				    			+ " from "
				    			+ " "+reconTable+" recon "
				    			+ " LEFT JOIN t_rules rl ON recon.approval_rule_id = rl.id, "
				    			+ " `"+sdv.getDataViewName().toLowerCase()+"` dv "
				    			+ " where "
				    			+ " reconciliation_rule_group_id = "+groupId+" "
				    			+ " and Date(dv.`"+periodFactor+"`) between '"+rangeFrom+"' "
				    			+ " and '"+rangeTo+"' "
				    			+ " and original_view_id = "+sViewId+" "
				    			+ " and current_record_flag is true "
				    			+ " and recon.original_row_id = dv.scrIds "
				    			+ " and recon_status = 'RECONCILED' "
				    			+ " and recon.final_action_date is not null "
				    			+ " and recon.tenant_id = "+tenantId+" "
				    			+ approvalNullCondition
				    			+ " and upper("
				    			+ " IFNULL(adjustmentType, 'X')"
				    			+ " )!= 'VARIANCE' "
				    			+ " group by "
				    			+ " Date(final_action_date)"
				    			+ " ) recon "
				    			+ " left outer join ("
				    			+ " select "
				    			+ " Date(recon.final_action_date) final_action_date, "
				    			+ " count(*) count, "
				    			+ " sum(dv.`"+sAmountCol+"`) variance_amount "
				    			+ " from "
				    			+ " "+reconTable+" recon, "
				    			+ " `"+sdv.getDataViewName().toLowerCase()+"` dv "
				    			+ " where "
				    			+ " reconciliation_rule_group_id = "+groupId+" "
				    			+ " and Date(dv.`"+periodFactor+"`) between '"+rangeFrom+"' "
				    			+ " and '"+rangeTo+"' "
				    			+ " and original_view_id = "+sViewId+" "
				    			+ " and current_record_flag is true "
				    			+ " and recon.original_row_id = dv.scrIds "
				    			+ " and recon_status = 'RECONCILED' "
				    			+ " and recon.final_action_date is not null "
				    			+ " and tenant_id = "+tenantId+" "
				    			+ approvalNullCondition
				    			+ " and sign(original_row_id) = -1 "
				    			+ " and upper("
				    			+ " IFNULL(adjustmentType, 'X')"
				    			+ " )= 'VARIANCE' "
				    			+ " group by "
				    			+ " Date(final_action_date)"
				    			+ " ) v_recon on Date(recon.final_action_date) = Date(v_recon.final_action_date)"
				    			+ " ) source "
				    			+ " left outer join ("
				    			+ " select "
				    			+ " Date(recon.final_action_date) final_action_date, "
				    			+ " recon.count, "
				    			+ " recon.amount_sum, "
				    			+ " v_recon.variance_amount, "
				    			+ " recon.amount_sum + IFNULL(v_recon.variance_amount, 0) total_amt "
				    			+ " from "
				    			+ " ("
				    			+ " select "
				    			+ " Date(recon.final_action_date) final_action_date, "
				    			+ " count(*) count, "
				    			+ " sum(dv.`"+tAmountCol+"`) amount_sum "
				    			+ " from "
				    			+ " "+reconTable+" recon "
				    			+ " LEFT JOIN t_rules rl ON recon.approval_rule_id = rl.id, "
				    			+ " `"+tdv.getDataViewName().toLowerCase()+"` dv "
				    			+ " where "
				    			+ " reconciliation_rule_group_id = "+groupId+" "
				    			+ " and Date(dv.`"+periodFactor+"`) between '"+rangeFrom+"' "
				    			+ " and '"+rangeTo+"' "
				    			+ " and target_view_id = "+tViewId+" "
				    			+ " and current_record_flag is true "
				    			+ " and recon.target_row_id = dv.scrIds "
				    			+ " and recon_status = 'RECONCILED' "
				    			+ " and recon.tenant_id = "+tenantId+" "
				    			+ " and recon.final_action_date is not null "
				    			+ approvalNullCondition
				    			+ " and upper("
				    			+ " IFNULL(adjustmentType, 'X')"
				    			+ " )!= 'VARIANCE' "
				    			+ " group by "
				    			+ " Date(final_action_date)"
				    			+ " ) recon "
				    			+ " left outer join ("
				    			+ " select "
				    			+ " Date(recon.final_action_date) final_action_date, "
				    			+ " count(*) count, "
				    			+ " sum(dv.`"+tAmountCol+"`) variance_amount "
				    			+ " from "
				    			+ " "+reconTable+" recon, "
				    			+ " `"+tdv.getDataViewName().toLowerCase()+"` dv "
				    			+ " where "
				    			+ " reconciliation_rule_group_id = "+groupId+" "
				    			+ " and Date(dv.`"+periodFactor+"`) between '"+rangeFrom+"' "
				    			+ " and '"+rangeTo+"' "
				    			+ " and target_view_id = "+tViewId+" "
				    			+ " and current_record_flag is true "
				    			+ " and recon.target_row_id = dv.scrIds "
				    			+ " and recon_status = 'RECONCILED' "
				    			+ " and tenant_id = "+tenantId+" "
				    			+ " and recon.final_action_date is not null "
				    			+ approvalNullCondition
				    			+ " and sign(target_row_id) = -1 "
				    			+ " and upper("
				    			+ " IFNULL(adjustmentType, 'X')"
				    			+ " )= 'VARIANCE' "
				    			+ " group by "
				    			+ " Date(final_action_date)"
				    			+ " ) v_recon on Date(recon.final_action_date) = Date(v_recon.final_action_date)"
				    			+ " ) target on Date(source.final_action_date) = Date(target.final_action_date) order by name desc";
			    	}
			    	else
			    	{
				    	query = " select"
				    			+ " source."+sGroupingColumn+" name,"
				    			+ ruleCodeSource
				    			+ " source.count src_count,"
				    			+ " target.count tr_count,"
				    			+ " source.total_amt src_amount, "
				    			+ " target.total_amt tr_amount, "
				    			+ " source.variance_amount src_var_amount, "
				    			+ " target.variance_amount tr_var_amount "
				    			+ " from "
				    			+ " ("
				    			+ " select "
				    			+ " recon."+sGroupingColumn+", "
				    			+ ruleCodeRecon
				    			+ " recon.count, "
				    			+ " recon.amount_sum, "
				    			+ " v_recon.variance_amount, "
				    			+ " recon.amount_sum + IFNULL(v_recon.variance_amount, 0) total_amt "
				    			+ " from "
				    			+ " ("
				    			+ " select "
				    			+ " "+sGroupingColumn+", "
				    			+ ruleCodeRl
				    			+ " count(*) count, "
				    			+ " sum(dv.`"+sAmountCol+"`) amount_sum "
				    			+ " from "
				    			+ " "+reconTable+" recon "
				    			+ " LEFT JOIN t_rules rl ON recon.approval_rule_id = rl.id, "
				    			+ " `"+sdv.getDataViewName().toLowerCase()+"` dv "
				    			+ " where "
				    			+ " reconciliation_rule_group_id = "+groupId+" "
				    			+ " and Date(dv.`"+periodFactor+"`) between '"+rangeFrom+"' "
				    			+ " and '"+rangeTo+"' "
				    			+ " and original_view_id = "+sViewId+" "
				    			+ " and current_record_flag is true "
				    			+ " and recon.original_row_id = dv.scrIds "
				    			+ " and recon_status = 'RECONCILED' "
				    			+ " and recon.tenant_id = "+tenantId+" "
				    			+ approvalNullCondition
				    			+ " and upper("
				    			+ " IFNULL(adjustmentType, 'X')"
				    			+ " )!= 'VARIANCE' "
				    			+ " group by "
				    			+ " "+sGroupingColumn+""
				    			+ " ) recon "
				    			+ " left outer join ("
				    			+ " select "
				    			+ " "+sGroupingColumn+", "
				    			+ " count(*) count, "
				    			+ " sum(dv.`"+sAmountCol+"`) variance_amount "
				    			+ " from "
				    			+ " "+reconTable+" recon, "
				    			+ " `"+sdv.getDataViewName().toLowerCase()+"` dv "
				    			+ " where "
				    			+ " reconciliation_rule_group_id = "+groupId+" "
				    			+ " and Date(dv.`"+periodFactor+"`) between '"+rangeFrom+"' "
				    			+ " and '"+rangeTo+"' "
				    			+ " and original_view_id = "+sViewId+" "
				    			+ " and current_record_flag is true "
				    			+ " and recon.original_row_id = dv.scrIds "
				    			+ " and recon_status = 'RECONCILED' "
				    			+ " and tenant_id = "+tenantId+" "
				    			+ approvalNullCondition
				    			+ " and sign(original_row_id) = -1 "
				    			+ " and upper("
				    			+ " IFNULL(adjustmentType, 'X')"
				    			+ " )= 'VARIANCE' "
				    			+ " group by "
				    			+ " "+sGroupingColumn+""
				    			+ " ) v_recon on recon."+sGroupingColumn+" = v_recon."+sGroupingColumn+""
				    			+ " ) source "
				    			+ " left outer join ("
				    			+ " select "
				    			+ " recon."+tGroupingColumn+", "
				    			+ " recon.count, "
				    			+ " recon.amount_sum, "
				    			+ " v_recon.variance_amount, "
				    			+ " recon.amount_sum + IFNULL(v_recon.variance_amount, 0) total_amt "
				    			+ " from "
				    			+ " ("
				    			+ " select "
				    			+ " "+tGroupingColumn+", "
				    			+ " count(*) count, "
				    			+ " sum(dv.`"+tAmountCol+"`) amount_sum "
				    			+ " from "
				    			+ " "+reconTable+" recon "
				    			+ " LEFT JOIN t_rules rl ON recon.approval_rule_id = rl.id, "
				    			+ " `"+tdv.getDataViewName().toLowerCase()+"` dv "
				    			+ " where "
				    			+ " reconciliation_rule_group_id = "+groupId+" "
				    			+ " and Date(dv.`"+periodFactor+"`) between '"+rangeFrom+"' "
				    			+ " and '"+rangeTo+"' "
				    			+ " and target_view_id = "+tViewId+" "
				    			+ " and current_record_flag is true "
				    			+ " and recon.target_row_id = dv.scrIds "
				    			+ " and recon_status = 'RECONCILED' "
				    			+ " and recon.tenant_id = "+tenantId+" "
				    			+ approvalNullCondition
				    			+ " and upper("
				    			+ " IFNULL(adjustmentType, 'X')"
				    			+ " )!= 'VARIANCE' "
				    			+ " group by "
				    			+ " "+tGroupingColumn+""
				    			+ " ) recon "
				    			+ " left outer join ("
				    			+ " select "
				    			+ " "+tGroupingColumn+", "
				    			+ " count(*) count, "
				    			+ " sum(dv.`"+tAmountCol+"`) variance_amount "
				    			+ " from "
				    			+ " "+reconTable+" recon, "
				    			+ " `"+tdv.getDataViewName().toLowerCase()+"` dv "
				    			+ " where "
				    			+ " reconciliation_rule_group_id = "+groupId+" "
				    			+ " and Date(dv.`"+periodFactor+"`) between '"+rangeFrom+"' "
				    			+ " and '"+rangeTo+"' "
				    			+ " and target_view_id = "+tViewId+" "
				    			+ " and current_record_flag is true "
				    			+ " and recon.target_row_id = dv.scrIds "
				    			+ " and recon_status = 'RECONCILED' "
				    			+ " and tenant_id = "+tenantId+" "
				    			+ approvalNullCondition
				    			+ " and sign(target_row_id) = -1 "
				    			+ " and upper("
				    			+ " IFNULL(adjustmentType, 'X')"
				    			+ " )= 'VARIANCE' "
				    			+ " group by "
				    			+ " "+tGroupingColumn+""
				    			+ " ) v_recon on recon."+tGroupingColumn+" = v_recon."+tGroupingColumn+""
				    			+ " ) target on IFNULL(source."+sGroupingColumn+", 'AAA') = IFNULL(target."+tGroupingColumn+", 'AAA') order by name asc";

			    	}
				}
				else
				{
					query = fieldsQuery
							+ " (select "
							+ " recon."+sGroupingColumn+","+ruleCodeQueryInside
							+ " recon.count, "
							+ " recon.amount_sum, "
							+ " v_recon.variance_amount, "
							+ " recon.amount_sum + IFNULL(v_recon.variance_amount,0) total_amt"
							+ " from ( select "
							+sJobReferenceGroupBySelect +", "
							+ " count(*) count, "
							+ " sum(dv.`"+sAmountCol+"`) amount_sum "
							+ " from "
					        + " "+reconTable+" recon "
					        + " LEFT JOIN t_rules rl ON recon.reconciliation_rule_id = rl.id, "
					        + " `"+sdv.getDataViewName().toLowerCase()+"` dv "
							+ " where "
							+ " reconciliation_rule_group_id = "+groupId+" "
							+ " and Date(dv.`"+sPeriodFactor+"`) between '"+rangeFrom+"' and '"+rangeTo+"' "
							+ " and original_view_id = "+sViewId+" "
							+ " and current_record_flag is true "
							+ " and recon.original_row_id = dv.scrIds "
							+ " and recon_status = 'RECONCILED' "
							+ " and recon.tenant_id = "+tenantId+" "
							+ " and upper(IFNULL(adjustmentType, 'X') )!= 'VARIANCE' "
							+ " group by "
							+sJobReferenceGroupBy
							+ " ) recon "
							+ " left outer join ("
							+ " select "+sGroupingColumn+","
							+ " count(*) count, "
							+ " sum(dv.`"+sAmountCol+"`) variance_amount "
							+ " from "
							+ " "+reconTable+" recon, "
							+ " `"+sdv.getDataViewName().toLowerCase()+"` dv "
							+ " where "
							+ " reconciliation_rule_group_id = "+groupId+" "
							+ " and Date(dv.`"+sPeriodFactor+"`) between '"+rangeFrom+"' and '"+rangeTo+"' "
							+ " and original_view_id = "+sViewId+" "
							+ " and current_record_flag is true "
							+ " and recon.original_row_id = dv.scrIds "
							+ " and recon_status = 'RECONCILED' "
							+ " and tenant_id = "+tenantId+" "
							+ " and sign(original_row_id) = -1 "
							+ " and upper("
							+ " IFNULL(adjustmentType, 'X')"
							+ " )= 'VARIANCE' "
							+ " group by "+sGroupingColumn+" "
							+ " ) v_recon on recon."+sGroupingColumn+" = v_recon."+sGroupingColumn+") source"
							// Source 
							
							+ " left outer join"
							
							// Target
							+ " (select "
							+ " recon."+tGroupingColumn+","
							+ " recon.count, "
							+ " recon.amount_sum, "
							+ " v_recon.variance_amount,     "
							+ " recon.amount_sum + IFNULL(v_recon.variance_amount,0) total_amt"
							+ " from (select "
							+ tJobReferenceGroupBySelect +", "
							+ " count(*) count, "
							+ " sum(dv.`"+tAmountCol+"`) amount_sum "
							+ " from "
							+ " "+reconTable+" recon "
							+ " LEFT JOIN t_rules rl ON recon.reconciliation_rule_id = rl.id, "
							+ " `"+tdv.getDataViewName().toLowerCase()+"` dv "
							+ " where "
							+ " reconciliation_rule_group_id = "+groupId+" "
							+ " and Date(dv.`"+tPeriodFactor+"`) between '"+rangeFrom+"' and '"+rangeTo+"' "
							+ " and target_view_id = "+tViewId+" "
							+ " and current_record_flag is true "
							+ " and recon.target_row_id = dv.scrIds "
							+ " and recon_status = 'RECONCILED' "
							+ " and recon.tenant_id = "+tenantId+" "
							+ " and upper("
							+ " IFNULL(adjustmentType, 'X')"
							+ " )!= 'VARIANCE' "
							+ " group by "
							+tJobReferenceGroupBy					
							+ " ) recon "
							+ " left outer join (select "+tGroupingColumn+","
							+ " count(*) count, "
							+ " sum(dv.`"+tAmountCol+"`) variance_amount "
							+ " from "
							+ " "+reconTable+" recon, "
							+ " `"+tdv.getDataViewName().toLowerCase()+"` dv "
							+ " where "
							+ " reconciliation_rule_group_id = "+groupId+" "
							+ " and Date(dv.`"+tPeriodFactor+"`) between '"+rangeFrom+"' "
							+ " and '"+rangeTo+"' "
							+ " and target_view_id = "+tViewId+" "
							+ " and current_record_flag is true "
							+ " and recon.target_row_id = dv.scrIds "
							+ " and recon_status = 'RECONCILED' "
							+ " and tenant_id = "+tenantId+" "
							+ " and sign(target_row_id) = -1 "
							+ " and upper("
							+ " IFNULL(adjustmentType, 'X')"
							+ " )= 'VARIANCE' "
							+ " group by "+tGroupingColumn+" "
							+ " ) v_recon on recon."+tGroupingColumn+" = v_recon."+tGroupingColumn+") target"
							+ " on IFNULL(source."+sGroupingColumn+", 'AAA') = IFNULL(target."+tGroupingColumn+", 'AAA') order by name asc";
				}
			    	
				log.info("Query for fetching reconciliation grouping summary info: "+ query);
				
/*				Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
				String currencyFormat = props.getProperty("currencyFormat");*/
				NumberFormat numFormat = NumberFormat.getInstance();
				
				result=stmt.executeQuery(query);
				if("rules".equalsIgnoreCase(groupBy) || "approvalRule".equalsIgnoreCase(groupBy))
				{
		        	while(result.next()){
		        		HashMap map = new HashMap();
		        		String sAmount = "0.0";
		        		String tAmount = "0.0";
		        		String sCount = "0";
		        		String tCount = "0";
		        		if(result.getString("src_amount") != null)
		        		{
		        			sAmount = result.getString("src_amount").toString();
		        		}
		        		if(result.getString("tr_amount") != null)
		        		{
		        			tAmount = result.getString("tr_amount").toString();
		        		}
		        		if(result.getString("src_count") != null)
		        		{
		        			sCount = result.getString("src_count").toString();
		        		}
		        		if(result.getString("tr_count") != null)
		        		{
		        			tCount = result.getString("tr_count").toString();
		        		}
		        		/*map.put("sAmount",  getAmountInFormat(sAmount,currencyFormat));*/
		        		map.put("sAmount",  Double.parseDouble(sAmount));
		        		map.put("dsCount", Long.parseLong(sCount));
		        		map.put("id", Long.parseLong(result.getString("name").toString()));
		        		map.put("name", result.getString("rule_code").toString());
		        		map.put("dtCount", Long.parseLong(tCount));
		        		map.put("sCount", numFormat.format(Long.parseLong(sCount)));
		        		map.put("tCount", numFormat.format(Long.parseLong(tCount)));
		        		map.put("tAmount",  Double.parseDouble(tAmount));
		        		totalSrcAmount = totalSrcAmount + Double.parseDouble(sAmount);
		        		totalTrAmount = totalTrAmount + Double.parseDouble(tAmount);
		        		totalSrcCount = totalSrcCount + Long.parseLong(sCount);
		        		totalTrCount = totalTrCount + Long.parseLong(tCount); 
		        		finalList.add(map);
		        	}	  
				}
				else
				{
		        	while(result.next()){
		        		HashMap map = new HashMap();
		        		String sAmount = "0.0";
		        		String tAmount = "0.0";
		        		String sCount = "0";
		        		String tCount = "0";
		        		if(result.getString("src_amount") != null)
		        		{
		        			sAmount = result.getString("src_amount").toString();
		        		}
		        		if(result.getString("tr_amount") != null)
		        		{
		        			tAmount = result.getString("tr_amount").toString();
		        		}
		        		if(result.getString("src_count") != null)
		        		{
		        			sCount = result.getString("src_count").toString();
		        		}
		        		if(result.getString("tr_count") != null)
		        		{
		        			tCount = result.getString("tr_count").toString();
		        		}
		        		/*map.put("sAmount", getAmountInFormat(sAmount,currencyFormat));*/
		        		map.put("sAmount", Double.parseDouble(sAmount));
		        		map.put("dsCount", Long.parseLong(sCount));
		        		if(result.getString("name") != null)
		        		{
			        		map.put("name", result.getString("name"));		        			
		        		}
		        		else
		        		{
			        		map.put("name", "Awaiting");
		        		}
		        		map.put("dtCount", Long.parseLong(tCount));
		        		map.put("sCount", numFormat.format(Long.parseLong(sCount)));
		        		map.put("tCount", numFormat.format(Long.parseLong(tCount)));
		        		/*map.put("tAmount", getAmountInFormat(tAmount,currencyFormat));*/
		        		map.put("tAmount", Double.parseDouble(tAmount));
		        		totalSrcAmount = totalSrcAmount + Double.parseDouble(sAmount);
		        		totalTrAmount = totalTrAmount + Double.parseDouble(tAmount);
		        		totalSrcCount = totalSrcCount + Long.parseLong(sCount);
		        		totalTrCount = totalTrCount + Long.parseLong(tCount); 
		        		finalList.add(map);
		        	}
				}
/*				info.put("totalSrcAmount", getAmountInFormat(totalSrcAmount.toString(), currencyFormat));*/
				info.put("totalSrcAmount", Double.parseDouble(totalSrcAmount.toString()));
/*				info.put("totalTrAmount", getAmountInFormat(totalTrAmount.toString(), currencyFormat));*/
				info.put("totalTrAmount", Double.parseDouble(totalTrAmount.toString()));
				info.put("totalSrcCount",  numFormat.format(Long.parseLong(totalSrcCount.toString())));
				info.put("totalTrCount",  numFormat.format(Long.parseLong(totalTrCount.toString())));
			}
			catch(Exception e)
			{
				log.info("Exception while fetching reconciliation grouping summary info. "+e);
			}
			finally
			{
	    		try{
					if(result != null)
						result.close();
					if(stmt != null)
						stmt.close();
					if(conn != null)
						conn.close();	    			
	    		}
	    		catch(Exception e)
	    		{
	    			log.info("Exception while closing jdbc statements.(Fetching un reconciled transactions.) "+e);
	    		} 
			}
			List<HashMap> approvalsInfo = new ArrayList<HashMap>();
			if(finalList.size()>0)
			{
				if("approvalStatus".equalsIgnoreCase(groupBy))
				{
					for(HashMap hm : finalList)
					{
						String name = hm.get("name").toString();
						LookUpCode lookUpCode=lookUpCodeRepository.findByTenantIdAndLookUpTypeAndLookUpCode(tenantId,"APPROVAL_STATUS",name);
						if(lookUpCode != null)
						{
							hm.put("name", lookUpCode.getMeaning());
						}
						approvalsInfo.add(hm);
					}
					finalList.clear();
					finalList.addAll(approvalsInfo);					
				}
				else if("approvalDate".equalsIgnoreCase(groupBy))
				{
					for(HashMap hm : finalList)
					{
						String name = hm.get("name").toString();
						
						DateFormat df = new SimpleDateFormat("yyyy-MM-dd");
						Date date= df.parse(name);
						df = new SimpleDateFormat("dd-MMM-yy");
				       	hm.put("name", df.format(date));	
				       	approvalsInfo.add(hm);
					}
					finalList.clear();
					finalList.addAll(approvalsInfo);					

				}
			}
			finalMap.put("summary", finalList);
			finalMap.put("info", info);
	    	return finalMap;
	    }
	    
	    
	    public HashMap getUnReconGroupingSummaryInfo(String srcColumn, String trgtColumn, Long groupId, Long sViewId, Long tViewId, String periodFactor, String rangeFrom, String rangeTo, String groupBy, 
	    		String ascOrDesc) throws ClassNotFoundException
	    {
	    	HashMap finalMap = new HashMap();
	    	List<HashMap> finalList = new ArrayList<>();
/*			Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
			String currencyFormat = props.getProperty("currencyFormat");*/
			NumberFormat numFormat = NumberFormat.getInstance();
			Connection conn = null;
			Statement stmt = null;
			ResultSet result = null; 
			
			Double totalSrcAmount = 0.0;
			Double totalTrAmount = 0.0;
			
			Long totalSrcCount = 0L;
			Long totalTrCount = 0L;
			
			HashMap info = new HashMap();
			
			try{				
				DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
				conn = ds.getConnection();
				
				DataViews sdv = dataViewsRepository.findOne(sViewId.longValue());
				DataViews tdv = dataViewsRepository.findOne(tViewId.longValue());
				
	    		String srcAmountCol = getTransDateQualifier(BigInteger.valueOf(sViewId), "AMOUNT");
	    		String trAmountCol = getTransDateQualifier(BigInteger.valueOf(tViewId), "AMOUNT");

	    		String sPeriodFactor = "";
	    		String tPeriodFactor = "";
		    	if("fileDate".equalsIgnoreCase(periodFactor))
		    	{
		    		sPeriodFactor = "fileDate";
		    		tPeriodFactor = "fileDate";
		    	}
		    	else if("dateQualifier".equalsIgnoreCase(periodFactor))
		    	{
		    		sPeriodFactor = getTransDateQualifier(BigInteger.valueOf(sViewId), "TRANSDATE");
		    		tPeriodFactor = getTransDateQualifier(BigInteger.valueOf(tViewId), "TRANSDATE");
		    	}
				
				log.info("Connected to JDBC Successfully");
				stmt = conn.createStatement();
				String query = "select grouping_col, sum(source_amount) s_amount, sum(src_count) s_count, sum(target_amount) t_amount, sum(tr_count) t_count from"
						+ " ("
						+ " SELECT "+srcColumn+" grouping_col, `"+srcAmountCol+"` source_amount, 1 src_count, 0 target_amount, 0 tr_count"
						+ "                 FROM   `"+sdv.getDataViewName().toLowerCase()+"` dv "
						+ "                WHERE  Date(`"+sPeriodFactor+"`) BETWEEN '"+rangeFrom+"' AND '"+rangeTo+"'"
						+ "                and scrIds not in (SELECT original_row_id "
						+ "                                FROM t_reconciliation_result "
						+ "                                WHERE  reconciliation_rule_group_id = "+groupId+" "
						+ "                                       AND original_view_id = "+sViewId+" "
						+ "                                       AND recon_status = 'RECONCILED' "
						+ "                                       AND current_record_flag IS TRUE)"
						+ " union all                "
						+ " SELECT  "+trgtColumn+" grouping_col,0 source_amount,0 src_count, `"+trAmountCol+"` target_amount, 1 tr_count"
						+ "                FROM   `"+tdv.getDataViewName().toLowerCase()+"` dv "
						+ "                WHERE  Date(`"+tPeriodFactor+"`) BETWEEN '"+rangeFrom+"' AND '"+rangeTo+"'"
						+ "                and scrIds not in (SELECT target_row_id "
						+ "                                FROM   t_reconciliation_result "
						+ "                                WHERE  reconciliation_rule_group_id = "+groupId+" "
						+ "                                       AND target_view_id = "+tViewId+""
						+ "                                       AND recon_status = 'RECONCILED' "
						+ "                                       AND current_record_flag IS TRUE)"
						+ " ) unrecon"
						+ " group by grouping_col order by grouping_col "+ascOrDesc;
				log.info("Query for fetching un reconciled summary info: "+query);
				result=stmt.executeQuery(query);
				if("days".equalsIgnoreCase(groupBy))
				{
					while(result.next())
					{
						String sAmout = "0.0";
						String tAmount = "0.0";
						String sCount = "0";
						String tCount = "0";
						if(result.getString("s_amount") != null )
						{
							sAmout = result.getString("s_amount").toString();
						}
						if(result.getString("t_amount") != null)
						{
							tAmount = result.getString("t_amount").toString();
						}
						if(result.getString("s_count") != null)
						{
							sCount = result.getString("s_count").toString();
						}
						if(result.getString("t_count") != null)
						{
							tCount = result.getString("t_count").toString();
						}
				       	HashMap map = new HashMap();
				       /*	map.put("sAmount",  getAmountInFormat(sAmout, currencyFormat));*/
				    	map.put("sAmount",  Double.parseDouble(sAmout));
				       	map.put("dsCount", Long.parseLong(sCount));
						DateFormat df = new SimpleDateFormat("yyyy-MM-dd");
						Date date= df.parse(result.getString("grouping_col").toString());
						df = new SimpleDateFormat("dd-MMM-yy");
				       	map.put("name", df.format(date));
				       	map.put("dtCount", Long.parseLong(tCount));
				       	map.put("sCount", numFormat.format(Long.parseLong(sCount)));
				       	map.put("tCount", numFormat.format(Long.parseLong(tCount)));
				       	/*map.put("tAmount", getAmountInFormat(tAmount, currencyFormat));	*/
				       	map.put("tAmount", Double.parseDouble(tAmount));	
				       	
		        		totalSrcAmount = totalSrcAmount + Double.parseDouble(sAmout);
		        		totalTrAmount = totalTrAmount + Double.parseDouble(tAmount);
		        		totalSrcCount = totalSrcCount + Long.parseLong(sCount);
		        		totalTrCount = totalTrCount + Long.parseLong(tCount); 
				       	
				       	finalList.add(map);
				    }
				}
				else
				{
					while(result.next())
					{
				       	HashMap map = new HashMap();
				       	/*map.put("sAmount",  getAmountInFormat(result.getString("s_amount"), currencyFormat));*/
				       	map.put("sAmount",  Double.parseDouble(result.getString("s_amount")));
				       	map.put("dsCount", Long.parseLong(result.getString("s_count").toString()));
				       	map.put("name", result.getString("grouping_col").toString());
				       	map.put("dtCount", Long.parseLong(result.getString("t_count").toString()));
				       	map.put("sCount", numFormat.format(Long.parseLong(result.getString("s_count").toString())));
				       	map.put("tCount", numFormat.format(Long.parseLong(result.getString("t_count").toString())));
				       	/*map.put("tAmount", getAmountInFormat(result.getString("t_amount").toString(), currencyFormat));*/
				       	map.put("tAmount", Double.parseDouble(result.getString("t_amount").toString()));
				       	
		        		totalSrcAmount = totalSrcAmount + Double.parseDouble(result.getString("s_amount"));
		        		totalTrAmount = totalTrAmount + Double.parseDouble(result.getString("t_amount"));
		        		totalSrcCount = totalSrcCount + Long.parseLong(result.getString("s_count").toString());
		        		totalTrCount = totalTrCount + Long.parseLong(result.getString("t_count").toString()); 
				       	
				       	finalList.add(map);
				    }
				}
				
/*				info.put("totalSrcAmount", getAmountInFormat(totalSrcAmount.toString(), currencyFormat));*/
				info.put("totalSrcAmount", Double.parseDouble(totalSrcAmount.toString()));
				/*info.put("totalTrAmount", getAmountInFormat(totalTrAmount.toString(), currencyFormat));*/
				info.put("totalTrAmount", Double.parseDouble(totalTrAmount.toString()));
				info.put("totalSrcCount",  numFormat.format(Long.parseLong(totalSrcCount.toString())));
				info.put("totalTrCount",  numFormat.format(Long.parseLong(totalTrCount.toString())));
				
			}
			catch(Exception e)
			{
				log.info("Exception while fetching un reconciled count and amounts: "+e);
			}
			finally
			{
	    		try{
					if(result != null)
						result.close();
					if(stmt != null)
						stmt.close();
					if(conn != null)
						conn.close();	    			
	    		}
	    		catch(Exception e)
	    		{
	    			log.info("Exception while closing jdbc statements.(Fetching un reconciled summary.) "+e);
	    		} 				
			}
			finalMap.put("summary", finalList);
			finalMap.put("info", info);
	    	return finalMap;
	    }
	    
	    public List<LinkedHashMap> getUnReconTransactionsData(String srcOrTrgt, Long groupId, Long viewId, String periodFactor, String rangeFrom, String rangeTo, String filterQuery,
	    		Long pageStartIndx, Long pageSize, String columnSearchQuery)
	    {
	    	log.info("Fetching Un Reconciliation Data...");
	    	List<LinkedHashMap> finalList = new ArrayList<LinkedHashMap>();
			Connection conn = null;
			Statement stmt = null;
			ResultSet result = null;
			Statement stmt2 = null;
			ResultSet result2 = null;
			String query = "";
			String totalCountQuery = "";
			try{
				
				DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
				conn = ds.getConnection();
				stmt = conn.createStatement();
				String amountQualifier = reconciliationResultService.getViewColumnQualifier(BigInteger.valueOf(viewId), "AMOUNT");
				DataViews dv = dataViewsRepository.findOne(viewId);
				
				if("source".equalsIgnoreCase(srcOrTrgt))
				{
					query = "SELECT * FROM `"+dv.getDataViewName().toLowerCase()+"` dv "
							+ " WHERE Date(`"+periodFactor+"`) BETWEEN '"+rangeFrom+"' AND '"+rangeTo+"' " +filterQuery + columnSearchQuery
							+ " AND scrids NOT IN (SELECT original_row_id FROM t_reconciliation_result "
							+ " WHERE reconciliation_rule_group_id = "+groupId+" "
							+ " AND original_view_id = "+viewId+" "
							+ " AND recon_status = 'RECONCILED' "
							+ " AND current_record_flag IS TRUE) limit "+pageStartIndx+", "+ pageSize;
					
					totalCountQuery = "SELECT count(*) FROM `"+dv.getDataViewName().toLowerCase()+"` dv "
							+ " WHERE Date(`"+periodFactor+"`) BETWEEN '"+rangeFrom+"' AND '"+rangeTo+"' " +filterQuery + columnSearchQuery
							+ " AND scrids NOT IN (SELECT original_row_id FROM t_reconciliation_result "
							+ " WHERE reconciliation_rule_group_id = "+groupId+" "
							+ " AND original_view_id = "+viewId+" "
							+ " AND recon_status = 'RECONCILED' "
							+ " AND current_record_flag IS TRUE) ";
				}
				else
				{
					query = "SELECT * FROM `"+dv.getDataViewName().toLowerCase()+"` dv "
							+ " WHERE  Date(`"+periodFactor+"`) BETWEEN '"+rangeFrom+"' AND '"+rangeTo+"' " + columnSearchQuery
							+ " AND scrids NOT IN (SELECT target_row_id FROM t_reconciliation_result "
							+ " WHERE reconciliation_rule_group_id = "+groupId+" "
							+ " AND target_view_id = "+viewId+" "
							+ " AND recon_status = 'RECONCILED' "
							+ " AND current_record_flag IS TRUE) limit "+pageStartIndx+", "+ pageSize;
					totalCountQuery = "SELECT count(*) FROM `"+dv.getDataViewName().toLowerCase()+"` dv "
							+ " WHERE  Date(`"+periodFactor+"`) BETWEEN '"+rangeFrom+"' AND '"+rangeTo+"' " + columnSearchQuery
							+ " AND scrids NOT IN (SELECT target_row_id FROM t_reconciliation_result "
							+ " WHERE reconciliation_rule_group_id = "+groupId+" "
							+ " AND target_view_id = "+viewId+" "
							+ " AND recon_status = 'RECONCILED' "
							+ " AND current_record_flag IS TRUE)";
				}
				log.info("Query for fetching Un-Reconciled Transactions Data: "+query);
	     	    result=stmt.executeQuery(query);
		     	stmt2 = conn.createStatement();
		     	result2 = stmt2.executeQuery(totalCountQuery);
     	    	ResultSetMetaData rsmd = result.getMetaData();
     	    	int colCount = rsmd.getColumnCount();
	     	    while(result.next()){
					LinkedHashMap hm = new LinkedHashMap();
					for(int i=1; i<= colCount; i++)
					{
						hm.put(rsmd.getColumnName(i), result.getString(i));
					}
					hm.put("dataRowId", hm.get("scrIds"));
					hm.remove("scrIds");
					hm.remove("srcFileInbId");
					hm.remove("fileDate");
					finalList.add(hm);
				}
	     	    Long totalCount = 0L;
	     	    while(result2.next())
	     	    {
	     	    	if(result2.getString(1)!=null)
	     	    	{
	     	    		totalCount = Long.parseLong(result2.getString(1).toString());
	     	    	}
	     	    }
	     	    HashMap info = new HashMap();
	     	    info.put("totalCount", totalCount);
	     	    info.put("amountQualifier", amountQualifier);
	     	    LinkedHashMap infoObj = new LinkedHashMap();
	     	    infoObj.put("info", info);
	     	    finalList.add(infoObj);
			}
			catch(Exception e)
			{
				log.info("Exception while fetching un-reconciliation transactions: "+e);
			}
			finally{
	    		try{
					if(result != null)
						result.close();
					if(result2 != null)
						result2.close();
					if(stmt != null)
						stmt.close();
					if(stmt2 != null)
						stmt2.close();
					if(conn != null)
						conn.close();	    			
	    		}
	    		catch(Exception e)
	    		{
	    			log.info("Exception while closing jdbc statements.(Fetching un reconciled transactions.) "+e);
	    		} 
			}
	    	return finalList;
	    }
	    
	    public HashMap getReconRefChildData(String sourceOrTarget, Long viewId, Long groupId, String reconReference, Long tenantId, String varOrNonVariance, String amountQualifier)
	    {
	    	HashMap finalMap = new HashMap();
	    	List<LinkedHashMap> finalList = new ArrayList<LinkedHashMap>();
	    	HashMap info = new HashMap();
	    	Connection conn = null;
    		Statement stmt = null;
    		ResultSet result = null;
    		Statement totalCountStmt = null;
    		ResultSet totalCountRS = null;
    		
    		try{
    			DataViews dv = dataViewsRepository.findById(viewId);
    			String query = "";
    			String totalCountQuery = "";
    			if("source".equalsIgnoreCase(sourceOrTarget))
    			{
    				query = "select recon_reference, dv.* from t_reconciliation_result recon, `"+dv.getDataViewName().toLowerCase()+"` dv"
    						+ " where "
    						+ " reconciliation_rule_group_id = "+groupId+" and original_view_id = "+viewId+" and current_record_flag is true and original_row_id = dv.scrIds"
    						+ " and recon_reference = '"+reconReference+"' and tenant_id = "+tenantId+" and upper(IFNULL(adjustmentType,'X')) "+varOrNonVariance+" 'VARIANCE'";
    				
    				totalCountQuery = "select sum(`"+amountQualifier+"`), count(*) from t_reconciliation_result recon, `"+dv.getDataViewName().toLowerCase()+"` dv"
    						+ " where "
    						+ " reconciliation_rule_group_id = "+groupId+" and original_view_id = "+viewId+" and current_record_flag is true and original_row_id = dv.scrIds"
    						+ " and recon_reference = '"+reconReference+"' and tenant_id = "+tenantId+" and upper(IFNULL(adjustmentType,'X')) "+varOrNonVariance+" 'VARIANCE'";
    				
    			}
    			else if("target".equalsIgnoreCase(sourceOrTarget))
    			{
    				query = "select recon_reference, dv.* from t_reconciliation_result recon, `"+dv.getDataViewName().toLowerCase()+"` dv"
    						+ " where "
    						+ " reconciliation_rule_group_id = "+groupId+" and target_view_id = "+viewId+" and current_record_flag is true and target_row_id = dv.scrIds"
    						+ " and recon_reference = '"+reconReference+"' and tenant_id = "+tenantId+" and upper(IFNULL(adjustmentType,'X')) "+varOrNonVariance+" 'VARIANCE'";
    				totalCountQuery = "select sum(`"+amountQualifier+"`), count(*) from t_reconciliation_result recon, `"+dv.getDataViewName().toLowerCase()+"` dv"
    						+ " where "
    						+ " reconciliation_rule_group_id = "+groupId+" and target_view_id = "+viewId+" and current_record_flag is true and target_row_id = dv.scrIds"
    						+ " and recon_reference = '"+reconReference+"' and tenant_id = "+tenantId+" and upper(IFNULL(adjustmentType,'X')) "+varOrNonVariance+" 'VARIANCE'";
    			}
    			log.info("Query to fetch ReconRefData: "+ query);
    			DataSource ds = (DataSource)ApplicationContextProvider.getApplicationContext().getBean("dataSource");
    			conn = ds.getConnection();
    			
	     	    stmt = conn.createStatement();
	     	    result=stmt.executeQuery(query);
	     	    
	     	    totalCountStmt = conn.createStatement();
	     	    totalCountRS = totalCountStmt.executeQuery(totalCountQuery); 
	     	    
	     	    ResultSetMetaData rsmd = result.getMetaData();
	     	    int colCount = rsmd.getColumnCount();
	     	    
	     	    while(result.next()){
	     	    	LinkedHashMap hm = new LinkedHashMap();
					for(int i=1; i<= colCount; i++)
					{
						hm.put(rsmd.getColumnName(i), result.getString(i));
					}
					hm.remove("scrIds");
					hm.remove("srcFileInbId");
					hm.remove("fileDate");
					finalList.add(hm);
				}				
	     	    
	     	    while(totalCountRS.next())
	     	    {
	     	    	info.put("amount", totalCountRS.getString(1));
	     	    	info.put("count", totalCountRS.getString(2));
	     	    }
	     	    
    		}catch(Exception e)
    		{
    			log.info("Exception while fetching reconciliation child data. "+e);
    		}
    		finally
    		{
	    		try{
					if(result != null)
						result.close();
					if(totalCountRS != null)
						totalCountRS.close();
					if(stmt != null)
						stmt.close();
					if(totalCountStmt != null)
						totalCountStmt.close();
					if(conn != null)
						conn.close();			
	    		}
	    		catch(Exception e)
	    		{
	    			log.info("Exception while closing jdbc statements.(Recon Reference Data) "+e);
	    		}
    		}
    		finalMap.put("data", finalList);
    		finalMap.put("info", info);
	    	return finalMap;
	    }
	    
	    public List<String> getColumnAlilasByViewId(Long viewId)
	    {
	    	List<String> columnNames = new ArrayList<String>();
			List<DataViewsColumns> dvc = dataViewsColumnsRepository.findByDataViewId(viewId);
			if(dvc.size()>0)
			{
				for(DataViewsColumns dv : dvc)
				{
					if("File Template".equalsIgnoreCase(dv.getRefDvType()))
					{
						FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dv.getRefDvColumn().toString()));
						if(ftl != null)
						{
							columnNames.add(ftl.getColumnAlias());
						}
					}
					else if("Data View".equalsIgnoreCase(dv.getRefDvType()) || dv.getRefDvType() == null)
					{
						columnNames.add(dv.getColumnName());
					}
				}
			}			
	    	return columnNames;
	    }
}