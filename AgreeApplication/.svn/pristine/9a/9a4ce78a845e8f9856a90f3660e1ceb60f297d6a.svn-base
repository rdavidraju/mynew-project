package com.nspl.app.web.rest;

import static org.elasticsearch.index.query.QueryBuilders.queryStringQuery;
import io.github.jhipster.web.util.ResponseUtil;
import io.swagger.annotations.ApiParam;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.math.BigInteger;
import java.net.URI;
import java.net.URISyntaxException;
import java.sql.SQLException;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.time.ZonedDateTime;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Optional;
import java.util.Properties;

import javax.inject.Inject;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

import org.apache.poi.ss.usermodel.CellStyle;
import org.apache.poi.ss.usermodel.Font;
import org.apache.poi.xssf.usermodel.XSSFCell;
import org.apache.poi.xssf.usermodel.XSSFRow;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.codahale.metrics.annotation.Timed;
import com.nspl.app.domain.AccountedSummary;
import com.nspl.app.domain.AccountingData;
import com.nspl.app.domain.AppModuleSummary;
import com.nspl.app.domain.DataViews;
import com.nspl.app.domain.RuleGroup;
import com.nspl.app.domain.Rules;
import com.nspl.app.repository.AccountedSummaryRepository;
import com.nspl.app.repository.AccountingDataRepository;
import com.nspl.app.repository.AccountingLineTypesRepository;
import com.nspl.app.repository.AcctRuleConditionsRepository;
import com.nspl.app.repository.AppModuleSummaryRepository;
import com.nspl.app.repository.DataMasterRepository;
import com.nspl.app.repository.DataViewsColumnsRepository;
import com.nspl.app.repository.DataViewsRepository;
import com.nspl.app.repository.FileTemplateLinesRepository;
import com.nspl.app.repository.LookUpCodeRepository;
import com.nspl.app.repository.RuleGroupDetailsRepository;
import com.nspl.app.repository.RuleGroupRepository;
import com.nspl.app.repository.RulesRepository;
import com.nspl.app.repository.search.AccountingDataSearchRepository;
import com.nspl.app.service.AccountingDataService;
import com.nspl.app.service.FileService;
import com.nspl.app.service.PropertiesUtilService;
import com.nspl.app.service.ReconciliationResultService;
import com.nspl.app.web.rest.dto.AWQGroupByParamsDTO;
import com.nspl.app.web.rest.dto.AWQGroupingDTO;
import com.nspl.app.web.rest.dto.AWQStatusCountsAmountsDTO;
import com.nspl.app.web.rest.dto.AWQStatusesDTO;
import com.nspl.app.web.rest.dto.CreditLineDTO;
import com.nspl.app.web.rest.dto.DebitLineDTO;
import com.nspl.app.web.rest.dto.ErrorReport;
import com.nspl.app.web.rest.dto.ErrorReporting;
import com.nspl.app.web.rest.dto.ManualAccDTO;
import com.nspl.app.web.rest.dto.ManualAccountingDTO;
import com.nspl.app.web.rest.dto.ManualUnRecByColumnDTO;
import com.nspl.app.web.rest.dto.RWQDataFetchDTO;
import com.nspl.app.web.rest.dto.ReconQueryParamsDTO;
import com.nspl.app.web.rest.dto.RowIdCreditDebitDTO;
import com.nspl.app.web.rest.dto.RowIdCreditsDebitsDTO;
import com.nspl.app.web.rest.util.HeaderUtil;
import com.nspl.app.web.rest.util.PaginationUtil;

/**
 * REST controller for managing AccountingData.
 */
@RestController
@RequestMapping("/api")
public class AccountingDataResource {

	private final Logger log = LoggerFactory
			.getLogger(AccountingDataResource.class);

	private static final String ENTITY_NAME = "accountingData";

	private final AccountingDataRepository accountingDataRepository;

	private final AccountingDataSearchRepository accountingDataSearchRepository;

	@Inject
	AccountingDataService accountingDataService;

	@Inject
	DataMasterRepository dataMasterRepository;

	@Inject
	ReconciliationResultService reconciliationResultService;

	@Inject
	RuleGroupDetailsRepository ruleGroupDetailsRepository;

	@Inject
	LookUpCodeRepository lookUpCodeRepository;

	@Inject
	RulesRepository rulesRepository;

	@Inject
	RuleGroupRepository ruleGroupRepository;

	@Inject
	RuleGroupResource ruleGroupResource;

	@Inject
	AcctRuleConditionsRepository acctRuleConditionsRepository;

	@Inject
	AccountingLineTypesRepository accountingLineTypesRepository;

	@Inject
	DataViewsColumnsRepository dataViewsColumnsRepository;

	@Inject
	DataViewsRepository dataViewsRepository;

	@Inject
	AccountedSummaryRepository accountedSummaryRepository;

	@Inject
	FileTemplateLinesRepository fileTemplateLinesRepository;

	@Inject
	PropertiesUtilService propertiesUtilService;
	
	@Inject
	AppModuleSummaryRepository appModuleSummaryRepository;

	@Inject
	FileService fileService;

	@PersistenceContext(unitName = "default")
	private EntityManager em;

	public AccountingDataResource(
			AccountingDataRepository accountingDataRepository,
			AccountingDataSearchRepository accountingDataSearchRepository) {
		this.accountingDataRepository = accountingDataRepository;
		this.accountingDataSearchRepository = accountingDataSearchRepository;
	}

	/**
	 * POST /accounting-data : Create a new accountingData.
	 *
	 * @param accountingData
	 *            the accountingData to create
	 * @return the ResponseEntity with status 201 (Created) and with body the
	 *         new accountingData, or with status 400 (Bad Request) if the
	 *         accountingData has already an ID
	 * @throws URISyntaxException
	 *             if the Location URI syntax is incorrect
	 */
	@PostMapping("/accounting-data")
	@Timed
	public ResponseEntity<AccountingData> createAccountingData(
			@RequestBody AccountingData accountingData)
			throws URISyntaxException {
		log.debug("REST request to save AccountingData : {}", accountingData);
		if (accountingData.getId() != null) {
			return ResponseEntity
					.badRequest()
					.headers(
							HeaderUtil
									.createFailureAlert(ENTITY_NAME,
											"idexists",
											"A new accountingData cannot already have an ID"))
					.body(null);
		}
		AccountingData result = accountingDataRepository.save(accountingData);
		accountingDataSearchRepository.save(result);
		return ResponseEntity
				.created(new URI("/api/accounting-data/" + result.getId()))
				.headers(
						HeaderUtil.createEntityCreationAlert(ENTITY_NAME,
								result.getId().toString())).body(result);
	}

	/**
	 * PUT /accounting-data : Updates an existing accountingData.
	 *
	 * @param accountingData
	 *            the accountingData to update
	 * @return the ResponseEntity with status 200 (OK) and with body the updated
	 *         accountingData, or with status 400 (Bad Request) if the
	 *         accountingData is not valid, or with status 500 (Internal Server
	 *         Error) if the accountingData couldnt be updated
	 * @throws URISyntaxException
	 *             if the Location URI syntax is incorrect
	 */
	@PutMapping("/accounting-data")
	@Timed
	public ResponseEntity<AccountingData> updateAccountingData(
			@RequestBody AccountingData accountingData)
			throws URISyntaxException {
		log.debug("REST request to update AccountingData : {}", accountingData);
		if (accountingData.getId() == null) {
			return createAccountingData(accountingData);
		}
		AccountingData result = accountingDataRepository.save(accountingData);
		accountingDataSearchRepository.save(result);
		return ResponseEntity
				.ok()
				.headers(
						HeaderUtil.createEntityUpdateAlert(ENTITY_NAME,
								accountingData.getId().toString()))
				.body(result);
	} 

	/**
	 * GET /accounting-data : get all the accountingData.
	 *
	 * @param pageable
	 *            the pagination information
	 * @return the ResponseEntity with status 200 (OK) and the list of
	 *         accountingData in body
	 */
	@GetMapping("/accounting-data")
	@Timed
	public ResponseEntity<List<AccountingData>> getAllAccountingData(
			@ApiParam Pageable pageable) {
		log.debug("REST request to get a page of AccountingData");
		Page<AccountingData> page = accountingDataRepository.findAll(pageable);
		HttpHeaders headers = PaginationUtil.generatePaginationHttpHeaders(
				page, "/api/accounting-data");
		return new ResponseEntity<>(page.getContent(), headers, HttpStatus.OK);
	}

	/**
	 * GET /accounting-data/:id : get the "id" accountingData.
	 *
	 * @param id
	 *            the id of the accountingData to retrieve
	 * @return the ResponseEntity with status 200 (OK) and with body the
	 *         accountingData, or with status 404 (Not Found)
	 */
	@GetMapping("/accounting-data/{id}")
	@Timed
	public ResponseEntity<AccountingData> getAccountingData(
			@PathVariable Long id) {
		log.debug("REST request to get AccountingData : {}", id);
		AccountingData accountingData = accountingDataRepository.findOne(id);
		return ResponseUtil.wrapOrNotFound(Optional.ofNullable(accountingData));
	}

	/**
	 * DELETE /accounting-data/:id : delete the "id" accountingData.
	 *
	 * @param id
	 *            the id of the accountingData to delete
	 * @return the ResponseEntity with status 200 (OK)
	 */
	@DeleteMapping("/accounting-data/{id}")
	@Timed
	public ResponseEntity<Void> deleteAccountingData(@PathVariable Long id) {
		log.debug("REST request to delete AccountingData : {}", id);
		accountingDataRepository.delete(id);
		accountingDataSearchRepository.delete(id);
		return ResponseEntity
				.ok()
				.headers(
						HeaderUtil.createEntityDeletionAlert(ENTITY_NAME,
								id.toString())).build();
	}

	/**
	 * SEARCH /_search/accounting-data?query=:query : search for the
	 * accountingData corresponding to the query.
	 *
	 * @param query
	 *            the query of the accountingData search
	 * @param pageable
	 *            the pagination information
	 * @return the result of the search
	 */
	@GetMapping("/_search/accounting-data")
	@Timed
	public ResponseEntity<List<AccountingData>> searchAccountingData(
			@RequestParam String query, @ApiParam Pageable pageable) {
		log.debug(
				"REST request to search for a page of AccountingData for query {}",
				query);
		Page<AccountingData> page = accountingDataSearchRepository.search(
				queryStringQuery(query), pageable);
		HttpHeaders headers = PaginationUtil
				.generateSearchPaginationHttpHeaders(query, page,
						"/api/_search/accounting-data");
		return new ResponseEntity<>(page.getContent(), headers, HttpStatus.OK);
	}

	/*
	 * Author: Shiva
	 * 
	 * @param ManualAccountingData, tenantId Description: Posting Manual
	 * Accounting Data
	 * 
	 * @return ErrorReport
	 */
	@PostMapping("/postManualAccountingData")
	@Timed
	public ErrorReport postManualAccountingData(
			@RequestBody ManualAccDTO manualAccDTO,
			@RequestParam Long tenantId, @RequestParam Long userId) {
		log.info("Rest api for posting manual accounted data");
		ErrorReport errorReport = new ErrorReport();
		Long viewId = manualAccDTO.getViewId();
		List<RowIdCreditDebitDTO> rows = manualAccDTO.getRows();
		if (rows.size() > 0) {
			List<AccountingData> allRecords = new ArrayList<AccountingData>();
			for (RowIdCreditDebitDTO row : rows) {
				String[] credit = row.getCredit().toString().split("\\-");
				String[] debit = row.getDebit().toString().split("\\-");
				if (credit.length > 0 && debit.length > 0) {
					AccountingData creditAD = new AccountingData();
					AccountingData debitAD = new AccountingData();

					creditAD.setTenantId(tenantId);
					creditAD.setOriginalRowId(row.getRowId());
					creditAD.setLineType("CREDIT");
					creditAD.setCreatedBy(userId);
					creditAD.setCreatedDate(ZonedDateTime.now());
					creditAD.setLastUpdatedBy(userId);
					creditAD.setLastUpdatedDate(ZonedDateTime.now());
					creditAD.setStatus("ACCOUNTED");
					creditAD.setAcctRuleId(null);
					creditAD.setOriginalViewId(manualAccDTO.getViewId());
					creditAD.setCoaRef(row.getCoaRef());
					creditAD.setAcctGroupId(manualAccDTO.getGroupId());
					for (int i = 0; i < credit.length; i++) {
						if (i == 0) {
							creditAD.setAccountingRef1(credit[i]);
						} else if (i == 1) {
							creditAD.setAccountingRef2(credit[i]);
						} else if (i == 2) {
							creditAD.setAccountingRef3(credit[i]);
						} else if (i == 3) {
							creditAD.setAccountingRef4(credit[i]);
						} else if (i == 4) {
							creditAD.setAccountingRef5(credit[i]);
						} else if (i == 5) {
							creditAD.setAccountingRef6(credit[i]);
						} else if (i == 6) {
							creditAD.setAccountingRef7(credit[i]);
						} else if (i == 7) {
							creditAD.setAccountingRef8(credit[i]);
						} else if (i == 8) {
							creditAD.setAccountingRef9(credit[i]);
						} else if (i == 9) {
							creditAD.setAccountingRef10(credit[i]);
						}
					}
					for (int i = 0; i < debit.length; i++) {
						if (i == 0) {
							debitAD.setAccountingRef1(debit[i]);
						} else if (i == 1) {
							debitAD.setAccountingRef2(debit[i]);
						} else if (i == 2) {
							debitAD.setAccountingRef3(debit[i]);
						} else if (i == 3) {
							debitAD.setAccountingRef4(debit[i]);
						} else if (i == 4) {
							debitAD.setAccountingRef5(debit[i]);
						} else if (i == 5) {
							debitAD.setAccountingRef6(debit[i]);
						} else if (i == 6) {
							debitAD.setAccountingRef7(debit[i]);
						} else if (i == 7) {
							debitAD.setAccountingRef8(debit[i]);
						} else if (i == 8) {
							debitAD.setAccountingRef9(debit[i]);
						} else if (i == 9) {
							debitAD.setAccountingRef10(debit[i]);
						}
					}
					debitAD.setTenantId(tenantId);
					debitAD.setOriginalRowId(row.getRowId());
					debitAD.setLineType("DEBIT");
					debitAD.setCreatedBy(userId);
					debitAD.setCreatedDate(ZonedDateTime.now());
					debitAD.setLastUpdatedBy(userId);
					debitAD.setLastUpdatedDate(ZonedDateTime.now());
					debitAD.setStatus("ACCOUNTED");
					debitAD.setAcctRuleId(null);
					debitAD.setOriginalViewId(manualAccDTO.getViewId());
					debitAD.setCoaRef(row.getCoaRef());
					debitAD.setAcctGroupId(manualAccDTO.getGroupId());
					AccountedSummary accSummary = accountedSummaryRepository
							.findByRowIdAndRuleGroupIdAndViewId(row.getRowId(),
									manualAccDTO.getGroupId(),
									manualAccDTO.getViewId());
					if (accSummary != null) {
						AccountingData adCredit = accountingDataRepository
								.findByTenantIdAndOriginalRowIdAndLineTypeAndOriginalViewIdAndAcctGroupIdAndJobReference(
										tenantId, row.getRowId(), "Credit",
										manualAccDTO.getViewId(),
										manualAccDTO.getGroupId(),
										accSummary.getJobReference());
						AccountingData adDebit = accountingDataRepository
								.findByTenantIdAndOriginalRowIdAndLineTypeAndOriginalViewIdAndAcctGroupIdAndJobReference(
										tenantId, row.getRowId(), "Debit",
										manualAccDTO.getViewId(),
										manualAccDTO.getGroupId(),
										accSummary.getJobReference());
						if (adCredit != null) {// Updating credit record
							creditAD.setId(adCredit.getId());
							accountingDataRepository.save(creditAD);
						}
						if (adDebit != null) {// Updating debit record
							debitAD.setId(adDebit.getId());
							accountingDataRepository.save(debitAD);
						}
					}
					allRecords.add(creditAD);
					allRecords.add(debitAD);
				}
			}
			List<AccountingData> dataPosting = accountingDataRepository
					.save(allRecords);
			log.info(dataPosting.size() + " Records Posted.");
		}
		return errorReport;
	}

	/**
	 * Author: Shiva
	 * 
	 * @param orginalRowIds
	 *            , tenantId Description: Processing Manual Un-Accounting Data
	 * @return ErrorReport
	 */
	@PostMapping("/processManualUnAccountingData")
	@Timed
	public ErrorReporting processManualUnAccountingData(
			@RequestBody List<Long> orginalRowIds, @RequestParam Long tenantId,
			@RequestParam Long dataViewId, @RequestParam Long groupId)
			throws URISyntaxException {
		log.info("Rest api for processing manual un accounting data");
		ErrorReporting errorReport = new ErrorReporting();
		List<String> reasons = new ArrayList<String>();
		try {
			if (orginalRowIds.size() > 0) {
				List<BigInteger> accntingIds = accountingDataRepository
						.fetchIdsByOriginalRowIdsAndTenantidAndViewIdAndGroupId(
								orginalRowIds, tenantId, dataViewId, groupId);
				if (accntingIds.size() > 0) {
					for (BigInteger id : accntingIds) {
						accountingDataRepository.delete(id.longValue());
					}
				}
			}
		} catch (Exception e) {
			log.info("Exception: " + e);
		}
		return errorReport;
	}

	/**
	 * Author: Shiva Description: Api to fetch columns Aligns
	 * 
	 * @param viewName
	 * @return
	 * @throws ClassNotFoundException
	 * @throws SQLException
	 */
	@GetMapping("/getAccountingColumnAlignmentInfo")
	@Timed
	public HashMap getAccountingColumnAlignmentInfo(
			@RequestParam Long tenantId, @RequestParam Long groupId,
			@RequestParam Long viewId) throws ClassNotFoundException,
			SQLException {
		log.info("Rest api to fetching Recon view columns alignments details for the view id: "
				+ viewId + ", group id: " + groupId + ", tenantId: " + tenantId);
		HashMap finalMap = new HashMap();
		finalMap.put("viewId", viewId);
		List<HashMap> cols = accountingDataService.getAccColsAlignInfo(viewId,
				groupId, tenantId);
		finalMap.put("columns", cols);
		return finalMap;
	}

	// Accounting Work Queue New Form API's
	/**
	 * Author: Shiva Purpose: Fetching AWQ Header Parameters List Params:
	 * tenantId, groupId Result: HashMap with AWQ header parameters list Date:
	 * 11-12-2017
	 */
	@GetMapping("/getAccHeaderParamsList")
	@Timed
	public HashMap getReconHeaderParamsList(@RequestParam Long tenantId,@RequestParam Long groupId) {
		log.info("Rest API for fetching AWQ Header Parameters List for tenant id: "+ tenantId + ", And rule group id: " + groupId);
		HashMap finalMap = new HashMap();
		RuleGroup ruleGrp = ruleGroupRepository.findOne(groupId);
		if (ruleGrp != null) {
			finalMap.put("tenantId", tenantId);
			finalMap.put("ruleGroupId", groupId);
			finalMap.put("ruleGroupName", ruleGrp.getName());

			// Fetching Batch Names
			List<String> batchNames = new ArrayList<String>();
			/*
			 * batchNames = reconciliationResultService.getBatchNames(tenantId,
			 * groupId);
			 */
			batchNames = accountingDataRepository.fetchDistinctBatches(tenantId, groupId);
			finalMap.put("batchNames", batchNames);

			// Fetching data views
			List<HashMap> dataViews = new ArrayList<HashMap>();
			/*
			 * List<BigInteger> viewIds =
			 * accountingLineTypesRepository.fetchDataViewIdsByTenantIdAndRuleId
			 * (tenantId, groupId);
			 */
			HashMap<String, List<BigInteger>> distinctViewIdMap = reconciliationResultService.getDistinctDVIdsforRuleGrp(groupId, tenantId);
			List<BigInteger> viewIds = distinctViewIdMap.get("sourceViewIds");
			if (viewIds.size() > 0) {
				for (BigInteger id : viewIds) {
					HashMap mp = new HashMap();
					DataViews dv = dataViewsRepository.findOne(id.longValue());
					if (dv != null) {
						mp.put("id", dv.getId());
						mp.put("viewName", dv.getDataViewDispName());
					}
					dataViews.add(mp);
				}
			} else {
				log.info("No View Ids found for the tenant id: " + tenantId + ", rule group id: " + groupId);
			}
			finalMap.put("dataViews", dataViews);
		}
		return finalMap;
	}

	//API After NVV discussion on form changes
	@PostMapping("/getDistinctStatusSummaryInfo")
	@Timed
	public HashMap getDistinctStatusSummaryInfo(@RequestBody AWQStatusCountsAmountsDTO params) throws ClassNotFoundException, SQLException, org.json.simple.parser.ParseException
	{
		log.info("Rest api for fetching counts and amounts for distinct status for the view id: "+params.getViewId()+", group id: "+ params.getRuleGroupId());
		HashMap finalMap = new HashMap();
		ErrorReporting errorReport = new ErrorReporting();
		List<HashMap> summaryList = new ArrayList<HashMap>();
		List<String> reasons = new ArrayList<String>();
		//Fetching distinct status from accounted summary table
		List<String> distStatus = new ArrayList<String>();
		distStatus = accountedSummaryRepository.fetchDistinctStatusByGroupIdNViewId(params.getRuleGroupId(), params.getViewId());
		distStatus.remove("UNACCOUNTED");
		Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
		String currencyFormat = props.getProperty("currencyFormat");
		List<BigInteger> accountingIds = new ArrayList<BigInteger>();
		log.info("Distinct statuses: "+ distStatus);
		DataViews dv = dataViewsRepository.findOne(params.getViewId());
		String amountQualifier = reconciliationResultService.getViewColumnQualifier(BigInteger.valueOf(params.getViewId()), "AMOUNT");
		String sCurrencyCode = reconciliationResultService.getTransDateQualifier(BigInteger.valueOf(params.getViewId()), "CURRENCYCODE");
		List<BigInteger> totalIds = new ArrayList<BigInteger>();
		if(amountQualifier.length()>0 && sCurrencyCode.length()>0)
		{
			HashMap sTotalIdsMap = reconciliationResultService.getTotalByPeriodFactor(params.getViewId(), params.getPeriodFactor(), params.getRangeFrom(), params.getRangeTo());
			totalIds = (List<BigInteger>) sTotalIdsMap.get("totalIds");
			if(totalIds.size()>0)
			{
				if(distStatus.size()>0)
				{
					for(String status : distStatus)
					{
						HashMap statusMp = new HashMap();
						statusMp.put("status", status);
						List<BigInteger> statusIds = new ArrayList<BigInteger>();
						statusIds = accountedSummaryRepository.fetchAccountingIdsByStatusNGroupIdNViewId(params.getRuleGroupId(), params.getViewId(), status);
						if(statusIds.size()>0)
						{
					  		String sRecCurrencySymbol = "";
					  		List<String> sRecCurrencies = reconciliationResultService.getDistColumnValues(statusIds,sCurrencyCode,dv.getDataViewName());
					  		if(sRecCurrencies.size()==1)
					  		{
					  			sRecCurrencySymbol = sRecCurrencySymbol + reconciliationResultService.getCurrencySymbol(sRecCurrencies.get(0));
					  		}
					  		else if(sRecCurrencies.size()>1)
					  		{
					  			sRecCurrencySymbol = sRecCurrencySymbol+"*";
					  		}

							HashMap countNAmount = reconciliationResultService.getCountNAmountForDVId(BigInteger.valueOf(params.getViewId()), params.getTenantId(), amountQualifier,statusIds);
							statusMp.put("amount", sRecCurrencySymbol+" "+reconciliationResultService.getAmountInFormat(countNAmount.get("totalAmount").toString(),currencyFormat));
							statusMp.put("count", countNAmount.get("totalCount"));
						}
						accountingIds.addAll(statusIds);
						summaryList.add(statusMp);
					}
				}
				else
				{
					log.info("No distinct statuses found for the group id: "+ params.getRuleGroupId()+", view id: "+params.getViewId());
				}
				List<BigInteger> unAccIds = new ArrayList<BigInteger>();
				for(BigInteger id : totalIds)
				{
					if(!accountingIds.contains(id))
					{
						unAccIds.add(id);
					}
				}
				if(unAccIds.size()>0)
				{
					HashMap unAccMap = new HashMap();
					unAccMap.put("status", "UNACCOUNTED");
					
			  		String sRecCurrencySymbol = "";
			  		List<String> sRecCurrencies = reconciliationResultService.getDistColumnValues(unAccIds,sCurrencyCode,dv.getDataViewName());
			  		if(sRecCurrencies.size()==1)
			  		{
			  			sRecCurrencySymbol = sRecCurrencySymbol + reconciliationResultService.getCurrencySymbol(sRecCurrencies.get(0));
			  		}
			  		else if(sRecCurrencies.size()>1)
			  		{
			  			sRecCurrencySymbol = sRecCurrencySymbol+"*";
			  		}

					HashMap countNAmount = reconciliationResultService.getCountNAmountForDVId(BigInteger.valueOf(params.getViewId()), params.getTenantId(), amountQualifier,unAccIds);
					unAccMap.put("amount", sRecCurrencySymbol+" "+reconciliationResultService.getAmountInFormat(countNAmount.get("totalAmount").toString(),currencyFormat));
					unAccMap.put("count", countNAmount.get("totalCount"));
					summaryList.add(unAccMap);
				}
			}
			else
			{
				log.info("There are no records found in given range");
			}
		}
		else 
		{
			log.info("No amount or currency code qualifier found for the view id: "+ params.getViewId());
		}
		errorReport.setStatus("");
		errorReport.setReasons(reasons);
		finalMap.put("summary", summaryList);
		finalMap.put("info", errorReport);
		return finalMap;
	}
	
	// AWQ New Form API's Modified API
	/**
	 * Author: Shiva Purpose: Fetching Accounting data counts and amounts for
	 * group by field
	 * @throws ClassNotFoundException
	 * @throws SQLException
	 * **/
	@GetMapping("/getAccountingGroupByAnalytics")
	@Timed
	public HashMap getAccountingGroupByAnalytics(@RequestParam Long tenantId,@RequestParam Long groupId,@RequestParam String rangeFrom,	@RequestParam String rangeTo,	@RequestParam String groupBy,
			@RequestParam(value = "sourceViewId", required = false) Long sourceViewId,	@RequestParam(value = "columnId", required = false) Long columnId)
			throws ClassNotFoundException, SQLException {
		log.info("Rest api for getting accounting group by summary data for the tenant id: "+ tenantId	+ ", group id: "	+ groupId	+ ", view id: "	+ sourceViewId);
		HashMap finalMap = new HashMap();
		List<HashMap> groupedList = new ArrayList<HashMap>();
		RuleGroup rg = ruleGroupRepository.findOne(groupId);
		finalMap.put("ruleGroupId", rg.getId());
		finalMap.put("ruleGroupName", rg.getName());
		finalMap.put("groupBy", groupBy);
		if ("process".equalsIgnoreCase(groupBy)) {
			log.info("Fetching acounting data counts and amounts for the grouped by PROCESS for the group id: "	+ groupId);
			HashMap<String, List<BigInteger>> distinctViewIdMap = reconciliationResultService.getDistinctDVIdsforRuleGrp(groupId, tenantId);
			List<BigInteger> viewIds = distinctViewIdMap.get("sourceViewIds");
			log.info("Source ViewIds: " + viewIds);
			if (viewIds.size() > 0) {
				for (BigInteger viewId : viewIds) {
					DataViews dv = dataViewsRepository.findOne(viewId.longValue());
					if (dv != null) {
						String transDateQualifier = reconciliationResultService.getViewColumnQualifier(viewId, "TRANSDATE");
						String amountQualifier = reconciliationResultService.getViewColumnQualifier(viewId, "AMOUNT");
						log.info("View Id: " + viewId+ ", Trans Date Qualifier: "+ transDateQualifier + ", Amount Qualifier: "+ amountQualifier);
						if (transDateQualifier.length() > 0 && amountQualifier.length() > 0) {
							Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getAccOriginalIdsStatusWise(tenantId,groupId, viewId, rangeFrom,rangeTo, transDateQualifier);
							if (accUnAccIds.size() > 0) {
								HashMap viewMp = accountingDataService.getAllGroupedListAnalytics(accUnAccIds, tenantId, viewId,amountQualifier);
								viewMp.put("name", dv.getDataViewDispName());
								viewMp.put("id", viewId);
								groupedList.add(viewMp);
							}
						} else {
							log.info("There is no trans date or amount qualifier found for the view id: "+ viewId);
						}
					}
				}
				finalMap.put("groupedList", groupedList);
			} else {
				log.info("There are no source view ids for the group id: "+ groupId);
			}
			log.info("Final Map Size: " + groupedList.size());
		} else {
			String transDateQualifier = reconciliationResultService.getViewColumnQualifier(new BigInteger(sourceViewId.toString()),"TRANSDATE");
			String amountQualifier = reconciliationResultService.getViewColumnQualifier(new BigInteger(sourceViewId.toString()), "AMOUNT");
			log.info("Amount Qualifier: " + amountQualifier	+ ", Trans Date Qualifier: " + transDateQualifier);
			if (transDateQualifier.length() > 0 && amountQualifier.length() > 0) {
				if ("columnName".equalsIgnoreCase(groupBy)) {
					log.info("Fetching accounting counts and amounts grouped by column name without fileted group by for the view id: "	+ sourceViewId);
					HashMap columnMap = accountingDataService.getDataViewColumnNameByColumnId(columnId);
					if (columnMap.get("columnName").toString().length() > 0	&& columnMap.get("dataType") != null) {
						List<String> distColValues = reconciliationResultService.getDistinctColValues(sourceViewId, rangeFrom,rangeTo, columnId,"fileDate");
						if (distColValues.size() > 0) {
							for (String colValue : distColValues) {
								List<BigInteger> totalIds = reconciliationResultService.getOriginalIdsByTransDate(sourceViewId, rangeFrom,rangeTo,columnMap.get("columnName").toString(), colValue.trim(),columnMap.get("dataType").toString(),"fileDate");
								Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getAccountingIdsByOriginalIds(totalIds,tenantId,groupId,new BigInteger(sourceViewId.toString()),rangeFrom, rangeTo);
								if (accUnAccIds.size() > 0) {
									HashMap colMp = accountingDataService.getGroupedListAnalytics(accUnAccIds,tenantId,new BigInteger(sourceViewId.toString()),amountQualifier);
									if (colMp.size() > 0) {
										colMp.put("name", colValue);
										groupedList.add(colMp);
									}
								}
							}
						}
					}
					finalMap.put("groupedList", groupedList);
				} else if ("rules".equalsIgnoreCase(groupBy)) {
					log.info("Fetching accounting counts and amounts groupBy rules without filtered group for the view id: "+ sourceViewId);
					List<BigInteger> ruleIds = accountingDataRepository.fetchRuleIdsByGroupIdAndTenantId(tenantId, groupId);
					log.info("RuleIds: " + ruleIds);
					if (ruleIds.size() > 0) {
						for (BigInteger ruleId : ruleIds) {
							List<BigInteger> ruleIdSingle = new ArrayList<BigInteger>();
							ruleIdSingle.add(ruleId);
							Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getAccountingIdsGroupByRules(tenantId,groupId, new BigInteger(sourceViewId.toString()),rangeFrom, rangeTo, ruleIdSingle);
							if (accUnAccIds.get("totalIds").size() > 0) {
								HashMap ruleMap = accountingDataService.getRulesGroupedList(accUnAccIds,tenantId,new BigInteger(sourceViewId.toString()),amountQualifier);
								if (ruleMap.size() > 0) {
									Rules rule = rulesRepository.findOne(ruleId.longValue());
									if (rule != null) {
										ruleMap.put("name", rule.getRuleCode());
										ruleMap.put("id", ruleId);
									}
									if (ruleId == BigInteger.valueOf(0)) {
										ruleMap.put("name", "Manual");
										ruleMap.put("id", ruleId);
									}
									groupedList.add(ruleMap);
								}
							}
						}
						// Others
						Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getOthersInfo(groupId,BigInteger.valueOf(sourceViewId),rangeFrom, rangeTo, transDateQualifier);
						if (accUnAccIds.get("totalIds").size() > 0) {
							HashMap othersMap = accountingDataService.getAllGroupedListAnalytics(accUnAccIds,tenantId, new BigInteger(sourceViewId.toString()),amountQualifier);
							othersMap.put("name", "Others");
							groupedList.add(othersMap);
						}
					}
					finalMap.put("groupedList", groupedList);
				} else if ("batch".equalsIgnoreCase(groupBy)) {
					List<BigInteger> totalIds = reconciliationResultService.getViewOriginalIds(sourceViewId.longValue(),rangeFrom, rangeTo, transDateQualifier);
					if (totalIds.size() > 0) {
						List<String> batches = accountingDataRepository.fetchDistinctBatches(tenantId, groupId);
						if (batches.size() > 0) {
							List<String> manualBatches = new ArrayList<String>();
							for (String batch : batches) {
								if (batch.contains("MANUAL")) {
									manualBatches.add(batch);
								} else {
									List<String> batchList = new ArrayList<String>();
									batchList.add(batch.trim());
									Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getAccountingIdsByOriginalBatches(totalIds,tenantId,groupId,new BigInteger(sourceViewId.toString()),rangeFrom, rangeTo,batchList);
									HashMap batchMap = accountingDataService.getGroupedListAnalytics(accUnAccIds,tenantId,new BigInteger(sourceViewId.toString()),amountQualifier);
									if (batchMap.size() > 0) {
										batchMap.put("name", batch);
										groupedList.add(batchMap);
									}
								}
							}
							if (manualBatches.size() > 0) {
								Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getAccountingIdsByManualBatches(totalIds,tenantId,groupId,new BigInteger(sourceViewId.toString()),rangeFrom, rangeTo,manualBatches);
								HashMap batchMap = accountingDataService.getGroupedListAnalytics(accUnAccIds,tenantId,new BigInteger(sourceViewId.toString()),amountQualifier);
								if (batchMap.size() > 0) {
									batchMap.put("name", "Manual");
									groupedList.add(batchMap);
								}
							}
							// Others
							Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getOthersInfo(groupId,BigInteger.valueOf(sourceViewId),rangeFrom, rangeTo,transDateQualifier);
							if (accUnAccIds.get("totalIds").size() > 0) {
								HashMap othersMap = accountingDataService.getAllGroupedListAnalytics(accUnAccIds,tenantId,new BigInteger(sourceViewId.toString()),amountQualifier);
								othersMap.put("name", "Others");
								groupedList.add(othersMap);
							}
						}
					}
					finalMap.put("groupedList", groupedList);
				}
			} else {
				log.info("There is no amount qualifier or trans date qualifier found for the view id: "+ sourceViewId);
			}
		}
		return finalMap;
	}

	/**
	 * Author: Shiva Purpose: Fetching Accounting data counts and amounts for
	 * group by field 
	 * @throws ClassNotFoundException
	 * @throws SQLException
	 * @throws ParseException
	 * **/
	@PostMapping("/getAccountingFilterGroupBySummary")
	@Timed
	public HashMap getAccountingFilterGroupBySummary(
			@RequestParam Long tenantId,
			@RequestParam Long groupId,
			@RequestParam String rangeFrom,
			@RequestParam String rangeTo,
			@RequestParam String groupBy,
			@RequestParam(value = "sourceViewId", required = false) Long sourceViewId,
			@RequestParam(value = "columnId", required = false) Long columnId,
			@RequestParam(value = "filterGroupBy", required = false) String filterGroupBy,
			@RequestBody AWQGroupByParamsDTO params)
			throws ClassNotFoundException, SQLException, ParseException {
		log.info("Rest api for fetching accounting data counts and amounts filtered group by for the tenant id: "+ tenantId+ ", group id: "+ groupId+ ", view id: "+ sourceViewId);
		HashMap finalMap = new HashMap();
		List<HashMap> groupedList = new ArrayList<HashMap>();
		RuleGroup rg = ruleGroupRepository.findOne(groupId);
		finalMap.put("ruleGroupId", rg.getId());
		finalMap.put("ruleGroupName", rg.getName());
		finalMap.put("groupBy", groupBy);
		if ("process".equalsIgnoreCase(groupBy)) {
			String transDateQualifier = reconciliationResultService.getViewColumnQualifier(BigInteger.valueOf(params.getViewId()), "TRANSDATE");
			String amountQualifier = reconciliationResultService.getViewColumnQualifier(BigInteger.valueOf(params.getViewId()), "AMOUNT");
			log.info("ViewId: " + params.getViewId()+ ", Trans date Qualifier: " + transDateQualifier+ ", Amount Qualifier: " + amountQualifier);
			if (transDateQualifier.length() > 0 && amountQualifier.length() > 0) {
				if ("days".equalsIgnoreCase(filterGroupBy)) {
					log.info("Fetching accounting data group by prceoss and filter group days for the view id: "+ params.getViewId());
					List<String> transDates = reconciliationResultService.getDistinctTransDates(params.getViewId(),rangeFrom, rangeTo, transDateQualifier);
					// log.info("Distinct Trans Dates: "+ transDates);
					if (transDates.size() > 0) {
						for (String transDate : transDates) {
							DateFormat df = new SimpleDateFormat("yyyy-MM-dd");
							Date date = df.parse(transDate);
							df = new SimpleDateFormat("dd-MMM-yy");
							Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getAccountingIdsWithTransDate(tenantId,groupId, BigInteger.valueOf(params.getViewId()), rangeFrom,rangeTo, transDateQualifier,transDate.trim());
							if (accUnAccIds.size() > 0) {
								HashMap dateMp = accountingDataService.getAllGroupedList(accUnAccIds,tenantId,new BigInteger(params.getViewId().toString()),amountQualifier);
								dateMp.put("name", df.format(date));
								groupedList.add(dateMp);
							}
						}
					}
					finalMap.put("groupedList", groupedList);
				} else if ("columnName".equalsIgnoreCase(filterGroupBy)) {
					log.info("Fetching accounting data group by prceoss and filter group by column name for the view id: "+ params.getViewId());
					HashMap columnMap = accountingDataService.getDataViewColumnNameByColumnId(params.getColumnId());
					if (columnMap.get("columnName").toString().length() > 0	&& columnMap.get("dataType") != null) {
						log.info("column name: "+ columnMap.get("columnName").toString()+ ", column data type: "+ columnMap.get("dataType"));
						List<String> distColValues = reconciliationResultService.getDistinctColValues(params.getViewId(),rangeFrom, rangeTo,params.getColumnId(),"fileDate");
						// log.info("Distinct column values sizes: "+distColValues.size());
						if (distColValues.size() > 0) {
							for (String colValue : distColValues) {
								List<BigInteger> totalIds = reconciliationResultService.getOriginalIdsByTransDate(params.getViewId(), rangeFrom,rangeTo,columnMap.get("columnName").toString(), colValue.trim(),columnMap.get("dataType").toString(),"fileDate");
								Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getAccountingIdsByOriginalIds(totalIds,tenantId,groupId,new BigInteger(params.getViewId().toString()),rangeFrom, rangeTo);
								if (accUnAccIds.size() > 0) {
									HashMap colMp = accountingDataService.getAllGroupedList(accUnAccIds,tenantId,new BigInteger(params.getViewId().toString()),amountQualifier);
									colMp.put("name", colValue);
									groupedList.add(colMp);
								}
							}
						}
					}
					finalMap.put("groupedList", groupedList);
				} else if ("rules".equalsIgnoreCase(filterGroupBy)) {
					log.info("Fetching accounting data group by prceoss and filter group by rules for the view id: "+ params.getViewId());
					List<BigInteger> ruleIds = accountingDataRepository.fetchRuleIdsByGroupIdAndTenantId(tenantId, groupId);
					log.info("RuleIds: " + ruleIds);
					if (ruleIds.size() > 0) {
						for (BigInteger ruleId : ruleIds) {
							log.info("Rule Id: " + ruleId);
							List<BigInteger> ruleIdSingle = new ArrayList<BigInteger>();
							ruleIdSingle.add(ruleId);
							Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getAccountingIdsGroupByRules(tenantId,groupId, BigInteger.valueOf(params.getViewId()), rangeFrom,	rangeTo, ruleIdSingle);
							if (accUnAccIds.size() > 0) {
								HashMap ruleMap = accountingDataService.getGroupedList(accUnAccIds, tenantId,BigInteger.valueOf(params.getViewId()),amountQualifier);
								if (ruleMap.size() > 0) {
									Rules rule = rulesRepository.findOne(ruleId.longValue());
									if (rule != null) {
										ruleMap.put("name", rule.getRuleCode());
										ruleMap.put("id", ruleId);
									} else if (ruleId == BigInteger.valueOf(0)) {
										ruleMap.put("name", "Manual");
										ruleMap.put("id", ruleId);
									}
									groupedList.add(ruleMap);
								}
							}
						}
						//Others Batch
						Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getUnAccOthersMap(params.getViewId(), tenantId, groupId, rangeFrom, rangeTo, "");
						HashMap unRecMap = accountingDataService.getUnAccGroupedList(accUnAccIds, tenantId,BigInteger.valueOf(params.getViewId()),amountQualifier);
						if(unRecMap.size()>0)
						{
							unRecMap.put("name", "Others");
							groupedList.add(unRecMap);
						}
					}
					else
					{
						Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getUnAccMap(params.getViewId(), tenantId, groupId, rangeFrom, rangeTo, "");
						HashMap unRecMap = accountingDataService.getUnAccGroupedList(accUnAccIds, tenantId,BigInteger.valueOf(params.getViewId()),amountQualifier);
						if(unRecMap.size()>0)
						{
							unRecMap.put("name", "Others");
							groupedList.add(unRecMap);
						}
						//finalList = reconciliationResultService.getReconData(recUnrecIds, params.getStatus(), tenantId, dataViewId, limit, pageSize, headerColumns, groupId, amtQualifier,params.getSearchWord(),columnsString,exportFile,colNameNType,params.getSortOrderBy());
					}
					finalMap.put("groupedList", groupedList);
				} else if ("batch".equalsIgnoreCase(filterGroupBy)) {
					log.info("Fetching accounting data group by prceoss and filter group by batches for the view id: "+ params.getViewId());
					List<String> batches = accountingDataRepository.fetchDistinctBatches(tenantId, groupId);
					List<String> manualBatches = new ArrayList<String>();
					log.info("Batches size: " + batches.size());
					if (batches.size() > 0) {
						for (String batch : batches) {
							List<String> jobReferences = new ArrayList<String>();
							jobReferences.add(batch);
							if (batch.contains("MANUAL")) {
								manualBatches.add(batch);
							} else {
								Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getAccountingIdsForBatch(tenantId,groupId, BigInteger.valueOf(params.getViewId()),rangeFrom, rangeTo,jobReferences,transDateQualifier);
								if (accUnAccIds.size() > 0) {
									HashMap batchMap = accountingDataService.getGroupedList(accUnAccIds,tenantId,BigInteger.valueOf(params.getViewId()),amountQualifier);
									if (batchMap.size() > 0) {
										batchMap.put("name", batch);
										groupedList.add(batchMap);
									}
								}
							}
						}
						if (manualBatches.size() > 0) {
							Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getAccountingIdsForManualBatchs(tenantId,groupId, BigInteger.valueOf(params.getViewId()), rangeFrom,rangeTo, transDateQualifier,manualBatches);
							if (accUnAccIds.size() > 0) {
								HashMap batchMap = accountingDataService.getGroupedList(accUnAccIds, tenantId,BigInteger.valueOf(params.getViewId()),amountQualifier);
								if (batchMap.size() > 0) {
									batchMap.put("name", "Manual");
									groupedList.add(batchMap);
								}
							}
						}
						//Others Batch
						Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getUnAccOthersMap(params.getViewId(), tenantId, groupId, rangeFrom, rangeTo, "");
						HashMap unRecMap = accountingDataService.getUnAccGroupedList(accUnAccIds, tenantId,BigInteger.valueOf(params.getViewId()),amountQualifier);
						if(unRecMap.size()>0)
						{
							unRecMap.put("name", "Others");
							groupedList.add(unRecMap);
						}
					}
					else
					{
						Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getUnAccMap(params.getViewId(), tenantId, groupId, rangeFrom, rangeTo, "");
						HashMap unRecMap = accountingDataService.getUnAccGroupedList(accUnAccIds, tenantId,BigInteger.valueOf(params.getViewId()),amountQualifier);
						if(unRecMap.size()>0)
						{
							unRecMap.put("name", "Others");
							groupedList.add(unRecMap);
						}
					}
					finalMap.put("groupedList", groupedList);
				}
			} else {
				log.info("There is no trans date or amount qualifier fournd for the view id: "+ params.getViewId());
			}
		} else {
			String transDateQualifier = reconciliationResultService.getTransDateQualifier(new BigInteger(sourceViewId.toString()),"TRANSDATE");
			String amountQualifier = reconciliationResultService.getTransDateQualifier(new BigInteger(sourceViewId.toString()), "AMOUNT");
			if ("columnName".equalsIgnoreCase(groupBy)) {
				HashMap columnMap = accountingDataService.getDataViewColumnNameByColumnId(params.getColumnId());
				if ("days".equalsIgnoreCase(filterGroupBy)) {
					log.info("Fetching accounting counts and amounts groupBy columnName and filtered group by days for the view id: "+ sourceViewId);
					if (transDateQualifier.length() > 0) {
						List<String> transDates = reconciliationResultService.getDistinctDaysWithFilteredGroupByColumnValue(sourceViewId, rangeFrom, rangeTo,transDateQualifier,params.getColumnId(),params.getColumnValue());
						if (transDates.size() > 0) {
							for (String transDate : transDates) {
								DateFormat df = new SimpleDateFormat("yyyy-MM-dd");
								Date date = df.parse(transDate);
								df = new SimpleDateFormat("dd-MMM-yy");
								List<BigInteger> totalIds = reconciliationResultService.getOriginalIdsByColumnAndTransDate(sourceViewId,rangeFrom,rangeTo,columnMap.get("columnName").toString(), params.getColumnValue(),columnMap.get("dataType").toString(),transDateQualifier, transDate);
								Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getAccountingIdsByOriginalIds(totalIds,tenantId,groupId,new BigInteger(sourceViewId.toString()),rangeFrom, rangeTo);
								if (accUnAccIds.size() > 0) {
									HashMap dateMp = accountingDataService.getAllGroupedList(accUnAccIds,tenantId,new BigInteger(sourceViewId.toString()),amountQualifier);
									dateMp.put("name", df.format(date));
									groupedList.add(dateMp);
								}
							}
						}
					}
					finalMap.put("groupedList", groupedList);
				}
			} else if ("rules".equalsIgnoreCase(groupBy)) {
				List<String> transDates = reconciliationResultService.getDistinctTransDates(sourceViewId, rangeFrom,rangeTo, transDateQualifier);
				log.info("Distinct Dates: " + transDates.size());
				// log.info("Grouping by rules... " + params.getRuleId());
				if ("days".equalsIgnoreCase(filterGroupBy)) {
					log.info("Filter group by days...");
					if (transDates.size() > 0) {
						if (params.getRuleId() != null) {
							log.info("Fetching filter group by days with respect to rules...");
							List<BigInteger> ruleIds = new ArrayList<BigInteger>();
							ruleIds.add(BigInteger.valueOf(params.getRuleId()));
							for (String transDate : transDates) {
								DateFormat df = new SimpleDateFormat("yyyy-MM-dd");
								Date date = df.parse(transDate);
								df = new SimpleDateFormat("dd-MMM-yy");
								List<String> dates = new ArrayList<String>();
								dates.add(transDate.trim());
								List<BigInteger> totalIds = reconciliationResultService.getOriginalIdsByTransDates(sourceViewId, rangeFrom,rangeTo, transDateQualifier,dates);
								Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getAccountingIdsGroupByDaysWithRule(totalIds, rangeFrom, rangeTo,sourceViewId, tenantId,groupId, transDateQualifier,"", ruleIds);
								if (accUnAccIds.size() > 0) {
									HashMap dateMp = accountingDataService.getGroupedList(accUnAccIds,tenantId,new BigInteger(sourceViewId.toString()),amountQualifier);
									if (dateMp.size() > 0) {
										dateMp.put("name", df.format(date));
										groupedList.add(dateMp);
									}
								}
							}
						} else if (params.getOthersRuleName() != null) {
							log.info("Fetching filter group by days with respect to Others...");
							for (String transDate : transDates) {
								DateFormat df = new SimpleDateFormat("yyyy-MM-dd");
								Date date = df.parse(transDate);
								df = new SimpleDateFormat("dd-MMM-yy");
								List<String> dates = new ArrayList<String>();
								dates.add(transDate.trim());
								Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getOthersInfoWithDayWise(groupId,	BigInteger.valueOf(sourceViewId),rangeFrom, rangeTo,transDateQualifier, dates);
								if (accUnAccIds.size() > 0) {
									HashMap dateMp = accountingDataService.getAllGroupedList(accUnAccIds,tenantId,new BigInteger(sourceViewId.toString()),amountQualifier);
									dateMp.put("name", df.format(date));
									groupedList.add(dateMp);
								}
							}
						}
						finalMap.put("groupedList", groupedList);
					}
				} else if ("columnName".equalsIgnoreCase(filterGroupBy)) {
					log.info("Filter group by column name...");
					HashMap columnMap = accountingDataService.getDataViewColumnNameByColumnId(params.getColumnId());
					if (columnMap.get("columnName").toString().length() > 0	&& columnMap.get("dataType") != null) {
						List<String> distColValues = reconciliationResultService.getDistinctColValues(sourceViewId, rangeFrom,rangeTo, params.getColumnId(),"fileDate");
						log.info("Distinct Column values: " + distColValues);
						if (distColValues.size() > 0) {
							if (params.getRuleId() != null) {
								log.info("Fetching filter group by column name with respect to rules...");
								List<BigInteger> ruleIds = new ArrayList<BigInteger>();
								ruleIds.add(BigInteger.valueOf(params.getRuleId()));
								for (String colValue : distColValues) {
									List<String> colValues = new ArrayList<String>();
									colValues.add(colValue.trim());
									List<BigInteger> totalIds = reconciliationResultService.getTotalIdsGroupByColumnValues(params.getColumnId(),sourceViewId, rangeFrom,rangeTo, colValues,"fileDate");
									Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getAccountingIdsGroupByDaysWithRule(totalIds, rangeFrom,rangeTo, sourceViewId,tenantId, groupId,columnMap.get("columnName").toString(), "",ruleIds);
									if (accUnAccIds.size() > 0) {
										HashMap colMp = accountingDataService.getGroupedList(accUnAccIds,tenantId,new BigInteger(sourceViewId.toString()),amountQualifier);
										if (colMp.size() > 0) {
											colMp.put("name", colValue);
											groupedList.add(colMp);
										}
									}
								}
							} else if (params.getOthersRuleName() != null) {
								log.info("Fetching filter group by column name with respect to Others...");
								for (String colValue : distColValues) {
									List<String> colValues = new ArrayList<String>();
									colValues.add(colValue.trim());
									Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getOthersInfoWithColumnWise(groupId, sourceViewId,rangeFrom, rangeTo,colValues,params.getColumnId());
									if (accUnAccIds.size() > 0) {
										HashMap colMp = accountingDataService.getGroupedList(accUnAccIds,tenantId,new BigInteger(sourceViewId.toString()),amountQualifier);
										if (colMp.size() > 0) {
											colMp.put("name", colValue);
											groupedList.add(colMp);
										}
									}
								}
							}
							finalMap.put("groupedList", groupedList);
						}
					}
				}
			} else if ("batch".equalsIgnoreCase(groupBy)) {
				log.info("Group by batch...");
				List<String> batchList = new ArrayList<String>();
				batchList.add(params.getBatchName());
				if ("days".equalsIgnoreCase(filterGroupBy)) {
					List<String> transDates = reconciliationResultService.getDistinctTransDates(sourceViewId, rangeFrom,rangeTo, transDateQualifier);
					log.info("Distinct trans dates size: " + transDates.size());
					if (transDates.size() > 0) {
						log.info("Filter group by days...");
						List<String> manualBatches = new ArrayList<String>();
						List<String> distinctBatches = accountingDataRepository.fetchDistinctBatches(tenantId, groupId);
						if (distinctBatches.size() > 0) {
							for (String batch : distinctBatches) {
								if (batch.contains("MANUAL")) {
									manualBatches.add(batch);
								}
							}
						}
						if ("Manual".equalsIgnoreCase(params.getBatchName())) {
							log.info("Fetching filter group by days for Manual.....");
							for (String transDate : transDates) {
								DateFormat df = new SimpleDateFormat("yyyy-MM-dd");
								Date date = df.parse(transDate);
								df = new SimpleDateFormat("dd-MMM-yy");
								List<String> dates = new ArrayList<String>();
								dates.add(transDate.trim());
								List<BigInteger> totalIds = reconciliationResultService.getOriginalIdsByTransDates(sourceViewId, rangeFrom,rangeTo, transDateQualifier,dates);
								if (totalIds.size() > 0
										&& manualBatches.size() > 0) {
									Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getAccIdsForManualBatches(totalIds,tenantId,groupId,new BigInteger(sourceViewId.toString()),rangeFrom, rangeTo,manualBatches);
									HashMap dateMp = accountingDataService.getAllGroupedList(accUnAccIds,tenantId,new BigInteger(sourceViewId.toString()),amountQualifier);
									if (dateMp.size() > 0) {
										dateMp.put("name", df.format(date));
										groupedList.add(dateMp);
									}
								}
							}
						} else if ("Others".equalsIgnoreCase(params.getBatchName())) {
							log.info("Fetching filter group by others for Others .....");
							for (String transDate : transDates) {
								DateFormat df = new SimpleDateFormat("yyyy-MM-dd");
								Date date = df.parse(transDate);
								df = new SimpleDateFormat("dd-MMM-yy");
								List<String> dates = new ArrayList<String>();
								dates.add(transDate.trim());
								Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getOthersInfoWithDayWise(groupId,BigInteger.valueOf(sourceViewId),rangeFrom, rangeTo,transDateQualifier, dates);
								if (accUnAccIds.size() > 0 && accUnAccIds.get("totalIds").size() > 0) {
									HashMap dateMp = accountingDataService.getAllGroupedList(accUnAccIds,tenantId,new BigInteger(sourceViewId.toString()),amountQualifier);
									if (dateMp.size() > 0) {
										dateMp.put("name", df.format(date));
										groupedList.add(dateMp);
									}
								}
							}
						} else {
							log.info("Fetching filter group by original Batches .....");
							for (String transDate : transDates) {
								DateFormat df = new SimpleDateFormat("yyyy-MM-dd");
								Date date = df.parse(transDate);
								df = new SimpleDateFormat("dd-MMM-yy");
								List<String> dates = new ArrayList<String>();
								dates.add(transDate.trim());
								List<BigInteger> totalIds = reconciliationResultService.getOriginalIdsByTransDates(sourceViewId, rangeFrom,rangeTo, transDateQualifier,dates);
								if (totalIds.size() > 0) {
									Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getAccIdsForOriginalBatches(totalIds,	tenantId,groupId,BigInteger.valueOf(sourceViewId),rangeFrom, rangeTo,batchList);
									HashMap dateMp = accountingDataService.getGroupedList(accUnAccIds,tenantId,new BigInteger(sourceViewId.toString()),amountQualifier);
									if (dateMp.size() > 0) {
										dateMp.put("name", df.format(date));
										groupedList.add(dateMp);
									}
								}
							}
						}
						finalMap.put("groupedList", groupedList);
					}
				} else if ("columnName".equalsIgnoreCase(filterGroupBy)) {
					log.info("Filter group by column name...");
					HashMap columnMap = accountingDataService.getDataViewColumnNameByColumnId(params.getColumnId());
					if (columnMap.get("columnName").toString().length() > 0	&& columnMap.get("dataType") != null) {
						List<String> distColValues = reconciliationResultService.getDistinctColValues(sourceViewId, rangeFrom,rangeTo, params.getColumnId(),"fileDate");
						if (distColValues.size() > 0) {
							if ("Manual".equalsIgnoreCase(params.getBatchName())) {
								List<String> manualBatches = new ArrayList<String>();
								List<String> distinctBatches = accountingDataRepository.fetchDistinctBatches(tenantId, groupId);
								if (distinctBatches.size() > 0) {
									for (String batch : distinctBatches) {
										if (batch.contains("MANUAL")) {
											manualBatches.add(batch);
										}
									}
								}
								log.info("Fetching filter group by column name for Manual.....");
								for (String colValue : distColValues) {
									List<String> colValues = new ArrayList<String>();
									colValues.add(colValue);
									List<BigInteger> totalIds = reconciliationResultService.getTotalIdsGroupByColumnValues(params.getColumnId(),sourceViewId, rangeFrom,rangeTo, colValues,"fileDate");
									if (totalIds.size() > 0 && manualBatches.size() > 0) {
										Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getAccountingIdsByManualBatches(totalIds,tenantId,groupId,new BigInteger(sourceViewId.toString()),rangeFrom, rangeTo,manualBatches);
										HashMap dateMp = accountingDataService.getAllGroupedList(accUnAccIds,tenantId,new BigInteger(sourceViewId.toString()),amountQualifier);
										if (dateMp.size() > 0) {
											dateMp.put("name", colValue.trim());
											groupedList.add(dateMp);
										}
									}
								}
							} else if ("Others".equalsIgnoreCase(params.getBatchName())) {
								log.info("Fetching filter group by column name for Others .....");
								for (String colValue : distColValues) {
									List<String> colValues = new ArrayList<String>();
									colValues.add(colValue);
									Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getOthersInfoWithColumnWise(groupId, sourceViewId,rangeFrom, rangeTo,colValues,params.getColumnId());
									HashMap dateMp = accountingDataService.getAllGroupedList(accUnAccIds,tenantId,new BigInteger(sourceViewId.toString()),amountQualifier);
									dateMp.put("name", colValue.trim());
									groupedList.add(dateMp);
								}
							} else {
								log.info("Fetching filter group by column name for original Batches .....");
								for (String colValue : distColValues) {
									List<String> colValues = new ArrayList<String>();
									colValues.add(colValue);
									List<BigInteger> totalIds = reconciliationResultService.getTotalIdsGroupByColumnValues(params.getColumnId(),sourceViewId, rangeFrom,rangeTo, colValues,"fileDate");
									if (totalIds.size() > 0) {
										Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getAccountingIdsByOriginalBatches(totalIds,tenantId,groupId,BigInteger.valueOf(sourceViewId),rangeFrom, rangeTo,batchList);
										HashMap dateMp = accountingDataService.getGroupedList(accUnAccIds,tenantId,	new BigInteger(sourceViewId.toString()),amountQualifier);
										if (dateMp.size() > 0) {
											dateMp.put("name", colValue.trim());
											groupedList.add(dateMp);
										}
									}
								}
							}
						}
					}
					finalMap.put("groupedList", groupedList);
				}
			}
		}
		return finalMap;
	}

	/**
	 * Author: Shiva Purpose: Fetching Grouped by accounting data
	 * 
	 * @throws ClassNotFoundException
	 * @throws SQLException
	 * @throws ParseException
	 * **/
/*	@PostMapping("/getGroupedByAccountingData")
	@Timed
	public List<LinkedHashMap> getGroupedByAccountingData(
			@RequestBody AWQGroupedByParamsDTO params)
			throws ClassNotFoundException, SQLException, ParseException {
		log.info("Rest api for fetching grouped by accounting data for tenant id: "
				+ params.getTenantId()
				+ ", group id: "
				+ params.getGroupId()
				+ ", view id: " + params.getDataViewId());
		List<LinkedHashMap> accDataWithStatus = new ArrayList<LinkedHashMap>();
		HashMap colNameNType = reconciliationResultService
				.getColNameNType(params.getSortByColumnId());
		Long limit = limit = (params.getPageNumber() * params.getPageSize() + 1) - 1;
		log.info("Limit Starting Values : " + limit);
		log.info("Page Number : " + params.getPageNumber());
		Long tenantId = params.getTenantId();
		Long groupId = params.getGroupId();
		Long viewId = params.getDataViewId();
		String rangeFrom = params.getRangeFrom();
		String rangeTo = params.getRangeTo();
		String exportFile = params.getExportFile();
		String searchWord = params.getSearchWord();
		Long pageSize = params.getPageSize();
		String transDateQualifier = reconciliationResultService
				.getViewColumnQualifier(BigInteger.valueOf(viewId), "TRANSDATE");
		String columnsString = reconciliationResultService
				.getColumnNamesAsString(viewId);
		HashMap headerColumns = accountingDataService
				.getViewColumnHeadersMapInSequence(viewId,
						params.getTenantId(), params.getGroupId(),
						params.getGroupedParamsList());
		log.info("ViewId: " + viewId + ", TransDate Qualifier: "
				+ transDateQualifier);
		if (transDateQualifier.length() > 0 && headerColumns.size() > 0) {
			if ("process".equalsIgnoreCase(params.getGroupBy())) {
				log.info("Fetching Accounting data group by proces for view id: "
						+ viewId);
				Map<String, List<BigInteger>> accUnAccIds = accountingDataService
						.getAccOriginalIdsStatusWise(tenantId, groupId,
								BigInteger.valueOf(viewId), rangeFrom, rangeTo,
								transDateQualifier);
				accDataWithStatus = accountingDataService.getAccDataWithStatus(
						accUnAccIds, params.getStatus(), tenantId, viewId,
						groupId, limit, pageSize, headerColumns, exportFile,
						columnsString, params.getSearchWord(), colNameNType);
			} else if ("columnName".equalsIgnoreCase(params.getGroupBy())) {
				log.info("Fetching accounting data grouped by column name for the view id: "
						+ params.getDataViewId());
				HashMap columnMap = accountingDataService
						.getDataViewColumnNameByColumnId(params.getColumnId());
				if (columnMap.get("columnName").toString().length() > 0
						&& columnMap.get("dataType") != null) {
					List<BigInteger> totalIdsWithColumnValue = reconciliationResultService
							.getOriginalIdsByTransDate(params.getDataViewId(),
									rangeFrom, rangeTo,
									columnMap.get("columnName").toString(),
									params.getColumnValue().trim(), columnMap
											.get("dataType").toString());
					Map<String, List<BigInteger>> accUnAccIds = accountingDataService
							.getAccountingIdsByOriginalIds(
									totalIdsWithColumnValue, tenantId, groupId,
									new BigInteger(params.getDataViewId()
											.toString()), rangeFrom, rangeTo);
					log.info("Total Ids with column values: "
							+ totalIdsWithColumnValue.size());
					accDataWithStatus = accountingDataService
							.getAccDataWithStatus(accUnAccIds,
									params.getStatus(), tenantId, viewId,
									groupId, limit, pageSize, headerColumns,
									exportFile, columnsString,
									params.getSearchWord(), colNameNType);
				}
			} else if ("rules".equalsIgnoreCase(params.getGroupBy())) {
				log.info("Fetching group by rules data...");
				
				 * Map<String, List<BigInteger>> accUnAccIds =
				 * accountingDataService
				 * .getAccountingIdsGroupByRules(tenantId,groupId,new
				 * BigInteger(
				 * params.getDataViewId().toString()),rangeFrom,rangeTo
				 * ,jobReference,ruleIds); if(accUnAccIds.size()>0) {
				 * accDataWithStatus =
				 * accountingDataService.getAccDataWithStatus(accUnAccIds,
				 * params.getStatus(), tenantId, params.getDataViewId(),
				 * groupId, limit, pageSize, headerColumns,exportFile,
				 * columnsString, params.getSearchWord()); }
				 
			} else if ("batch".equalsIgnoreCase(params.getGroupBy())) {

			}
		} else {
			log.info("There is no trans date qualifier or headerColumns found for the view id: "
					+ viewId);
			log.info("TransDate Qualifer length: "
					+ transDateQualifier.length() + ", HeaderColumns Size: "
					+ headerColumns.size());
		}
		return accDataWithStatus;
	}*/

	@PostMapping("/getFilterGroupByAccountingData")
	@Timed
	public List<LinkedHashMap> getFilterGroupByAccountingData(@RequestParam Long pageNumber,	@RequestParam Long pageSize,	@RequestParam(value = "filterGroupBy", required = false) String filterGroupBy,
															  @RequestParam(value = "exportFile", required = false) String exportFile, @RequestBody ReconQueryParamsDTO params) throws SQLException,ClassNotFoundException, ParseException {
		log.info("--------------------------------------------------Started------------------------------------------------------------");
		log.info("Rest api for fetching filtered grouped by accounting data for tenant id: "+ params.getTenantId()+ ", group id: "+ params.getGroupId() + ", view id: " + params.getDataViewId());
		List<LinkedHashMap> accDataWithStatus = new ArrayList<LinkedHashMap>();
    	ErrorReporting errorReport = new ErrorReporting();
    	List<String> reasons = new ArrayList<String>();
		Long limit =  (pageNumber * pageSize + 1) - 1;
		log.info("Page Limit: " + limit + ", Page Number : " + pageNumber);
		RWQDataFetchDTO keyValues = params.getKeyValues();
		HashMap info = new HashMap();
		Long tenantId = params.getTenantId();
		Long groupId = params.getGroupId();
		String rangeFrom = params.getRangeFrom();
		String rangeTo = params.getRangeTo();
		HashMap colNameNType = reconciliationResultService.getColNameNType(params.getSortByColumnId());
		log.info("columnName: " + colNameNType.get("columnName")+ ", data type: " + colNameNType.get("dataType"));
		AWQGroupByParamsDTO groupByParams = params.getGroupByParams();
		ManualUnRecByColumnDTO columnValues = params.getKeyValues().getColumnValues();
		if ("process".equalsIgnoreCase(params.getGroupBy())) {
			log.info("Fetching accounting data group by process...");
			String transDateQualifier = reconciliationResultService.getViewColumnQualifier(BigInteger.valueOf(groupByParams.getViewId()),"TRANSDATE");	// un use
			HashMap headerColumns = accountingDataService.getViewColumnHeadersMapInSequence(groupByParams.getViewId(), tenantId, groupId,params.getGroupedParamsList());	//un use
			List<BigInteger> totalIdsWithView = reconciliationResultService.getViewOriginalIds(groupByParams.getViewId(), rangeFrom,rangeTo, transDateQualifier);
			log.info("TotalIdsSize: " + totalIdsWithView.size());
			String columnsString = reconciliationResultService.getColumnNamesAsString(groupByParams.getViewId());
			log.info("TransDate: "+ transDateQualifier);
			if (transDateQualifier.length() > 0 && headerColumns.size() > 0 ) {	//un used
				if("days".equalsIgnoreCase(filterGroupBy)) {
					log.info("Fetching accounting data group by process and filter group by days for teh view id: "+ params.getDataViewId());
					List<BigInteger> totalIds = new ArrayList<BigInteger>();
					if (keyValues.getDays().size() > 0) {
						totalIds = reconciliationResultService.getOriginalIdsByTransDates(groupByParams.getViewId(), rangeFrom,rangeTo, transDateQualifier,keyValues.getDays());
					} else {
						totalIds.addAll(totalIdsWithView);
					}
					Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getAccountingIdsByOriginalIds(totalIds, tenantId,groupId, BigInteger.valueOf(groupByParams.getViewId()), rangeFrom, rangeTo);
					if(accUnAccIds.size()>0)
					{
						accDataWithStatus = accountingDataService.getAccDataWithStatus(accUnAccIds,params.getStatus(), tenantId,groupByParams.getViewId(), groupId, limit,pageSize, headerColumns, exportFile,columnsString, params.getSearchWord(),colNameNType,params.getSortOrderBy());
					}
				} else if ("columnName".equalsIgnoreCase(filterGroupBy)) {
					HashMap columnMap = accountingDataService.getDataViewColumnNameByColumnId(groupByParams.getColumnId());
					List<BigInteger> totalIds = new ArrayList<BigInteger>();
					if (columnValues.getColumnValues().size() > 0) {
						totalIds = reconciliationResultService.getTotalIdsGroupByColumnValues(columnValues.getColumnId(),groupByParams.getViewId(), rangeFrom,rangeTo, columnValues.getColumnValues(),"fileDate");
					} else {
						totalIds.addAll(totalIdsWithView);
					}
					Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getAccountingIdsByOriginalIds(totalIds, tenantId,groupId, new BigInteger(groupByParams.getViewId().toString()),rangeFrom, rangeTo);
					if(accUnAccIds.size()>0)
					{
						accDataWithStatus = accountingDataService.getAccDataWithStatus(accUnAccIds,params.getStatus(), tenantId,groupByParams.getViewId(), groupId, limit,pageSize, headerColumns, exportFile,columnsString, params.getSearchWord(),colNameNType,params.getSortOrderBy());	
					}
					
				} else if ("rules".equalsIgnoreCase(filterGroupBy)) {
					List<BigInteger> ruleIds = new ArrayList<BigInteger>();
					List<Long> ruleIdsLong = keyValues.getRuleIds();
					List<BigInteger> totalIds = new ArrayList<BigInteger>();
					totalIds.addAll(totalIdsWithView);
					List<BigInteger> ruleIdsList = accountingDataRepository.fetchRuleIdsByGroupIdAndTenantId(tenantId, groupId);
					if(ruleIdsList.size() == 0)
					{
						Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getUnAccMap(groupByParams.getViewId(), tenantId, groupId, rangeFrom, rangeTo, "");
						if(accUnAccIds.size()>0)
						{
							accDataWithStatus = accountingDataService.getAccDataWithStatus(accUnAccIds,params.getStatus(), tenantId,groupByParams.getViewId(), groupId,limit, pageSize, headerColumns,exportFile, columnsString,params.getSearchWord(),colNameNType,params.getSortOrderBy());
						}
					}
					else
					{
						if (ruleIdsLong.size() > 0) {
							for (Long id : ruleIdsLong) {
								ruleIds.add(new BigInteger(id.toString()));
							}
							Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getAccountingIdsGroupByRules(tenantId,groupId, new BigInteger(groupByParams.getViewId().toString()),rangeFrom, rangeTo, ruleIds);
							if (accUnAccIds.size() > 0) {
								accDataWithStatus = accountingDataService.getAccDataWithStatus(accUnAccIds,params.getStatus(), tenantId,groupByParams.getViewId(), groupId,limit, pageSize, headerColumns,exportFile, columnsString,params.getSearchWord(),colNameNType,params.getSortOrderBy());
							}
						} else {
							Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getAccountingIdsByOriginalIds(totalIds,tenantId, groupId, new BigInteger(groupByParams.getViewId().toString()),rangeFrom, rangeTo);
							if(accUnAccIds.size()>0)
							{
								accDataWithStatus = accountingDataService.getAccDataWithStatus(accUnAccIds,params.getStatus(), tenantId,groupByParams.getViewId(), groupId,limit, pageSize, headerColumns,exportFile, columnsString,params.getSearchWord(), colNameNType,params.getSortOrderBy());	
							}
						}
					}
				} else if ("batch".equalsIgnoreCase(filterGroupBy)) {
					log.info("keyValues.getBatchNames(): "+ keyValues.getBatchNames());
					List<String> batches = accountingDataRepository.fetchDistinctBatches(tenantId, groupId);
					if(batches.size() == 0)
					{
						Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getUnAccMap(groupByParams.getViewId(), tenantId, groupId, rangeFrom, rangeTo, "");
						if(accUnAccIds.size()>0)
						{
							accDataWithStatus = accountingDataService.getAccDataWithStatus(accUnAccIds,params.getStatus(), tenantId,groupByParams.getViewId(), groupId,limit, pageSize, headerColumns,exportFile, columnsString,params.getSearchWord(),colNameNType,params.getSortOrderBy());
						}
					}
					else
					{
						if (keyValues.getBatchNames().size() > 0) {
							Map<String, List<BigInteger>> accUnAccIds = new HashMap<String, List<BigInteger>>();
							if (!keyValues.getBatchNames().contains("Manual")) {
								if(keyValues.getBatchNames().contains("Others"))
								{
									accUnAccIds = accountingDataService.getUnAccOthersMap(groupByParams.getViewId(), tenantId, groupId, rangeFrom, rangeTo, "");
								}
								else{
									accUnAccIds = accountingDataService.getAccountingIdsForBatch(tenantId,groupId, BigInteger.valueOf(groupByParams.getViewId()),rangeFrom, rangeTo, keyValues.getBatchNames(),transDateQualifier);
								}
							} else if (keyValues.getBatchNames().contains("Manual")) {
								List<String> jobReferences = new ArrayList<String>();
								jobReferences = accountedSummaryRepository.fetchManualJobReferences(groupId,groupByParams.getViewId());
								log.info("Manual Batch Names: " + jobReferences);
								jobReferences.addAll(keyValues.getBatchNames());
								log.info("Input manual Batches: " + jobReferences);
								accUnAccIds = accountingDataService.getAccountingIdsForManualBatchs(tenantId,groupId, BigInteger.valueOf(groupByParams.getViewId()),rangeFrom, rangeTo,transDateQualifier, jobReferences);
							}
							if (accUnAccIds.size() > 0) {
								accDataWithStatus = accountingDataService.getAccDataWithStatus(accUnAccIds,params.getStatus(), tenantId,groupByParams.getViewId(), groupId,limit, pageSize, headerColumns,exportFile, columnsString,params.getSearchWord(),colNameNType,params.getSortOrderBy());
							}
						} else {
							Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getAccountingIdsByBatches(totalIdsWithView,tenantId, groupId, new BigInteger(groupByParams.getViewId().toString()),rangeFrom, rangeTo, keyValues.getBatchNames());
							if (accUnAccIds.size() > 0) {
								accDataWithStatus = accountingDataService.getAccDataWithStatus(accUnAccIds,params.getStatus(), tenantId,groupByParams.getViewId(), groupId,limit, pageSize, headerColumns,exportFile, columnsString,params.getSearchWord(),colNameNType,params.getSortOrderBy());
							}
						}
					}
				}
			} else {
				log.info("There is no trans date qualifier or header columns found for the view id: "+ groupByParams.getViewId());
			}
		} else if ("columnName".equalsIgnoreCase(params.getGroupBy())) {
			String transDateQualifier = reconciliationResultService.getTransDateQualifier(new BigInteger(params.getDataViewId().toString()), "TRANSDATE");
			String columnsString = reconciliationResultService.getColumnNamesAsString(params.getDataViewId());
			HashMap columnMap = accountingDataService.getDataViewColumnNameByColumnId(groupByParams.getColumnId());
			HashMap headerColumns = accountingDataService.getViewColumnHeadersMapInSequence(params.getDataViewId(),params.getTenantId(), params.getGroupId(),params.getGroupedParamsList());
			if (columnMap.get("columnName").toString().length() > 0 && columnMap.get("dataType") != null) {
				List<BigInteger> totalIdsWithColumnValue = reconciliationResultService.getOriginalIdsByTransDate(params.getDataViewId(),rangeFrom, rangeTo, columnMap.get("columnName").toString(), groupByParams.getColumnValue().trim(), columnMap.get("dataType").toString(),"fileDate");
				log.info("Total Ids with column values: "+ totalIdsWithColumnValue.size());
				if ("days".equalsIgnoreCase(filterGroupBy)) {
					log.info("Fetching accounting data grouped by column name with filtered group by daysfor the view id: "+ params.getDataViewId());
					List<BigInteger> totalIds = new ArrayList<BigInteger>();
					if (keyValues.getDays().size() > 0) {
						totalIds = reconciliationResultService.getOriginalIdsByTransDatesAndColValue(params.getDataViewId(), rangeFrom, rangeTo,columnMap.get("columnName").toString(),groupByParams.getColumnValue(),columnMap.get("dataType").toString(),transDateQualifier, keyValues.getDays());
					} else {
						totalIds.addAll(totalIdsWithColumnValue);
					}
					Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getAccountingIdsByOriginalIds(totalIds, tenantId,groupId, new BigInteger(params.getDataViewId().toString()),rangeFrom, rangeTo);
					if (accUnAccIds.size() > 0) {
						accDataWithStatus = accountingDataService.getAccDataWithStatus(accUnAccIds,params.getStatus(), tenantId,params.getDataViewId(), groupId, limit,pageSize, headerColumns, exportFile,columnsString, params.getSearchWord(),colNameNType,params.getSortOrderBy());
					}
				}
			}
		} else if ("rules".equalsIgnoreCase(params.getGroupBy())) {
			String transDateQualifier = reconciliationResultService.getTransDateQualifier(new BigInteger(params.getDataViewId().toString()), "TRANSDATE");
			List<BigInteger> totalIdsWithView = reconciliationResultService.getViewOriginalIds(params.getDataViewId(), rangeFrom,rangeTo, transDateQualifier);
			String columnsString = reconciliationResultService.getColumnNamesAsString(params.getDataViewId());
			HashMap headerColumns = accountingDataService.getViewColumnHeadersMapInSequence(params.getDataViewId(),params.getTenantId(), params.getGroupId(),params.getGroupedParamsList());
			if ("days".equalsIgnoreCase(filterGroupBy)) {
				List<BigInteger> totalIds = new ArrayList<BigInteger>();
				if (keyValues.getDays().size() > 0) {
					if (groupByParams.getRuleId() != null) {
						List<BigInteger> ruleIds = new ArrayList<BigInteger>();
						ruleIds.add(BigInteger.valueOf(groupByParams.getRuleId()));
						List<BigInteger> totalIdsWithDays = reconciliationResultService.getOriginalIdsByTransDates(params.getDataViewId(), rangeFrom,rangeTo, transDateQualifier,keyValues.getDays());
						Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getAccountingIdsGroupByDaysWithRule(totalIdsWithDays, rangeFrom, rangeTo,params.getDataViewId(), tenantId,groupId, transDateQualifier, "",ruleIds);
						if (accUnAccIds.size() > 0) {
							accDataWithStatus = accountingDataService.getAccDataWithStatus(accUnAccIds,params.getStatus(), tenantId,params.getDataViewId(), groupId,limit, pageSize, headerColumns,exportFile, columnsString,params.getSearchWord(),colNameNType,params.getSortOrderBy());
						}
					} else if (groupByParams.getOthersRuleName() != null && "Others".equalsIgnoreCase(groupByParams.getOthersRuleName())) {
						Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getOthersInfoWithDayWise(groupId, BigInteger.valueOf(params.getDataViewId()),rangeFrom, rangeTo, transDateQualifier,keyValues.getDays());
						if (accUnAccIds.size() > 0) {
							accDataWithStatus = accountingDataService.getAccDataWithStatus(accUnAccIds,params.getStatus(), tenantId,params.getDataViewId(), groupId,limit, pageSize, headerColumns,exportFile, columnsString,params.getSearchWord(),colNameNType,params.getSortOrderBy());
						}
					}
				} else {
					totalIds.addAll(totalIdsWithView);
					if (groupByParams.getRuleId() != null) {
						List<BigInteger> ruleIds = new ArrayList<BigInteger>();
						ruleIds.add(BigInteger.valueOf(groupByParams.getRuleId()));
						Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getAccountingIdsGroupByDaysWithRule(totalIds,rangeFrom, rangeTo,params.getDataViewId(), tenantId,groupId, transDateQualifier, "",ruleIds);
						if (accUnAccIds.size() > 0) {
							accDataWithStatus = accountingDataService.getAccDataWithStatus(accUnAccIds,params.getStatus(), tenantId,params.getDataViewId(), groupId,limit, pageSize, headerColumns,exportFile, columnsString,params.getSearchWord(),colNameNType,params.getSortOrderBy());
						}
					} else if (groupByParams.getOthersRuleName() != null && "Others".equalsIgnoreCase(groupByParams.getOthersRuleName())) {
						Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getOthersInfo(groupId, BigInteger.valueOf(params.getDataViewId()),rangeFrom, rangeTo, transDateQualifier);
						if (accUnAccIds.size() > 0) {
							accDataWithStatus = accountingDataService.getAccDataWithStatus(accUnAccIds,params.getStatus(), tenantId,params.getDataViewId(), groupId,limit, pageSize, headerColumns,exportFile, columnsString,params.getSearchWord(),colNameNType,params.getSortOrderBy());
						}
					}
				}
			} else if ("columnName".equalsIgnoreCase(filterGroupBy)) {
				List<BigInteger> totalIds = new ArrayList<BigInteger>();
				HashMap columnMap = accountingDataService.getDataViewColumnNameByColumnId(columnValues.getColumnId());
				if (columnMap.get("columnName").toString().length() > 0 && columnMap.get("dataType") != null) {
					if (columnValues.getColumnValues().size() > 0) {
						if (groupByParams.getRuleId() != null) {
							List<BigInteger> ruleIds = new ArrayList<BigInteger>();
							ruleIds.add(BigInteger.valueOf(groupByParams.getRuleId()));
							List<BigInteger> totalIdsWitColumns = reconciliationResultService.getTotalIdsGroupByColumnValues(columnValues.getColumnId(),params.getDataViewId(), rangeFrom,rangeTo,columnValues.getColumnValues(),"fileDate");
							Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getAccountingIdsGroupByDaysWithRule(totalIdsWitColumns, rangeFrom,rangeTo, params.getDataViewId(),tenantId, groupId,columnMap.get("columnName").toString(), "", ruleIds);
							if (accUnAccIds.size() > 0) {
								accDataWithStatus = accountingDataService.getAccDataWithStatus(accUnAccIds,params.getStatus(), tenantId,params.getDataViewId(),groupId, limit, pageSize,headerColumns, exportFile,columnsString,params.getSearchWord(),colNameNType,params.getSortOrderBy());
							}
						} else if (groupByParams.getOthersRuleName() != null) {
							Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getOthersInfoWithColumnWise(groupId,params.getDataViewId(), rangeFrom,rangeTo,columnValues.getColumnValues(),columnValues.getColumnId());
							if (accUnAccIds.size() > 0) {
								accDataWithStatus = accountingDataService.getAccDataWithStatus(accUnAccIds,params.getStatus(), tenantId,params.getDataViewId(),groupId, limit, pageSize,headerColumns, exportFile,columnsString,params.getSearchWord(),colNameNType,params.getSortOrderBy());
							}
						}
					} else {
						totalIds.addAll(totalIdsWithView);
						if (groupByParams.getRuleId() != null) {
							List<BigInteger> ruleIds = new ArrayList<BigInteger>();
							ruleIds.add(BigInteger.valueOf(groupByParams.getRuleId()));
							Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getAccountingIdsGroupByDaysWithRule(totalIds, rangeFrom, rangeTo,params.getDataViewId(), tenantId,groupId, transDateQualifier, "",ruleIds);
							if (accUnAccIds.size() > 0) {
								accDataWithStatus = accountingDataService.getAccDataWithStatus(accUnAccIds,params.getStatus(), tenantId,params.getDataViewId(),groupId, limit, pageSize,headerColumns, exportFile,columnsString,params.getSearchWord(),colNameNType,params.getSortOrderBy());
							}
						} else if (groupByParams.getOthersRuleName() != null) {
							Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getOthersInfo(groupId, BigInteger.valueOf(params.getDataViewId()),rangeFrom, rangeTo,transDateQualifier);
							if (accUnAccIds.size() > 0) {
								accDataWithStatus = accountingDataService.getAccDataWithStatus(accUnAccIds,params.getStatus(), tenantId,params.getDataViewId(),groupId, limit, pageSize,headerColumns, exportFile,columnsString,params.getSearchWord(),colNameNType,params.getSortOrderBy());
							}
						}
					}
				}
			}
		} else if ("batch".equalsIgnoreCase(params.getGroupBy())) {
			String columnsString = reconciliationResultService.getColumnNamesAsString(params.getDataViewId());
			HashMap headerColumns = accountingDataService.getViewColumnHeadersMapInSequence(params.getDataViewId(),params.getTenantId(), params.getGroupId(),params.getGroupedParamsList());
			String transDateQualifier = reconciliationResultService.getTransDateQualifier(new BigInteger(params.getDataViewId().toString()), "TRANSDATE");
			List<BigInteger> totalIdsWithView = reconciliationResultService.getViewOriginalIds(params.getDataViewId(), rangeFrom,rangeTo, transDateQualifier);
			List<String> batchList = new ArrayList<String>();
			batchList.add(groupByParams.getBatchName());
			if ("days".equalsIgnoreCase(filterGroupBy)) {
				if (keyValues.getDays().size() > 0) {
					if ("Manual".equalsIgnoreCase(groupByParams.getBatchName())) {
						List<String> manualBatches = new ArrayList<String>();
						List<String> distinctBatches = accountingDataRepository.fetchDistinctBatches(tenantId, groupId);
						if (distinctBatches.size() > 0) {
							for (String batch : distinctBatches) {
								if (batch.contains("MANUAL")) {
									manualBatches.add(batch);
								}
							}
						}
						List<BigInteger> totalIds = reconciliationResultService.getOriginalIdsByTransDates(params.getDataViewId(), rangeFrom,rangeTo, transDateQualifier,keyValues.getDays());
						if (totalIds.size() > 0 && manualBatches.size() > 0) {
							Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getAccIdsForManualBatches(totalIds,tenantId, groupId, BigInteger.valueOf(params.getDataViewId()),rangeFrom, rangeTo, manualBatches);
							if(accUnAccIds.size()>0)
							{
								accDataWithStatus = accountingDataService.getAccDataWithStatus(accUnAccIds,params.getStatus(), tenantId,params.getDataViewId(), groupId,limit, pageSize, headerColumns,exportFile, columnsString,params.getSearchWord(),colNameNType,params.getSortOrderBy());	
							}
						}
					} else if ("Others".equalsIgnoreCase(groupByParams.getBatchName())) {
						Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getOthersInfoWithDayWise(groupId, BigInteger.valueOf(params.getDataViewId()),rangeFrom, rangeTo, transDateQualifier,keyValues.getDays());
						if (accUnAccIds.size() > 0) {
							accDataWithStatus = accountingDataService.getAccDataWithStatus(accUnAccIds,params.getStatus(), tenantId,params.getDataViewId(), groupId,limit, pageSize, headerColumns,exportFile, columnsString,params.getSearchWord(),colNameNType,params.getSortOrderBy());
						}
					} else {
						List<BigInteger> totalIds = reconciliationResultService.getOriginalIdsByTransDates(params.getDataViewId(), rangeFrom,rangeTo, transDateQualifier,keyValues.getDays());
						Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getAccIdsForOriginalBatches(totalIds,tenantId, groupId,BigInteger.valueOf(params.getDataViewId()), rangeFrom,rangeTo, batchList);
						if(accUnAccIds.size()>0)
						{
							accDataWithStatus = accountingDataService.getAccDataWithStatus(accUnAccIds,params.getStatus(), tenantId,params.getDataViewId(), groupId, limit,pageSize, headerColumns, exportFile,columnsString, params.getSearchWord(),colNameNType,params.getSortOrderBy());	
						}
					}
				} else {
					List<BigInteger> totalIds = reconciliationResultService.getViewOriginalIds(params.getDataViewId(),rangeFrom, rangeTo, transDateQualifier);
					if (totalIds.size() > 0) {
						if ("Manual".equalsIgnoreCase(groupByParams.getBatchName())) {
							List<String> batches = accountingDataRepository.fetchDistinctBatches(tenantId, groupId);
							if (batches.size() > 0) {
								List<String> manualBatches = new ArrayList<String>();
								for (String batch : batches) {
									if (batch.contains("MANUAL")) {
										manualBatches.add(batch);
									}
								}
								if (manualBatches.size() > 0) {
									Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getAccountingIdsByManualBatches(totalIds, tenantId,groupId,BigInteger.valueOf(params.getDataViewId()),rangeFrom, rangeTo,manualBatches);
									if(accUnAccIds.size()>0)
									{
										accDataWithStatus = accountingDataService.getAccDataWithStatus(accUnAccIds,params.getStatus(),tenantId,params.getDataViewId(),groupId, limit, pageSize,headerColumns, exportFile,columnsString,params.getSearchWord(),colNameNType,params.getSortOrderBy());	
									}
								}
							}
						} else if ("Others".equalsIgnoreCase(groupByParams.getBatchName())) {
							Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getOthersInfo(groupId, BigInteger.valueOf(params.getDataViewId()),rangeFrom, rangeTo,transDateQualifier);
							if (accUnAccIds.size() > 0) {
								accDataWithStatus = accountingDataService.getAccDataWithStatus(accUnAccIds,params.getStatus(), tenantId,params.getDataViewId(),groupId, limit, pageSize,headerColumns, exportFile,columnsString,params.getSearchWord(),colNameNType,params.getSortOrderBy());
							}
						} else {
							Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getAccountingIdsByOriginalBatches(totalIds, tenantId, groupId,BigInteger.valueOf(params.getDataViewId()),rangeFrom, rangeTo, batchList);
							if(accUnAccIds.size()>0)
							{
								accDataWithStatus = accountingDataService.getAccDataWithStatus(accUnAccIds,params.getStatus(), tenantId,params.getDataViewId(), groupId,limit, pageSize, headerColumns,exportFile, columnsString,params.getSearchWord(),colNameNType,params.getSortOrderBy());	
							}
						}
					}
				}
			} else if ("columnName".equalsIgnoreCase(filterGroupBy)) {
				if (columnValues.getColumnValues().size() > 0) {
					if ("Manual".equalsIgnoreCase(groupByParams.getBatchName())) {
						List<String> manualBatches = new ArrayList<String>();
						List<String> distinctBatches = accountingDataRepository.fetchDistinctBatches(tenantId, groupId);
						if (distinctBatches.size() > 0) {
							for (String batch : distinctBatches) {
								if (batch.contains("MANUAL")) {
									manualBatches.add(batch);
								}
							}
						}
						List<BigInteger> totalIds = reconciliationResultService.getTotalIdsGroupByColumnValues(columnValues.getColumnId(),params.getDataViewId(), rangeFrom,rangeTo, columnValues.getColumnValues(),"fileDate");
						Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getAccountingIdsByManualBatches(totalIds,tenantId, groupId,BigInteger.valueOf(params.getDataViewId()), rangeFrom,rangeTo, manualBatches);
						accDataWithStatus = accountingDataService.getAccDataWithStatus(accUnAccIds,params.getStatus(), tenantId,params.getDataViewId(), groupId, limit,pageSize, headerColumns, exportFile,columnsString, params.getSearchWord(),colNameNType,params.getSortOrderBy());
					} else if ("Others".equalsIgnoreCase(groupByParams.getBatchName())) {
						Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getOthersInfoWithColumnWise(groupId,params.getDataViewId(), rangeFrom,rangeTo,columnValues.getColumnValues(),columnValues.getColumnId());
						if (accUnAccIds.size() > 0) {
							accDataWithStatus = accountingDataService.getAccDataWithStatus(accUnAccIds,params.getStatus(), tenantId,params.getDataViewId(), groupId,limit, pageSize, headerColumns,exportFile, columnsString,params.getSearchWord(),colNameNType,params.getSortOrderBy());
						}
					} else {
						List<BigInteger> totalIds = reconciliationResultService.getTotalIdsGroupByColumnValues(columnValues.getColumnId(),params.getDataViewId(), rangeFrom,rangeTo, columnValues.getColumnValues(),"fileDate");
						Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getAccountingIdsByOriginalBatches(totalIds,tenantId, groupId,BigInteger.valueOf(params.getDataViewId()), rangeFrom,rangeTo, batchList);
						if(accUnAccIds.size()>0)
						{
							accDataWithStatus = accountingDataService.getAccDataWithStatus(accUnAccIds,params.getStatus(), tenantId,params.getDataViewId(), groupId, limit,pageSize, headerColumns, exportFile,columnsString, params.getSearchWord(),colNameNType,params.getSortOrderBy());	
						}
					}
				} else {
					List<BigInteger> totalIds = reconciliationResultService.getViewOriginalIds(params.getDataViewId(),rangeFrom, rangeTo, transDateQualifier);
					if (totalIds.size() > 0) {
						if ("Manual".equalsIgnoreCase(groupByParams.getBatchName())) {
							List<String> batches = accountingDataRepository.fetchDistinctBatches(tenantId, groupId);
							if (batches.size() > 0) {
								List<String> manualBatches = new ArrayList<String>();
								for (String batch : batches) {
									if (batch.contains("MANUAL")) {
										manualBatches.add(batch);
									}
								}
								if (manualBatches.size() > 0) {
									Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getAccountingIdsByManualBatches(totalIds, tenantId,groupId,BigInteger.valueOf(params.getDataViewId()),rangeFrom, rangeTo,manualBatches);
									if(accUnAccIds.size()>0)
									{
										accDataWithStatus = accountingDataService.getAccDataWithStatus(accUnAccIds,params.getStatus(),tenantId,params.getDataViewId(),groupId, limit, pageSize,headerColumns, exportFile,columnsString,params.getSearchWord(),colNameNType,params.getSortOrderBy());	
									}
								}
							}
						} else if ("Others".equalsIgnoreCase(groupByParams.getBatchName())) {
							Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getOthersInfo(groupId, BigInteger.valueOf(params.getDataViewId()),rangeFrom, rangeTo,transDateQualifier);
							if (accUnAccIds.size() > 0) {
								accDataWithStatus = accountingDataService.getAccDataWithStatus(accUnAccIds,params.getStatus(), tenantId,params.getDataViewId(),groupId, limit, pageSize,headerColumns, exportFile,columnsString,params.getSearchWord(),colNameNType,params.getSortOrderBy());
							}
						} else {
							Map<String, List<BigInteger>> accUnAccIds = accountingDataService.getAccountingIdsByOriginalBatches(totalIds, tenantId, groupId,BigInteger.valueOf(params.getDataViewId()),rangeFrom, rangeTo, batchList);
							if(accUnAccIds.size()>0)
							{
								accDataWithStatus = accountingDataService.getAccDataWithStatus(accUnAccIds,params.getStatus(), tenantId,params.getDataViewId(), groupId,limit, pageSize, headerColumns,exportFile, columnsString,params.getSearchWord(),colNameNType,params.getSortOrderBy());	
							}
						}
					}
				}
			}
		}
		return accDataWithStatus;
	}

	// AWQ New Forms API's
	/**
	 * Author: Shiva Purpose: Fetching AWQ Counts and Amounts based on groupBy
	 * fields Params: tenantId, groupId, rangeFrom, rangeTo, groupBy,
	 * sourceDataView, keyObjects Result: HashMap with AWQ counts and amounts
	 * with respecto groupby fields
	 * 
	 * @throws ClassNotFoundException
	 * @throws SQLException
	 * @throws ParseException
	 **/
	@PostMapping("/getAccCountAndAmounts")
	@Timed
	public HashMap getAccCountAndAmounts(
			@RequestParam Long tenantId,
			@RequestParam Long groupId,
			@RequestParam(value = "rangeFrom", required = true) String rangeFrom,
			@RequestParam(value = "rangeTo", required = true) String rangeTo,
			@RequestParam(value = "groupBy", required = true) String groupBy,
			@RequestParam(value = "sourceViewId", required = false) Long sourceViewId,
			@RequestParam(value = "columnId", required = false) Long columnId,
			@RequestParam(value = "filterGroupBy", required = false) String filterGroupBy,
			@RequestBody AWQGroupByParamsDTO params)
			throws ClassNotFoundException, SQLException, ParseException {
		log.info("Rest api for getting accounting count and amounts for tenant id: "
				+ tenantId
				+ ", rule group id: "
				+ groupId
				+ ", groupBy: "
				+ groupBy);
		HashMap finalMap = new HashMap();
		RuleGroup rg = ruleGroupRepository.findOne(groupId);
		if (rg != null) {
			List<HashMap> groupedList = new ArrayList<HashMap>();
			finalMap.put("ruleGroupId", rg.getId());
			finalMap.put("ruleGroupName", rg.getName());
			finalMap.put("groupBy", groupBy);
			if ("process".equalsIgnoreCase(groupBy)) {
				log.info("Fetching accounting counts and amounts groupBy process...");
				String transDateQualifier = reconciliationResultService
						.getTransDateQualifier(
								new BigInteger(sourceViewId.toString()),
								"TRANSDATE");
				if (filterGroupBy != null) {
					String amountQualifier = reconciliationResultService
							.getQualifier(new BigInteger(params.getViewId()
									.toString()));
					if (amountQualifier.length() > 0) {
						if ("batch".equalsIgnoreCase(filterGroupBy)) {
							String transDateColumn = reconciliationResultService
									.getTransDateQualifier(new BigInteger(
											params.getViewId().toString()),
											"TRANSDATE");
							if (transDateColumn.length() > 0) {
								List<String> batches = accountingDataRepository
										.fetchDistinctBatches(tenantId, groupId);
								groupedList = accountingDataService
										.fetchBatchesStatisticsWithOthers(
												batches,
												new BigInteger(params
														.getViewId().toString()),
												rangeFrom, rangeTo,
												transDateQualifier, tenantId,
												groupId, amountQualifier);
								finalMap.put("groupedList", groupedList);
							}
						}
					}
				}
			}
		}
		return finalMap;
	}

	/**
	 * Author: Shiva Description: API for fetching reconciliation data based on
	 * group id and groupBy values params: tenantId, groupId, dataViewId,
	 * sourceOrTarget, status, rangeFrom, rangeTo, pageNumber, pageSize,
	 * keyValuesDTO
	 * 
	 * @throws SQLException
	 * @throws ClassNotFoundException
	 * @throws ParseException
	 */
	@PostMapping("/getAccountingGroupByData")
	@Timed
	public List<LinkedHashMap> getAccountingGroupByData(
			@RequestParam(value = "pageNumber", required = false) Long pageNumber,
			@RequestParam(value = "pageSize", required = false) Long pageSize,
			@RequestParam(value = "filterGroupBy", required = false) String filterGroupBy,
			@RequestParam(value = "exportFile", required = false) String exportFile,
			@RequestBody ReconQueryParamsDTO params) throws SQLException,
			ClassNotFoundException, ParseException {
		log.info("Rest api for fetching accounting data for the group id: "
				+ params.getTenantId() + ", and tenant id: "
				+ params.getGroupId());
		List<LinkedHashMap> finalList = new ArrayList<LinkedHashMap>();
		// Setting pagination parameters
		Long limit = 0L;

		HashMap info = new HashMap();
		Long tenantId = params.getTenantId();
		Long groupId = params.getGroupId();
		String rangeFrom = params.getRangeFrom();
		String rangeTo = params.getRangeTo();
		RWQDataFetchDTO keyValues = params.getKeyValues();
		AWQGroupByParamsDTO groupByParams = params.getGroupByParams();
		ManualUnRecByColumnDTO columnValues = params.getKeyValues()
				.getColumnValues();
		List<LinkedHashMap> accDataWithStatus = new ArrayList<LinkedHashMap>();
		String transDateQualifier = reconciliationResultService
				.getTransDateQualifier(new BigInteger(params.getDataViewId()
						.toString()), "TRANSDATE");
		String columnsString = reconciliationResultService
				.getColumnNamesAsString(params.getDataViewId());
		// columnsString = columnsString.substring(0, columnsString.length()-1);
		log.info("After removing Last Char: " + columnsString);
		if (transDateQualifier.length() > 0) {
			List<BigInteger> allOriginalIds = reconciliationResultService
					.getViewOriginalIds(params.getDataViewId(), rangeFrom,
							rangeTo, transDateQualifier);
			if ("process".equalsIgnoreCase(params.getGroupBy())) {
				HashMap headerColumns = accountingDataService
						.getViewColumnHeadersMapInSequence(
								groupByParams.getViewId(),
								params.getTenantId(), params.getGroupId(),
								params.getGroupedParamsList());
				List<BigInteger> totalIdsWithView = reconciliationResultService
						.getViewOriginalIds(groupByParams.getViewId(),
								rangeFrom, rangeTo, transDateQualifier);
				if (filterGroupBy != null) {
					if ("batch".equalsIgnoreCase(filterGroupBy)) {
						Map<String, List<BigInteger>> accUnAccIds = accountingDataService
								.getAccountingIdsByBatches(totalIdsWithView,
										tenantId, groupId, new BigInteger(
												groupByParams.getViewId()
														.toString()),
										rangeFrom, rangeTo, keyValues
												.getBatchNames());
						if (accUnAccIds.size() > 0) {
							// accDataWithStatus =
							// accountingDataService.getAccDataWithStatus(accUnAccIds,
							// params.getStatus(), tenantId,
							// groupByParams.getViewId(), groupId, limit,
							// pageSize, headerColumns,exportFile,
							// columnsString, params.getSearchWord());
						}
					}

				}
				return accDataWithStatus;
			} else
				return accDataWithStatus;
		} else {
			log.info("There is no trans date qualifier found for the view id: "
					+ params.getDataViewId());
			return accDataWithStatus;
		}
	}

	/*
	 * Author: Shiva
	 * 
	 * @param ManualAccountingData, tenantId Description: Posting Manual
	 * Accounting Data
	 * 
	 * @return ErrorReport
	 */
	@PostMapping("/postManualAccData")
	@Timed
	public ErrorReport postManualAccData(
			@RequestBody ManualAccountingDTO manualAccDTO,
			@RequestParam Long tenantId, @RequestParam Long userId) {
		log.info("Rest api for posting manual accounted data");
		ErrorReport errorReport = new ErrorReport();
		Long viewId = manualAccDTO.getViewId();
		List<RowIdCreditsDebitsDTO> rows = manualAccDTO.getRows();
		String timeStamp = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss",Locale.US).format(new Date());
		String jobReference = "MANUAL_" + timeStamp;
		List<AccountedSummary> accSummary = new ArrayList<AccountedSummary>();
		if (rows.size() > 0) {
			List<AccountingData> allRecords = new ArrayList<AccountingData>();
			for (RowIdCreditsDebitsDTO row : rows) {
				AccountedSummary as = new AccountedSummary();
				as.setCreatedBy(userId);
				as.setCreatedDate(ZonedDateTime.now());
				as.setLastUpdatedBy(userId);
				as.setLastUpdatedDate(ZonedDateTime.now());
				as.setJobReference(jobReference);
				as.setRowId(row.getRowId());
				as.setRuleId(0L);
				as.setStatus("ACCOUNTED");
				as.setRuleGroupId(manualAccDTO.getGroupId());
				as.setViewId(manualAccDTO.getViewId());
				as.setCreditCount(row.getCredits().size());
				as.setDebitCount(row.getDebits().size());
				AccountedSummary asRecord = accountedSummaryRepository.findByRowIdAndRuleGroupIdAndViewId(row.getRowId(),manualAccDTO.getGroupId(), viewId);
				if (asRecord != null) {
					as.setId(asRecord.getId());
					accountedSummaryRepository.save(as);
				}
				accSummary.add(as);
				List<CreditLineDTO> credits = row.getCredits();
				List<DebitLineDTO> debits = row.getDebits();
				if (credits.size() > 0) {
					for (CreditLineDTO creditObj : credits) {
						String credit = creditObj.getCreditLine();
						if (credit.length() > 0) {
							String[] creditArray = credit.toString().split("\\-");
							AccountingData creditAD = new AccountingData();
							creditAD.setTenantId(tenantId);
							creditAD.setOriginalRowId(row.getRowId());
							creditAD.setLineType("CREDIT");
							creditAD.setCreatedBy(userId);
							creditAD.setCreatedDate(ZonedDateTime.now());
							creditAD.setLastUpdatedBy(userId);
							creditAD.setLastUpdatedDate(ZonedDateTime.now());
							creditAD.setStatus("SUCCESS");
							creditAD.setAcctRuleId(0L);
							creditAD.setOriginalViewId(manualAccDTO.getViewId());
							creditAD.setCoaRef(row.getCoaRef());
							creditAD.setAcctGroupId(manualAccDTO.getGroupId());
							creditAD.setJobReference(jobReference);
							creditAD.setLedgerRef(row.getLedgerRef());
							creditAD.setAmountColId(creditObj.getAmountColId());
							creditAD.setCategoryRef(row.getCategoryRef());
							creditAD.setSourceRef(row.getSourceRef());
							creditAD.setCurrencyRef(row.getCurrencyRef());
							for (int i = 0; i < creditArray.length; i++) {
								if (i == 0) {
									creditAD.setAccountingRef1(creditArray[i]);
								} else if (i == 1) {
									creditAD.setAccountingRef2(creditArray[i]);
								} else if (i == 2) {
									creditAD.setAccountingRef3(creditArray[i]);
								} else if (i == 3) {
									creditAD.setAccountingRef4(creditArray[i]);
								} else if (i == 4) {
									creditAD.setAccountingRef5(creditArray[i]);
								} else if (i == 5) {
									creditAD.setAccountingRef6(creditArray[i]);
								} else if (i == 6) {
									creditAD.setAccountingRef7(creditArray[i]);
								} else if (i == 7) {
									creditAD.setAccountingRef8(creditArray[i]);
								} else if (i == 8) {
									creditAD.setAccountingRef9(creditArray[i]);
								} else if (i == 9) {
									creditAD.setAccountingRef10(creditArray[i]);
								}
							}
							AccountedSummary accSummaryCredit = accountedSummaryRepository.findByRowIdAndRuleGroupIdAndViewId(row.getRowId(),manualAccDTO.getGroupId(),manualAccDTO.getViewId());
							if (accSummary != null) {
								AccountingData adCredit = accountingDataRepository.findByTenantIdAndOriginalRowIdAndLineTypeAndOriginalViewIdAndAcctGroupIdAndJobReference(tenantId, row.getRowId(),"Credit", manualAccDTO.getViewId(),manualAccDTO.getGroupId(),accSummaryCredit.getJobReference());
								if (adCredit != null) {// Updating credit record
									creditAD.setId(adCredit.getId());
									accountingDataRepository.save(creditAD);
								}
							}
							allRecords.add(creditAD);
						}
					}
				}
				if (debits.size() > 0) {
					for (DebitLineDTO debitObj : debits) {
						String debit = debitObj.getDebitLine();
						if (debit.length() > 0) {
							String[] debitArray = debit.toString().split("\\-");
							AccountingData debitAD = new AccountingData();
							for (int i = 0; i < debitArray.length; i++) {
								if (i == 0) {
									debitAD.setAccountingRef1(debitArray[i]);
								} else if (i == 1) {
									debitAD.setAccountingRef2(debitArray[i]);
								} else if (i == 2) {
									debitAD.setAccountingRef3(debitArray[i]);
								} else if (i == 3) {
									debitAD.setAccountingRef4(debitArray[i]);
								} else if (i == 4) {
									debitAD.setAccountingRef5(debitArray[i]);
								} else if (i == 5) {
									debitAD.setAccountingRef6(debitArray[i]);
								} else if (i == 6) {
									debitAD.setAccountingRef7(debitArray[i]);
								} else if (i == 7) {
									debitAD.setAccountingRef8(debitArray[i]);
								} else if (i == 8) {
									debitAD.setAccountingRef9(debitArray[i]);
								} else if (i == 9) {
									debitAD.setAccountingRef10(debitArray[i]);
								}
							}
							debitAD.setTenantId(tenantId);
							debitAD.setOriginalRowId(row.getRowId());
							debitAD.setLineType("DEBIT");
							debitAD.setCreatedBy(userId);
							debitAD.setCreatedDate(ZonedDateTime.now());
							debitAD.setLastUpdatedBy(userId);
							debitAD.setLastUpdatedDate(ZonedDateTime.now());
							debitAD.setStatus("SUCCESS");
							debitAD.setAcctRuleId(0L);
							debitAD.setOriginalViewId(manualAccDTO.getViewId());
							debitAD.setCoaRef(row.getCoaRef());
							debitAD.setAcctGroupId(manualAccDTO.getGroupId());
							debitAD.setJobReference(jobReference);
							debitAD.setLedgerRef(row.getLedgerRef());
							debitAD.setAmountColId(debitObj.getAmountColId());
							debitAD.setCategoryRef(row.getCategoryRef());
							debitAD.setSourceRef(row.getSourceRef());
							debitAD.setCurrencyRef(row.getCurrencyRef());
							AccountedSummary accSummaryDebit = accountedSummaryRepository.findByRowIdAndRuleGroupIdAndViewId(row.getRowId(),manualAccDTO.getGroupId(),manualAccDTO.getViewId());
							if (accSummary != null) {
								AccountingData adDebit = accountingDataRepository.findByTenantIdAndOriginalRowIdAndLineTypeAndOriginalViewIdAndAcctGroupIdAndJobReference(tenantId, row.getRowId(),"Debit", manualAccDTO.getViewId(),manualAccDTO.getGroupId(),accSummaryDebit.getJobReference());
								if (adDebit != null) {// Updating debit record
									debitAD.setId(adDebit.getId());
									accountingDataRepository.save(debitAD);
								}
							}
							allRecords.add(debitAD);
						}
					}
				}
			}
			List<AccountingData> dataPosting = accountingDataRepository.save(allRecords);
			List<AccountedSummary> accSummaryPosting = accountedSummaryRepository.save(accSummary);
			//POsting manual accounting data count in t_app_module_summary table
 	 		AppModuleSummary amsSource = appModuleSummaryRepository.findByModuleAndRuleGroupIdAndRuleIdAndTypeAndViewId("ACCOUNTING", manualAccDTO.getGroupId(), 0L, "ACCOUNTED", manualAccDTO.getViewId());
 	 		if(amsSource != null)
 	 		{
 	 			log.info("Source app_module_config table updating...");
 	 			amsSource.setLastUpdatedBy(userId);
 	 			amsSource.setLastUpdatedDate(ZonedDateTime.now());
 	 			amsSource.setTypeCount(amsSource.getTypeCount()+accSummaryPosting.size());
 	 			AppModuleSummary amsSrcUpdate = appModuleSummaryRepository.save(amsSource);
 	 		}
 	 		else
 	 		{
 	 			log.info("Source app_module_config table creating...");
 	 			AppModuleSummary amsCreate = new AppModuleSummary();
 	 			amsCreate.setCreatedBy(userId);
 	 			amsCreate.setCreatedDate(ZonedDateTime.now());
 	 			amsCreate.setLastUpdatedBy(userId);
 	 			amsCreate.setLastUpdatedDate(ZonedDateTime.now());
 	 			amsCreate.setModule("ACCOUNTING");
 	 			amsCreate.setRuleGroupId(manualAccDTO.getGroupId());
 	 			amsCreate.setRuleId(0L);
 	 			amsCreate.setType("ACCOUNTED");
 	 			amsCreate.setTypeCount(Long.valueOf(accSummaryPosting.size()));
 	 			amsCreate.setViewId(manualAccDTO.getViewId());
 	 			AppModuleSummary amsSrcCreate = appModuleSummaryRepository.save(amsCreate);
 	 		}
			log.info(dataPosting.size() + " Records Posted.");
		}
		return errorReport;
	}

	/**
	 * Author: Shiva
	 * @param orginalRowIds, tenantId Description: Processing Manual Un-Accounting Data
	 * @return ErrorReport
	 * @throws SQLException
	 * @throws ClassNotFoundException
	 */
	@PostMapping("/manualUnAccData")
	@Timed
	public ErrorReporting manualUnAccData(
			@RequestParam(value = "type", required = true) String type,
			@RequestParam(value = "filterGroupBy", required = false) String filterGroupBy,
			@RequestBody ReconQueryParamsDTO params,
			@RequestParam(value = "userId", required = true) Long userId
			) throws URISyntaxException,
			SQLException, ClassNotFoundException {
		log.info("Rest api for processing manual un accounting data");
		ErrorReporting errorReport = new ErrorReporting();
		List<String> reasons = new ArrayList<String>();
		List<Long> originalRowIds = params.getOriginalRowIds();
		Long tenantId = params.getTenantId();
		Long groupId = params.getGroupId();
		
		if ("recordwise".equalsIgnoreCase(type)) {
			log.info("Manual Un-Accounting with Recordwise...");
			if (originalRowIds.size() > 0) {
				List<BigInteger> rowIds = new ArrayList<BigInteger>();
				for (Long id : originalRowIds) {
					rowIds.add(BigInteger.valueOf(id));
				}
				// Fetching rule ids
				log.info(">> RowIds: "+ rowIds+", groupID: "+ groupId+", viewID: "+params.getDataViewId());
				List<BigInteger> ruleIds = accountedSummaryRepository.fetchDistinctRuleIdsByRowIds(rowIds, groupId, params.getDataViewId());
				log.info("rule ids: "+ ruleIds);
				if(ruleIds.size()>0)
				{
					for(BigInteger ruleId : ruleIds)
					{
						List<AccountedSummary> accntedSummary = accountedSummaryRepository.fetchRecordsByRowIdsAndGroupIdAndViewIdNRuleId(rowIds,params.getGroupId(), params.getDataViewId(), ruleId.longValue());
						if (accntedSummary.size() > 0) // Deleting accounted summary records
						{
							accountedSummaryRepository.delete(accntedSummary);
							log.info(accntedSummary.size()+ " records deleted from accounting summary table");
						}
						List<AccountingData> accntingIds = accountingDataRepository.fetchRecordsByOriginalRowIdsAndTenantidAndViewIdAndGroupIdNRuleId(originalRowIds, tenantId,params.getDataViewId(), params.getGroupId(), ruleId.longValue());
						if (accntingIds.size() > 0) // Deleting accounting data records
						{
							accountingDataRepository.delete(accntingIds);
							log.info(accntingIds.size()	+ " records deleted from accounting data table");
						}
	 			 		// updating counts in t_app_module_summary table
	 			 		accountingDataService.postAppModuleSummaryTableForAcc(groupId, params.getDataViewId(), ruleId.longValue(), userId, Long.valueOf(accntedSummary.size()), "ACCOUNTING", "ACCOUNTED");
					}
				}
			}
		} else if("batchwise".equalsIgnoreCase(type)){
			String rangeFrom = params.getRangeFrom();
			String rangeTo = params.getRangeTo();
			RWQDataFetchDTO keyValues = params.getKeyValues();
			AWQGroupByParamsDTO groupByParams = params.getGroupByParams();
			ManualUnRecByColumnDTO columnValues = params.getKeyValues().getColumnValues();
			String transDateColumn = reconciliationResultService.getTransDateQualifier(new BigInteger(params.getDataViewId().toString()), "TRANSDATE");
			List<BigInteger> allOriginalIds = reconciliationResultService.getViewOriginalIds(params.getDataViewId(),params.getRangeFrom(), params.getRangeTo(),	transDateColumn);
			if ("rules".equalsIgnoreCase(params.getGroupBy())) {
				log.info("Manual Un-Accounting group by rules...");
				if (transDateColumn.length() > 0) {
					if (filterGroupBy != null) {
						if ("days".equalsIgnoreCase(filterGroupBy)) {
							log.info("Manual filter group by days Un-Accounting...");
							List<BigInteger> totalIds = reconciliationResultService.getOriginalIdsByTransDates(params.getDataViewId(), rangeFrom,rangeTo, transDateColumn,keyValues.getDays());
							log.info("total ids size: "+ totalIds.size());
							accountingDataService.manulUnAccForRules(totalIds,tenantId, params.getDataViewId(), groupId,groupByParams.getRuleId(), userId);
						} else if ("columnName".equalsIgnoreCase(filterGroupBy)) {
							log.info("Manual filter group by column name Un-Accounting...");
							List<BigInteger> totalIds = reconciliationResultService.getTotalIdsGroupByColumnValues(columnValues.getColumnId(),params.getDataViewId(), rangeFrom,rangeTo,columnValues.getColumnValues(),"fileDate");
							log.info("total ids size: "+totalIds.size());
							accountingDataService.manulUnAccForRules(totalIds,tenantId, params.getDataViewId(), groupId,groupByParams.getRuleId(),userId);
						}
					} else if (filterGroupBy == null) {
						log.info("Manual filter group by null Un-Accounting...");
						List<BigInteger> totalIds = reconciliationResultService.getViewOriginalIds(params.getDataViewId(),rangeFrom, rangeTo, transDateColumn);
						log.info("Total Ids Size: "+ totalIds.size());
						accountingDataService.manulUnAccForRules(totalIds,tenantId, params.getDataViewId(), groupId,groupByParams.getRuleId(),userId);
					}
				}
			} else if ("batch".equalsIgnoreCase(params.getGroupBy())) {
				log.info("Manual Un-Accounting with batch...");
				List<String> batchList = new ArrayList<String>();
				batchList.add(groupByParams.getBatchName());
				if (transDateColumn.length() > 0) {
					if (filterGroupBy != null) {
						if ("days".equalsIgnoreCase(filterGroupBy)) {
							if (batchList.contains("Manual")) {
								if ("Manual".equalsIgnoreCase(groupByParams.getBatchName())) {
									List<String> batches = accountingDataRepository.fetchDistinctBatches(tenantId,groupId);
									if (batches.size() > 0) {
										List<String> manualBatches = new ArrayList<String>();
										for (String batch : batches) {
											if (batch.contains("MANUAL")) {
												manualBatches.add(batch);
											}
										}
										if (manualBatches.size() > 0) {
											List<BigInteger> totalIds = reconciliationResultService.getOriginalIdsByTransDates(params.getDataViewId(),rangeFrom, rangeTo,transDateColumn,keyValues.getDays());
											accountingDataService.manualUnAccForBatches(totalIds,tenantId,params.getDataViewId(),groupId,manualBatches, userId);
										}
									}
								}
							} else {
								List<BigInteger> totalIds = reconciliationResultService.getOriginalIdsByTransDates(params.getDataViewId(),rangeFrom, rangeTo,transDateColumn,keyValues.getDays());
								accountingDataService.manualUnAccForBatches(totalIds, tenantId,	params.getDataViewId(), groupId,batchList,userId);
							}
						} else if ("columnName".equalsIgnoreCase(filterGroupBy)) {
							if (batchList.contains("Manual")) {
								if ("Manual".equalsIgnoreCase(groupByParams.getBatchName())) {
									List<String> batches = accountingDataRepository.fetchDistinctBatches(tenantId,groupId);
									if (batches.size() > 0) {
										List<String> manualBatches = new ArrayList<String>();
										for (String batch : batches) {
											if (batch.contains("MANUAL")) {
												manualBatches.add(batch);
											}
										}
										if (manualBatches.size() > 0) {
											List<BigInteger> totalIds = reconciliationResultService.getTotalIdsGroupByColumnValues(columnValues.getColumnId(),params.getDataViewId(),rangeFrom,rangeTo,columnValues.getColumnValues(),"fileDate");
											accountingDataService.manualUnAccForBatches(totalIds,tenantId,params.getDataViewId(),groupId,manualBatches,userId);
										}
									}
								}
							} else {
								List<BigInteger> totalIds = reconciliationResultService.getTotalIdsGroupByColumnValues(columnValues.getColumnId(),params.getDataViewId(),rangeFrom, rangeTo,columnValues.getColumnValues(),"fileDate");
								accountingDataService.manualUnAccForBatches(totalIds, tenantId,params.getDataViewId(), groupId,	batchList,userId);
							}
						}
					} else if (filterGroupBy == null) {
						List<BigInteger> totalIds = reconciliationResultService.getViewOriginalIds(params.getDataViewId(),rangeFrom, rangeTo, transDateColumn);
						accountingDataService.manualUnAccForBatches(totalIds,tenantId, params.getDataViewId(), groupId,batchList,userId);
					}
				}
			} else if ("days".equalsIgnoreCase(params.getGroupBy())) {
				log.info("Manual Un-Accounting group by days...");
				if (transDateColumn.length() > 0) {
					if (filterGroupBy != null) {
						HashMap columnMap = accountingDataService.getDataViewColumnNameByColumnId(columnValues.getColumnId());
						log.info("Column Map: "+ columnMap);
						if ("columnName".equalsIgnoreCase(filterGroupBy)) {
							log.info("Manual Un-Accounting filter group by column name...");
							List<BigInteger> totalIds = reconciliationResultService.getOriginalIdsByColumnValuesNTransDate(params.getDataViewId(), rangeFrom,rangeTo, columnMap.get("columnName").toString(), columnValues.getColumnValues(),columnMap.get("dataType").toString(),transDateColumn, groupByParams.getDay());
							log.info("Total Ids Size: "+ totalIds.size());
							accountingDataService.manualUnAccForTotal(totalIds,	tenantId, params.getDataViewId(), groupId, userId);
						}
					} else if (filterGroupBy == null) {
						log.info("Manual Un-Accounting filter group by null...");
						List<BigInteger> totalIds = reconciliationResultService.getOriginalIdsByTransDate(params.getDataViewId(), rangeFrom,rangeTo, transDateColumn,groupByParams.getDay(), "DATE","fileDate");
						log.info("Total Ids Size: "+ totalIds.size());
						accountingDataService.manualUnAccForTotal(totalIds,tenantId, params.getDataViewId(), groupId, userId);
					}
				}
			} else if ("columnName".equalsIgnoreCase(params.getGroupBy())) {
				log.info("Manual Un-Accounting Group by column name...");
				HashMap columnMap = accountingDataService.getDataViewColumnNameByColumnId(groupByParams.getColumnId());
				log.info("Column map : "+columnMap);
				if (columnMap.get("columnName").toString().length() > 0	&& columnMap.get("dataType") != null) {
					if (filterGroupBy != null) {
						if ("days".equalsIgnoreCase(filterGroupBy)) {
							log.info("Manual Un-Accounting filter group by days...");
							List<BigInteger> totalIds = reconciliationResultService.getOriginalIdsByTransDatesAndColValue(params.getDataViewId(), rangeFrom,rangeTo, columnMap.get("columnName").toString(), groupByParams.getColumnValue(),columnMap.get("dataType").toString(),transDateColumn, keyValues.getDays());
							log.info("Total Ids: "+ totalIds.size());
							accountingDataService.manualUnAccForTotal(totalIds,tenantId, params.getDataViewId(), groupId, userId);
						}
					} else if (filterGroupBy == null) {
						List<BigInteger> totalIds = reconciliationResultService.getOriginalIdsByTransDate(groupByParams.getColumnId(), rangeFrom, rangeTo,columnMap.get("columnName").toString(),groupByParams.getColumnValue().trim(),columnMap.get("dataType").toString(),"fileDate");
						accountingDataService.manualUnAccForTotal(totalIds,tenantId, params.getDataViewId(), groupId, userId);
					}
				}
			} else if ("process".equalsIgnoreCase(params.getGroupBy())) {
				log.info("Manual Un-Accounting group by process...");
				if (filterGroupBy != null) {
					if ("rules".equalsIgnoreCase(filterGroupBy)) {
						log.info("Manual Un-Accounting filter group by rules...");
						List<BigInteger> ruleIds = new ArrayList<BigInteger>();
						List<Long> ruleIdsLong = keyValues.getRuleIds();
						if (ruleIdsLong.size() > 0) {
							for (Long id : ruleIdsLong) {
								ruleIds.add(new BigInteger(id.toString()));
							}
						}
						log.info("Rule Ids: "+ ruleIds);
						List<BigInteger> totalIds = reconciliationResultService.getViewOriginalIds(groupByParams.getViewId(),rangeFrom, rangeTo, transDateColumn);
						log.info("Total Ids: "+ totalIds.size());
					} else if ("batch".equalsIgnoreCase(filterGroupBy)) {
						log.info("Manual Un-Accounting filter group by batch...");
						if (transDateColumn.length() > 0) {
							List<BigInteger> totalIds = reconciliationResultService.getViewOriginalIds(groupByParams.getViewId(),rangeFrom, rangeTo, transDateColumn);
							log.info("Total Ids Size: "+ totalIds.size());
							accountingDataService.manualUnAccForTotal(totalIds,tenantId, params.getDataViewId(), groupId, userId);
						}
					} else if ("days".equalsIgnoreCase(filterGroupBy)) {
						log.info("Manual Un-Accounting filter group by days...");
						List<BigInteger> totalIds = reconciliationResultService.getOriginalIdsByTransDates(groupByParams.getViewId(), rangeFrom,rangeTo, transDateColumn,keyValues.getDays());
						log.info("Total Ids Size: "+ totalIds.size());
						accountingDataService.manualUnAccForTotal(totalIds,tenantId, params.getDataViewId(), groupId, userId);
					} else if ("columnName".equalsIgnoreCase(filterGroupBy)) {
						log.info("Manual Un-Accounting filter group by column name...");
						HashMap columnMap = accountingDataService.getDataViewColumnNameByColumnId(groupByParams.getColumnId());
						log.info("Column Map: "+ columnMap);
						List<BigInteger> totalIds = reconciliationResultService.getTotalIdsGroupByColumnValues(columnValues.getColumnId(),groupByParams.getViewId(), rangeFrom,rangeTo, columnValues.getColumnValues(),"fileDate");
						log.info("Total Ids Size: "+ totalIds.size());
						accountingDataService.manualUnAccForTotal(totalIds,tenantId, params.getDataViewId(), groupId, userId);
					}
				} else if (filterGroupBy == null) {
					log.info("Manual Un-Accounting filter group by null...");
					List<BigInteger> totalIds = reconciliationResultService.getViewOriginalIds(groupByParams.getViewId(),rangeFrom, rangeTo, transDateColumn);
					log.info("Total Ids Size: "+ totalIds.size());
					accountingDataService.manualUnAccForTotal(totalIds,tenantId, params.getDataViewId(), groupId, userId);
				}
			}
		}
		return errorReport;
	}

	/**
	 * Author: Shiva params: Accounting data fetching parameters Description:
	 * Exporting accounting data into Excel File
	 * 
	 * @throws SQLException
	 * @throws ClassNotFoundException
	 * @throws IOException
	 * @throws ParseException
	 **/
	@PostMapping("/exportAccDataToExcelFile")
	@Timed
	public void exportAccDataToExcelFile(
			@RequestParam(value = "filterGroupBy", required = false) String filterGroupBy,
			@RequestBody ReconQueryParamsDTO params)
			throws ClassNotFoundException, SQLException, IOException,
			ParseException {
		log.info("Rest api for Exporting reconciliation data into excel file");
		HashMap finalMap = new HashMap();
		List<LinkedHashMap> accData = new ArrayList<LinkedHashMap>();
		// Fetching accounting Data
		if (filterGroupBy == null) {
			filterGroupBy = null;
		}
		String groupName = "";
		RuleGroup rg = ruleGroupRepository.findOne(params.getGroupId());
		if (rg != null) {
			groupName = groupName + rg.getName();
		}
		String timeStamp = new SimpleDateFormat("yyyy-MM-dd_HH:mm:ss").format(new Date());
		String fileName = "AccountingData" + groupName + "_" + timeStamp + ".xlsx";
		accData = getAccountingGroupByData(0L, 25L, filterGroupBy, "YES",params);
		log.info("Source Size: " + accData.size());
		// Writing source and target data into excel work book
		Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
		String xlsxFileAddress = props.getProperty("localTempLocation") + "/"+ fileName;
		log.info("File Path>>> : " + xlsxFileAddress);

		XSSFWorkbook workBook = new XSSFWorkbook(); // Creating Excel WorkBook
		XSSFSheet source = workBook.createSheet("AccountingData"); //Creating Sheet for
																	// Source

		CellStyle style = workBook.createCellStyle();
		Font font = workBook.createFont();
		font.setFontHeightInPoints((short) 10);
		font.setBoldweight(Font.BOLDWEIGHT_BOLD);
		style.setFont(font);

		try {
			if (accData.size() > 0) // Writing source data into excel
			{
				log.info("Writing accounting data into excel file...");
				LinkedHashMap headerRowData = accData.get(0);
				if (headerRowData != null) {
					LinkedHashMap headerRow = (LinkedHashMap) headerRowData
							.get("data");
					if (headerRow != null) {
						XSSFRow headingRow = source.createRow(0);
						int headerCell = 0;
						for (Object key : headerRow.keySet()) {
							XSSFCell cell = headingRow.createCell(headerCell);
							cell.setCellValue(key.toString());
							cell.setCellStyle(style);
							cell.setAsActiveCell();
							headerCell++;
						}
					}
				}
				/*					*/
				int rowNumber = 1;

				for (LinkedHashMap sourceRec : accData) {
					LinkedHashMap dataMap = (LinkedHashMap) sourceRec
							.get("data");
					XSSFRow currentRow = source.createRow(rowNumber);
					int cellIndex = 0;
					if (dataMap != null) {
						for (Object key : dataMap.keySet()) {
							if (dataMap.get(key.toString()) != null) {
								XSSFCell cell = currentRow
										.createCell(cellIndex);
								cell.setCellValue(dataMap.get(key.toString())
										.toString());
								cell.setCellStyle(style);
							}
							cellIndex++;
						}
					}
					List<LinkedHashMap> childMap = (List<LinkedHashMap>) sourceRec
							.get("children");
					if (childMap != null && childMap.size() > 0) {
						rowNumber = rowNumber + 1;
						for (LinkedHashMap childMp : childMap) {
							LinkedHashMap childMpInside = (LinkedHashMap) childMp
									.get("data");
							if (childMpInside != null) {
								XSSFRow childRow = source.createRow(rowNumber);
								if (childMpInside != null) {
									int childCellIndex = 0;
									for (Object key : childMpInside.keySet()) {
										if (childMpInside.get(key.toString()) != null) {
											childRow.createCell(childCellIndex)
													.setCellValue(
															childMpInside
																	.get(key.toString())
																	.toString());
										}
										childCellIndex++;
									}
									rowNumber = rowNumber + 1;
								}
							}
						}
					}
				}
			}
			FileOutputStream fileOutputStream = new FileOutputStream(
					xlsxFileAddress);
			workBook.write(fileOutputStream);
			fileOutputStream.close();
			System.out.println("Done.........");
		} catch (Exception e) {
			log.info("Exception: " + e);
		}

		File file = new File(props.getProperty("localTempLocation") + "/"
				+ fileName);
		InputStream inputStream = new FileInputStream(file);
		fileService.fileUpload(inputStream, fileName);
		finalMap.put("excelFilePath", props.getProperty("sftpFileTargetFolder")+ fileName);
	}

	@PostMapping("/getHeaderColumnsInSequence")
	@Timed
	public LinkedHashMap getColumnsSequence(@RequestParam Long viewId,@RequestParam Long tenantId, @RequestParam Long groupId, @RequestBody List<String> groupedByParams) {
	LinkedHashMap headerColumns = accountingDataService.getViewColumnHeadersMapInSequence(viewId, tenantId, groupId,groupedByParams);
		log.info("Header Columns: " + headerColumns);
		return headerColumns;
	}
	
	@GetMapping("/testAppModuleSummary")
	@Timed
	public void testAppModuleSummary() throws SQLException
	{
		HashMap ruleViewMap = accountingDataService.getRuleViewMap(35L, "local-1519360083863");
		accountingDataService.postAccountingCountsInAppModuleSummary(35L, "local-1519360083863", ruleViewMap, 9L);
	}
	
	/**
	 * Author: Jagan
	 * @param orginalRowIds, tenantId Description: Processing Manual Un-Accounting Data
	 * @return ErrorReport
	 * @throws SQLException
	 * @throws ClassNotFoundException
	 */
	@PostMapping("/manualUnAccDataAutoAcc")
	@Timed
	public ErrorReporting manualUnAccDataAutoAcc(
			@RequestParam(value = "type", required = true) String type,
			@RequestParam(value = "filterGroupBy", required = false) String filterGroupBy,
			@RequestBody ReconQueryParamsDTO params) throws URISyntaxException,
			SQLException, ClassNotFoundException {
		log.info("Rest api for processing manual un accounting data");
		ErrorReporting errorReport = new ErrorReporting();
		List<String> reasons = new ArrayList<String>();
		List<Long> originalRowIds = params.getOriginalRowIds();
		Long tenantId = params.getTenantId();
		Long groupId = params.getGroupId();
		Long userId= params.getUserId();

		if ("recordwise".equalsIgnoreCase(type)) {
			log.info("Manual Un-Accounting with Recordwise...");
			if (originalRowIds.size() > 0) {
				
				String jobRef = ""; 
				SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
				java.util.Date date = new java.util.Date();
				jobRef = "MANUAL"+dateFormat.format(date)+"RE";
				
				accountingDataService.createReveseEntries(originalRowIds,tenantId,userId,jobRef);
			}
		} else if ("batchwise".equalsIgnoreCase(type)) {
			String rangeFrom = params.getRangeFrom();
			String rangeTo = params.getRangeTo();
			RWQDataFetchDTO keyValues = params.getKeyValues();
			AWQGroupByParamsDTO groupByParams = params.getGroupByParams();
			ManualUnRecByColumnDTO columnValues = params.getKeyValues()
					.getColumnValues();
			String transDateColumn = reconciliationResultService
					.getTransDateQualifier(new BigInteger(params
							.getDataViewId().toString()), "TRANSDATE");
			List<BigInteger> allOriginalIds = reconciliationResultService
					.getViewOriginalIds(params.getDataViewId(),
							params.getRangeFrom(), params.getRangeTo(),
							transDateColumn);
			if ("rules".equalsIgnoreCase(params.getGroupBy())) {
				log.info("Manual Un-Accounting with rules...");
				/*List<Long> ruleIds = new ArrayList<Long>();
				ruleIds.add(groupByParams.getRuleId());*/
				if (transDateColumn.length() > 0) {
					if (filterGroupBy != null) {
						if ("days".equalsIgnoreCase(filterGroupBy)) {
							List<BigInteger> totalIds = reconciliationResultService
									.getOriginalIdsByTransDates(
											params.getDataViewId(), rangeFrom,
											rangeTo, transDateColumn,
											keyValues.getDays());
							accountingDataService.manulUnAccForRules(totalIds,
									tenantId, params.getDataViewId(), groupId,
									groupByParams.getRuleId(), params.getUserId());
						} else if ("columnName".equalsIgnoreCase(filterGroupBy)) {
							List<BigInteger> totalIds = reconciliationResultService
									.getTotalIdsGroupByColumnValues(
											columnValues.getColumnId(),
											params.getDataViewId(), rangeFrom,
											rangeTo,
											columnValues.getColumnValues(), "fileDate");
							accountingDataService.manulUnAccForRules(totalIds,
									tenantId, params.getDataViewId(), groupId,
									groupByParams.getRuleId(), params.getUserId());
						}
					} else if (filterGroupBy == null) {
						List<BigInteger> totalIds = reconciliationResultService
								.getViewOriginalIds(params.getDataViewId(),
										rangeFrom, rangeTo, transDateColumn);
						accountingDataService.manulUnAccForRules(totalIds,
								tenantId, params.getDataViewId(), groupId,
								groupByParams.getRuleId(), params.getUserId());
					}
				}
			} else if ("batch".equalsIgnoreCase(params.getGroupBy())) {
				log.info("Manual Un-Accounting with batch...");
				List<String> batchList = new ArrayList<String>();
				batchList.add(groupByParams.getBatchName());
				if (transDateColumn.length() > 0) {
					if (filterGroupBy != null) {
						if ("days".equalsIgnoreCase(filterGroupBy)) {
							if (batchList.contains("Manual")) {
								if ("Manual".equalsIgnoreCase(groupByParams
										.getBatchName())) {
									List<String> batches = accountingDataRepository
											.fetchDistinctBatches(tenantId,
													groupId);
									if (batches.size() > 0) {
										List<String> manualBatches = new ArrayList<String>();
										for (String batch : batches) {
											if (batch.contains("MANUAL")) {
												manualBatches.add(batch);
											}
										}
										if (manualBatches.size() > 0) {
											List<BigInteger> totalIds = reconciliationResultService
													.getOriginalIdsByTransDates(
															params.getDataViewId(),
															rangeFrom, rangeTo,
															transDateColumn,
															keyValues.getDays());
											accountingDataService
													.manualUnAccForBatches(
															totalIds,
															tenantId,
															params.getDataViewId(),
															groupId,
															manualBatches, params.getUserId());
										}
									}
								}
							} else {
								List<BigInteger> totalIds = reconciliationResultService
										.getOriginalIdsByTransDates(
												params.getDataViewId(),
												rangeFrom, rangeTo,
												transDateColumn,
												keyValues.getDays());
								accountingDataService.manualUnAccForBatches(
										totalIds, tenantId,
										params.getDataViewId(), groupId,
										batchList, params.getUserId());
							}
						} else if ("columnName".equalsIgnoreCase(filterGroupBy)) {
							if (batchList.contains("Manual")) {
								if ("Manual".equalsIgnoreCase(groupByParams
										.getBatchName())) {
									List<String> batches = accountingDataRepository
											.fetchDistinctBatches(tenantId,
													groupId);
									if (batches.size() > 0) {
										List<String> manualBatches = new ArrayList<String>();
										for (String batch : batches) {
											if (batch.contains("MANUAL")) {
												manualBatches.add(batch);
											}
										}
										if (manualBatches.size() > 0) {
											List<BigInteger> totalIds = reconciliationResultService
													.getTotalIdsGroupByColumnValues(
															columnValues
																	.getColumnId(),
															params.getDataViewId(),
															rangeFrom,
															rangeTo,
															columnValues
																	.getColumnValues(), "fileDate");
											accountingDataService
													.manualUnAccForBatches(
															totalIds,
															tenantId,
															params.getDataViewId(),
															groupId,
															manualBatches, params.getUserId());
										}
									}
								}
							} else {
								List<BigInteger> totalIds = reconciliationResultService
										.getTotalIdsGroupByColumnValues(
												columnValues.getColumnId(),
												params.getDataViewId(),
												rangeFrom, rangeTo,
												columnValues.getColumnValues(), "fileDate");
								accountingDataService.manualUnAccForBatches(
										totalIds, tenantId,
										params.getDataViewId(), groupId,
										batchList, params.getUserId());
							}
						}
					} else if (filterGroupBy == null) {
						List<BigInteger> totalIds = reconciliationResultService
								.getViewOriginalIds(params.getDataViewId(),
										rangeFrom, rangeTo, transDateColumn);
						accountingDataService.manualUnAccForBatches(totalIds,
								tenantId, params.getDataViewId(), groupId,
								batchList, params.getUserId());
					}
				}
			} else if ("days".equalsIgnoreCase(params.getGroupBy())) {
				log.info("Manual Un-Accounting with days...");
				if (transDateColumn.length() > 0) {
					if (filterGroupBy != null) {
						HashMap columnMap = accountingDataService
								.getDataViewColumnNameByColumnId(columnValues
										.getColumnId());
						if ("columnName".equalsIgnoreCase(filterGroupBy)) {
							List<BigInteger> totalIds = reconciliationResultService
									.getOriginalIdsByColumnValuesNTransDate(
											params.getDataViewId(), rangeFrom,
											rangeTo, columnMap
													.get("columnName")
													.toString(), columnValues
													.getColumnValues(),
											columnMap.get("dataType")
													.toString(),
											transDateColumn, groupByParams
													.getDay());
							accountingDataService.manualUnAccForTotal(totalIds,
									tenantId, params.getDataViewId(), groupId, params.getUserId());
						}
					} else if (filterGroupBy == null) {
						List<BigInteger> totalIds = reconciliationResultService
								.getOriginalIdsByTransDate(
										params.getDataViewId(), rangeFrom,
										rangeTo, transDateColumn,
										groupByParams.getDay(), "DATE", "fileDate");
						accountingDataService.manualUnAccForTotal(totalIds,
								tenantId, params.getDataViewId(), groupId, params.getUserId());
					}
				}
			} else if ("columnName".equalsIgnoreCase(params.getGroupBy())) {
				log.info("Manual Un-Accounting with column name...");
				HashMap columnMap = accountingDataService
						.getDataViewColumnNameByColumnId(groupByParams
								.getColumnId());
				if (columnMap.get("columnName").toString().length() > 0
						&& columnMap.get("dataType") != null) {
					if (filterGroupBy != null) {
						if ("days".equalsIgnoreCase(filterGroupBy)) {
							List<BigInteger> totalIds = reconciliationResultService
									.getOriginalIdsByTransDatesAndColValue(
											params.getDataViewId(), rangeFrom,
											rangeTo, columnMap
													.get("columnName")
													.toString(), groupByParams
													.getColumnValue(),
											columnMap.get("dataType")
													.toString(),
											transDateColumn, keyValues
													.getDays());
							accountingDataService.manualUnAccForTotal(totalIds,
									tenantId, params.getDataViewId(), groupId, params.getUserId());
						}
					} else if (filterGroupBy == null) {
						List<BigInteger> totalIds = reconciliationResultService
								.getOriginalIdsByTransDate(groupByParams
										.getColumnId(), rangeFrom, rangeTo,
										columnMap.get("columnName").toString(),
										groupByParams.getColumnValue().trim(),
										columnMap.get("dataType").toString(), "fileDate");
						accountingDataService.manualUnAccForTotal(totalIds,
								tenantId, params.getDataViewId(), groupId, params.getUserId());
					}
				}
			} else if ("process".equalsIgnoreCase(params.getGroupBy())) {
				log.info("Manual Un-Accounting with process...");
				if (filterGroupBy != null) {
					if ("rules".equalsIgnoreCase(filterGroupBy)) {
						List<BigInteger> ruleIds = new ArrayList<BigInteger>();
						List<Long> ruleIdsLong = keyValues.getRuleIds();
						if (ruleIdsLong.size() > 0) {
							for (Long id : ruleIdsLong) {
								ruleIds.add(new BigInteger(id.toString()));
							}
						}
						List<BigInteger> totalIds = reconciliationResultService
								.getViewOriginalIds(groupByParams.getViewId(),
										rangeFrom, rangeTo, transDateColumn);
					} else if ("batch".equalsIgnoreCase(filterGroupBy)) {
						if (transDateColumn.length() > 0) {
							List<BigInteger> totalIds = reconciliationResultService
									.getViewOriginalIds(
											groupByParams.getViewId(),
											rangeFrom, rangeTo, transDateColumn);
							accountingDataService.manualUnAccForTotal(totalIds,
									tenantId, params.getDataViewId(), groupId, params.getUserId());
						}
					} else if ("days".equalsIgnoreCase(filterGroupBy)) {
						List<BigInteger> totalIds = reconciliationResultService
								.getOriginalIdsByTransDates(
										groupByParams.getViewId(), rangeFrom,
										rangeTo, transDateColumn,
										keyValues.getDays());
						accountingDataService.manualUnAccForTotal(totalIds,
								tenantId, params.getDataViewId(), groupId, params.getUserId());
					} else if ("columnName".equalsIgnoreCase(filterGroupBy)) {
						HashMap columnMap = accountingDataService
								.getDataViewColumnNameByColumnId(groupByParams
										.getColumnId());
						List<BigInteger> totalIds = reconciliationResultService
								.getTotalIdsGroupByColumnValues(
										columnValues.getColumnId(),
										groupByParams.getViewId(), rangeFrom,
										rangeTo, columnValues.getColumnValues(), "fileDate");
						accountingDataService.manualUnAccForTotal(totalIds,
								tenantId, params.getDataViewId(), groupId, params.getUserId());
					}
				} else if (filterGroupBy == null) {
					List<BigInteger> totalIds = reconciliationResultService
							.getViewOriginalIds(groupByParams.getViewId(),
									rangeFrom, rangeTo, transDateColumn);
					accountingDataService.manualUnAccForTotal(totalIds,
							tenantId, params.getDataViewId(), groupId, params.getUserId());
				}
			}
		}
		return errorReport;
	}
	
	/**
	 * Author: Shiva
	 * **/
	@PostMapping("/getAWQStatusesCountsNAmounts")
	@Timed
	public HashMap getAWQStatusesCountsNAmounts(@RequestBody AWQStatusesDTO params)
	{
		Long tenantId = params.getTenantId();
		Long viewId = params.getViewId();
		Long groupId = params.getGroupId();
		String rangeFrom = params.getRangeFrom();
		String rangeTo = params.getRangeTo();
		String periodFactor = params.getPeriodFactor();
		log.info("Rest api for fetching distinct statuses counts and amounts for activity and non activity based accounting for the rule group: "+groupId+", view id: "+viewId);	
		HashMap finalMap = new HashMap();
		List<HashMap> summary = new ArrayList<HashMap>();
		String status = "";
		List<String> reasons = new ArrayList<String>();
		List<String> activityYorN = new ArrayList<String>();
		String amountQualifier = accountingDataService.getQualifierViewColName(viewId, "AMOUNT");
		String transDateQualifier = accountingDataService.getQualifierViewColName(viewId, "TRANSDATE");
		String dateQualifier = "";
		if("fileDate".equalsIgnoreCase(periodFactor))
		{
			dateQualifier = "fileDate";
		}
		else if("dateQualifier".equalsIgnoreCase(periodFactor))
		{
			dateQualifier  = transDateQualifier;
		}
		log.info("Amount qualifier: "+ amountQualifier+", Date Qualifier: "+ dateQualifier+", view id: "+ viewId);
		try {
			activityYorN = accountingDataService.getActityOrNonActityBased(tenantId, groupId, viewId);
			log.info("View Id: "+ viewId + ", activity or non activity list: "+activityYorN);
			if(dateQualifier.length()>0 && amountQualifier.length()>0)
			{
				if(activityYorN.contains("N"))
				{
					List<HashMap> nonActivityMps = new ArrayList<HashMap>();
					nonActivityMps = accountingDataService.getNonActivitySummary(viewId, groupId, amountQualifier, dateQualifier, rangeFrom, rangeTo);
					summary.addAll(nonActivityMps);
					log.info("Non Activity Based Status Summary info: "+ nonActivityMps);
				}
				if(activityYorN.contains("Y"))
				{
					
				}
			}
			else
			{
				log.info("No amount or date qualifier found for the view id: "+ viewId);
			}

		} catch (SQLException e) {
			status = "Failed";
		}
		finalMap.put("summary", summary);
		HashMap info = new HashMap();
		info.put("status", status);
		info.put("reasons", reasons);
		finalMap.put("summary", summary);
		finalMap.put("info", info);
		return finalMap;
	}

	/**
	 * Author: Shiva
	 * @throws SQLException 
	 * **/
	@PostMapping("/getAWQGroupingSummaryInfo")
	@Timed
	public List<HashMap> getAWQGroupingSummaryInfo(@RequestBody AWQGroupingDTO params) throws SQLException
	{
		List<HashMap> finalMapList = new ArrayList<HashMap>();
		Long tenantId = params.getTenantId();
		Long groupId = params.getGroupId();
		Long viewId = params.getViewId();
		String status = params.getStatus();
		String periodFactor = params.getPeriodFactor();
		String rangeFrom = params.getRangeFrom();
		String rangeTo = params.getRangeTo();
		List<String> filterList = new ArrayList<String>();
		log.info("Rest api for fetching all grouping by summary info for the status "+status);
		String amountQualifier = reconciliationResultService.getViewColumnQualifier(BigInteger.valueOf(viewId), "AMOUNT");
		DataViews dv = dataViewsRepository.findById(viewId);
		// Building where string
		String whereString = "";
		List<HashMap> filters = params.getFilters();
		if(filters.size()>0)
		{
			for(HashMap filter : filters)	// Looping filter column names and values
			{
				String columnName = filter.get("key").toString();
				List<String> values = (List<String>) filter.get("values");
				String innerWhereString = "";
				if(values.size()>0)
				{
					for(int i=0; i<values.size(); i++)	// looing column values
					{
						if(i == values.size()-1)
						{
							innerWhereString = innerWhereString +  "'"+values.get(i)+"'";
						}
						else
						{
							innerWhereString = innerWhereString + "'"+values.get(i) +"', ";
						}
					}
					whereString = whereString + " AND "+columnName +" IN("+innerWhereString+")";
				}
			}
		}
		log.info("Filter Query: "+ whereString);
		
		// Getting dateQualifier or fileDate
		String dateGroupBy = "";
		if("fileDate".equalsIgnoreCase(periodFactor))
		{
			dateGroupBy = "fileDate";
		}
		else if("dateQualifier".equalsIgnoreCase(periodFactor))
		{
			dateGroupBy = accountingDataService.getQualifierViewColName(viewId, "TRANSDATE");
		}
		log.info("Date Qualifier: "+dateGroupBy);
		
		List<String> inputFilterList = new ArrayList<String>();
		if(filters.size()>0)
		{
			for(HashMap filter : filters)
			{
				String columnName = filter.get("key").toString();
				inputFilterList.add(columnName);
			}
		}
		log.info("Filtering columns: "+ inputFilterList);
		
		// By Sub Process
		if(!inputFilterList.contains("rule_code"))
		{
			List<HashMap> rulesSummary = new ArrayList<HashMap>();
			rulesSummary = accountingDataService.getGroupBySummaryInfo(status, "rule_code", dv.getDataViewName().toLowerCase(), dateGroupBy, rangeFrom, rangeTo, tenantId, groupId, viewId,whereString,amountQualifier);
			log.info("Grouping Rules for the view id "+ viewId+" is: "+rulesSummary.size());
			if(rulesSummary.size()>0)
			{
				HashMap rulesMap = new HashMap();
				rulesMap.put("filterName", "rule_code");
				rulesMap.put("filterDisplyName", "By Sub Process");
				rulesMap.put("summary", rulesSummary);
				finalMapList.add(rulesMap);
			}
		}
		
		// By Batch
		if(!inputFilterList.contains("job_reference"))
		{
			List<HashMap> batchSummary = new ArrayList<HashMap>();
			batchSummary = accountingDataService.getGroupBySummaryInfo(status, "job_reference", dv.getDataViewName().toLowerCase(), dateGroupBy, rangeFrom, rangeTo, tenantId, groupId, viewId,whereString,amountQualifier);
			log.info("Grouping Rules for the view id "+ viewId+" is: "+batchSummary.size());
			if(batchSummary.size()>0)
			{
				HashMap rulesMap = new HashMap();
				rulesMap.put("filterName", "job_reference");
				rulesMap.put("filterDisplyName", "By Batch");
				rulesMap.put("summary", batchSummary);
				finalMapList.add(rulesMap);
			}
		}

		// By COA
		if(!inputFilterList.contains("coa_name"))
		{
			List<HashMap> coaSummary = new ArrayList<HashMap>();
			coaSummary = accountingDataService.getGroupBySummaryInfo(status, "coa_name", dv.getDataViewName().toLowerCase(), dateGroupBy, rangeFrom, rangeTo, tenantId, groupId, viewId,whereString,amountQualifier);
			log.info("Grouping Rules for the view id "+ viewId+" is: "+coaSummary.size());
			if(coaSummary.size()>0)
			{
				HashMap rulesMap = new HashMap();
				rulesMap.put("filterName", "coa_name");
				rulesMap.put("filterDisplyName", "By COA");
				rulesMap.put("summary", coaSummary);
				finalMapList.add(rulesMap);
			}
		}

		// By Ledger
		if(!inputFilterList.contains("ledger_name"))
		{
			List<HashMap> ledgerSummary = new ArrayList<HashMap>();
			ledgerSummary = accountingDataService.getGroupBySummaryInfo(status, "ledger_name", dv.getDataViewName().toLowerCase(), dateGroupBy, rangeFrom, rangeTo, tenantId, groupId, viewId,whereString,amountQualifier);
			log.info("Grouping Rules for the view id "+ viewId+" is: "+ledgerSummary.size());
			if(ledgerSummary.size()>0)
			{
				HashMap rulesMap = new HashMap();
				rulesMap.put("filterName", "ledger_name");
				rulesMap.put("filterDisplyName", "By Ledger");
				rulesMap.put("summary", ledgerSummary);
				finalMapList.add(rulesMap);
			}
		}

		// By Line Type
		if(!inputFilterList.contains("line_type"))
		{
			List<HashMap> lineTypeSummary = new ArrayList<HashMap>();
			lineTypeSummary = accountingDataService.getGroupBySummaryInfo(status, "line_type", dv.getDataViewName().toLowerCase(), dateGroupBy, rangeFrom, rangeTo, tenantId, groupId, viewId,whereString,amountQualifier);
			log.info("Grouping Rules for the view id "+ viewId+" is: "+lineTypeSummary.size());
			if(lineTypeSummary.size()>0)
			{
				HashMap rulesMap = new HashMap();
				rulesMap.put("filterName", "line_type");
				rulesMap.put("filterDisplyName", "By Line Type");
				rulesMap.put("summary", lineTypeSummary);
				finalMapList.add(rulesMap);
			}
		}

		// By Line Type Details
		if(!inputFilterList.contains("line_type_detail"))
		{
			List<HashMap> lineTypeDetailSummary = new ArrayList<HashMap>();
			lineTypeDetailSummary = accountingDataService.getGroupBySummaryInfo(status, "line_type_detail", dv.getDataViewName().toLowerCase(), dateGroupBy, rangeFrom, rangeTo, tenantId, groupId, viewId,whereString,amountQualifier);
			log.info("Grouping Rules for the view id "+ viewId+" is: "+lineTypeDetailSummary.size());
			if(lineTypeDetailSummary.size()>0)
			{
				HashMap rulesMap = new HashMap();
				rulesMap.put("filterName", "line_type_detail");
				rulesMap.put("filterDisplyName", "By Line Type Detail");
				rulesMap.put("summary", lineTypeDetailSummary);
				finalMapList.add(rulesMap);
			}
		}
		
		
		// Fetching group by true columns
		List<String> grpByTrueCols = new ArrayList<String>();
		grpByTrueCols = accountingDataService.getGroupByColsTrue(viewId);
		log.info("Data view columns with group by true for the view id are: "+grpByTrueCols);
		if(grpByTrueCols.size()>0)
		{
			for(String column : grpByTrueCols)
			{
				if(!inputFilterList.contains(column.trim()))
				{
					List<HashMap> columnSummary = new ArrayList<HashMap>();
					columnSummary = accountingDataService.getGroupBySummaryInfo(status, column.trim(), dv.getDataViewName().toLowerCase(), dateGroupBy, rangeFrom, rangeTo, tenantId, groupId, viewId,whereString,amountQualifier);
					log.info("Grouping Rules for the view id "+ viewId+" is: "+columnSummary.size());
					if(columnSummary.size()>0)
					{
						HashMap rulesMap = new HashMap();
						rulesMap.put("filterName", column.trim());
						rulesMap.put("filterDisplyName", "By "+column);
						rulesMap.put("summary", columnSummary);
						finalMapList.add(rulesMap);
					}
				}
			}
		}
		
		// Fetching group by period

		List<HashMap> daysGrouping = new ArrayList<HashMap>();
		daysGrouping = accountingDataService.getGroupBySummaryInfo(status, dateGroupBy, dv.getDataViewName().toLowerCase(), dateGroupBy, rangeFrom, rangeTo, tenantId, groupId, viewId ,whereString,amountQualifier);
		for(HashMap dateMap : daysGrouping)
		{
			String columnName = dateMap.get("name").toString();		
			if(!inputFilterList.contains(columnName.trim()))
			{
				List<HashMap> columnSummary = new ArrayList<HashMap>();
				columnSummary = accountingDataService.getGroupBySummaryInfo(status, columnName, dv.getDataViewName().toLowerCase(), dateGroupBy, rangeFrom, rangeTo, tenantId, groupId, viewId,whereString,amountQualifier);
				log.info("Grouping Rules for the view id "+ viewId+" is: "+columnSummary.size());
				if(columnSummary.size()>0)
				{
					HashMap rulesMap = new HashMap();
					rulesMap.put("filterName", columnName);
					rulesMap.put("filterDisplyName", "By "+columnName);
					rulesMap.put("summary", columnSummary);
					finalMapList.add(rulesMap);
				}
			}
		}
	
		return finalMapList;
	}
}