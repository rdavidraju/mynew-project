package com.nspl.app.service;

import static org.elasticsearch.index.query.QueryBuilders.queryStringQuery;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.text.DateFormat;
import java.text.NumberFormat;
import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.time.ZonedDateTime;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.stream.Collectors;

import javax.inject.Inject;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.servlet.http.HttpServletRequest;

import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVPrinter;
import org.apache.poi.xssf.usermodel.XSSFRow;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.core.env.Environment;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestParam;

import com.codahale.metrics.annotation.Timed;
import com.nspl.app.domain.AccountingEvents;
import com.nspl.app.domain.AppModuleSummary;
import com.nspl.app.domain.ApplicationPrograms;
import com.nspl.app.domain.DataViews;
import com.nspl.app.domain.DataViewsColumns;
import com.nspl.app.domain.FileTemplateLines;
import com.nspl.app.domain.FormConfig;
import com.nspl.app.domain.ReconciliationDuplicateResult;
import com.nspl.app.domain.ReconciliationResult;
import com.nspl.app.domain.RuleGroup;
import com.nspl.app.domain.Rules;
import com.nspl.app.domain.TenantConfig;
import com.nspl.app.repository.AccountingEventsRepository;
import com.nspl.app.repository.AppModuleSummaryRepository;
import com.nspl.app.repository.AppRuleConditionsRepository;
import com.nspl.app.repository.BalanceTypeRepository;
import com.nspl.app.repository.DataViewsColumnsRepository;
import com.nspl.app.repository.DataViewsRepository;
import com.nspl.app.repository.FileTemplateLinesRepository;
import com.nspl.app.repository.ReconciliationDuplicateResultRepository;
import com.nspl.app.repository.ReconciliationResultRepository;
import com.nspl.app.repository.RuleConditionsRepository;
import com.nspl.app.repository.RuleGroupDetailsRepository;
import com.nspl.app.repository.RuleGroupRepository;
import com.nspl.app.repository.RulesRepository;
import com.nspl.app.repository.TenantConfigRepository;
import com.nspl.app.repository.search.ReconciliationResultSearchRepository;
import com.nspl.app.web.rest.DataViewsResource;
import com.nspl.app.web.rest.dto.FilterColumns;
import com.nspl.app.web.rest.dto.ManualUnRecByColumnDTO;
import com.nspl.app.web.rest.dto.RWQDataFetchDTO;
import com.nspl.app.web.rest.dto.RWQDetailInfoDTO;
import com.nspl.app.web.rest.dto.ReconCountNAmountsDTO;
import com.nspl.app.web.rest.dto.ReconUnReconAmountsDTO;

/**
 * Service Implementation for managing ReconciliationResult.
 */
@Service
@Transactional
public class ReconciliationResultService {

    private final Logger log = LoggerFactory.getLogger(ReconciliationResultService.class);
    
    private final ReconciliationResultRepository reconciliationResultRepository;

    private final ReconciliationResultSearchRepository reconciliationResultSearchRepository;
    
    @Inject
    RuleGroupDetailsRepository ruleGroupDetailsRepository;
    
    @Inject
    RuleGroupRepository ruleGroupRepository;
    
    @Inject
    RulesRepository rulesRepository;
    
    @Inject
    DataViewsResource dataViewsResource;
    
    @Inject
    FileTemplateLinesRepository fileTemplateLinesRepository;
    
    @Inject
    DataViewsColumnsRepository dataViewsColumnsRepository;
    
    @Inject
    PropertiesUtilService propertiesUtilService;
    
    @Inject
    DataViewsRepository dataViewsRepository;
    
    @Inject
    RuleConditionsRepository ruleConditionsRepository;
    
    @Inject
    ReconciliationResultService reconciliationResultService;
    
    @Inject
    AccountingDataService accountingDataService;
    
    @Inject
    BalanceTypeService balanceTypeService;
    
    @Inject
    AppRuleConditionsRepository  appRuleConditionsRepository;
    
    @Inject
    AccountingEventsRepository accountingEventsRepository;
    
    @Inject
    AppModuleSummaryRepository appModuleSummaryRepository;
    
    @Inject
    BalanceTypeRepository balanceTypeRepository;

    @Inject
    ReconciliationDuplicateResultRepository reconciliationDuplicateResultRepository;

    
    
    @Inject
    TenantConfigRepository tenantConfigRepository;
    
    
    @Inject
    FileService fileService;
    
    
    @Inject
    UserJdbcService userJdbcService;
    
    @Inject
    private Environment env;
    
	@PersistenceContext(unitName="default")
	private EntityManager em;

    public ReconciliationResultService(ReconciliationResultRepository reconciliationResultRepository, ReconciliationResultSearchRepository reconciliationResultSearchRepository) {
        this.reconciliationResultRepository = reconciliationResultRepository;
        this.reconciliationResultSearchRepository = reconciliationResultSearchRepository;
    }

    /**
     * Save a reconciliationResult.
     *
     * @param reconciliationResult the entity to save
     * @return the persisted entity
     */
    public ReconciliationResult save(ReconciliationResult reconciliationResult) {
        log.debug("Request to save ReconciliationResult : {}", reconciliationResult);
        ReconciliationResult result = reconciliationResultRepository.save(reconciliationResult);
        reconciliationResultSearchRepository.save(result);
        return result;
    }

    /**
     *  Get all the reconciliationResults.
     *  
     *  @param pageable the pagination information
     *  @return the list of entities
     */
    @Transactional(readOnly = true)
    public Page<ReconciliationResult> findAll(Pageable pageable) {
        log.debug("Request to get all ReconciliationResults");
        Page<ReconciliationResult> result = reconciliationResultRepository.findAll(pageable);
        return result;
    }

    /**
     *  Get one reconciliationResult by id.
     *
     *  @param id the id of the entity
     *  @return the entity
     */
    @Transactional(readOnly = true)
    public ReconciliationResult findOne(Long id) {
        log.debug("Request to get ReconciliationResult : {}", id);
        ReconciliationResult reconciliationResult = reconciliationResultRepository.findOne(id);
        return reconciliationResult;
    }

    /**
     *  Delete the  reconciliationResult by id.
     *
     *  @param id the id of the entity
     */
    public void delete(Long id) {
        log.debug("Request to delete ReconciliationResult : {}", id);
        reconciliationResultRepository.delete(id);
        reconciliationResultSearchRepository.delete(id);
    }

    /**
     * Search for the reconciliationResult corresponding to the query.
     *
     *  @param query the query of the search
     *  @param pageable the pagination information
     *  @return the list of entities
     */
    @Transactional(readOnly = true)
    public Page<ReconciliationResult> search(String query, Pageable pageable) {
        log.debug("Request to search for a page of ReconciliationResults for query {}", query);
        Page<ReconciliationResult> result = reconciliationResultSearchRepository.search(queryStringQuery(query), pageable);
        return result;
    }
    
    /**
     * Author: Shiva
     * Description: Service for getting original ids based on view id
     * @return
     * @throws ClassNotFoundException
     * @throws SQLException 
     */
    public List<BigInteger> getViewIds(BigInteger viewId) throws ClassNotFoundException, SQLException
    {
    	List<BigInteger> originalIds = new ArrayList<BigInteger>();
		Connection conn = null;
		Statement stmt = null;
		ResultSet result = null; 
    	try{
    		String dbUrl=env.getProperty("spring.datasource.url");
    		String[] parts=dbUrl.split("[\\s@&?$+-]+");
    		String host = parts[0].split("/")[2].split(":")[0];
    		String schemaName=parts[0].split("/")[3];
    		String userName = env.getProperty("spring.datasource.username");
    		String password = env.getProperty("spring.datasource.password");
    		String jdbcDriver = env.getProperty("spring.datasource.jdbcdriver");  
    		
    		Class.forName(jdbcDriver);
     	    conn = DriverManager.getConnection(dbUrl, userName, password);
     	    stmt = conn.createStatement();
      	    DataViews dv=dataViewsRepository.findOne(viewId.longValue());
      	    if(dv!= null)
      	    {
         	    String viewName=dv.getDataViewName();
         	    result=stmt.executeQuery("select scrIds from "+schemaName+".`"+viewName.toLowerCase()+"`");
         	 	while(result.next()){
         	 	    	originalIds.add(new BigInteger((result.getString(1))));
         	 	}  
      	    }
      	    else
      	    {
      	    	log.info("View doen't not exist for the view id: "+viewId);
      	    }
    	 }catch(SQLException se){
    		   log.info("Error while executing query: "+se);
         }
    	catch(Exception e)
    	{
        	 log.info("Exception while getting databse properties");
    	}
    	finally{
    		if(result != null)
    			result.close();	
    		if(stmt != null)
    			stmt.close();
			if(conn != null)
				conn.close();
		}
    	log.info("View ID: "+ viewId+", Row Ids Size: "+originalIds.size());
    	return originalIds;
    }

    /* Get Distinct DvIds based on RuleGroup */
    public HashMap<String, List<BigInteger>> getDistinctDVIdsforRuleGrp(Long ruleGrpId, Long tenantId){
    	log.info("In Service for getting distinct source and target ids for grup id: "+ruleGrpId+", tenantId: "+ tenantId);
    	HashMap<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
    	List<BigInteger> distSrcIds = new ArrayList<BigInteger>();
    	List<BigInteger> distTargetIds = new ArrayList<BigInteger>();
    	List<Long> ruleIds = ruleGroupDetailsRepository.fetchByRuleGroupIdAndTenantId(ruleGrpId, tenantId);
    	log.info("Rule Ids Size for Group Id "+ruleGrpId+": "+ruleIds.size()+", "+ruleIds);
    	if(ruleIds.size()>0)
    	{
    		distSrcIds = rulesRepository.fetchDistictSrcViewIdsByRuleId(ruleIds);
    		distTargetIds = rulesRepository.fetchDistictTargetViewIdsByRuleId(ruleIds);
    	}
    	log.info("Distinct Source View Ids for GroupId "+ruleGrpId+" : "+distSrcIds);
    	log.info("Distinct Target View Ids for GroupId "+ruleGrpId+" : "+distTargetIds);
    	finalMap.put("sourceViewIds", distSrcIds);
    	finalMap.put("targeViewIds", distTargetIds);
		return finalMap;
    }

	/* Getting Amount Qualifier Field for DataViewId */
	public String getQualifier(BigInteger dataViewId) throws ClassNotFoundException{
		log.info("In Service for getting qualifier column name for the view id: "+ dataViewId);
    	DataViewsColumns dvc = dataViewsColumnsRepository.findByDataViewIdAndQualifier(dataViewId.longValue(), "AMOUNT");
    	String qualifier = "";
    	if(dvc != null)
    	{
    		if("File Template".equalsIgnoreCase(dvc.getRefDvType()))
    		{
        		FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dvc.getRefDvColumn()));
        		if(ftl != null)
        		{
        			qualifier = ftl.getColumnAlias();
        		}
        		log.info("Amount Qualifier for View ID "+ dataViewId +" is ["+dvc.getColumnName()+", "+qualifier+"]");
    		}
    		else if("Data View".equalsIgnoreCase(dvc.getRefDvType()) || dvc.getRefDvType() == null)
    		{
    			qualifier= dvc.getColumnName();
    		}
    	}
    	else
    	{
    		log.info("There is no Amount Qualifier for the view id : "+ dataViewId);
    	}
    	return qualifier;
 }
	
	/* Getting Amount Qualifier Field for DataViewId */
	public String getCurrencyQualifier(BigInteger dataViewId) throws ClassNotFoundException{
		log.info("In Service for getting currency code qualifier column name for the view id: "+ dataViewId);
    	DataViewsColumns dvc = dataViewsColumnsRepository.findByDataViewIdAndQualifier(dataViewId.longValue(), "CURRENCYCODE");
    	String qualifier = "";
    	if(dvc != null)
    	{
    		if("File Template".equalsIgnoreCase(dvc.getRefDvType()))
    		{
        		FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dvc.getRefDvColumn()));
        		if(ftl != null)
        		{
        			qualifier = ftl.getColumnAlias();
        		}
        		log.info("Currency Code Qualifier for View ID "+ dataViewId +" is ["+dvc.getColumnName()+", "+qualifier+"]");
    		}
    		else if("Data View".equalsIgnoreCase(dvc.getRefDvType()) || dvc.getRefDvType() == null)
    		{
    			qualifier= dvc.getColumnName();
    		}
    	}
    	else
    	{
    		log.info("There is no currency code qualifier for the view id : "+ dataViewId);
    	}
    	return qualifier;
 }
	
	public String getQualifierColumnName(BigInteger dataViewId) throws ClassNotFoundException{
		log.info("In Service for getting qualifier column name for the view id: "+ dataViewId);
    	DataViewsColumns dvc = dataViewsColumnsRepository.findByDataViewIdAndQualifier(dataViewId.longValue(), "AMOUNT");
    	String qualifier = "";
    	if(dvc != null)
    	{
    		qualifier = qualifier + dvc.getColumnName();
    		log.info("Qualifier column name for data view id "+ dataViewId + " is: "+ qualifier);
    	}
    	else
    	{
    		log.info("There is no Qualifier for the view id : "+ dataViewId);
    	}
    	return qualifier;
 }
	
    /* Getting Count and Amount based on DVId */
	public HashMap getCountNAmountForDVId(BigInteger dataViewId, Long tenantId, String quaifierCol, List<BigInteger> viewTotalIds) throws ClassNotFoundException{
    	//log.info("In Service for getting total count and amount for view id: "+dataViewId);
		//log.info("dataViewId: "+dataViewId+", qualifer col: "+ quaifierCol+", viewTotalids: "+ viewTotalIds);
		/*NumberFormat nf = NumberFormat.getInstance();*/
		
		int count = viewTotalIds.size();
		NumberFormat numFormat = NumberFormat.getInstance();
		
    	HashMap finalMap=new HashMap();
    	Double totalAmount = 0.0d;
    	totalAmount = totalAmount + Double.parseDouble(getAmountSumByIds(viewTotalIds, quaifierCol, dataViewId));
        finalMap.put("totalCount", numFormat.format(count));
        finalMap.put("totalAmount", totalAmount);
        finalMap.put("totalIds", viewTotalIds);
		return finalMap;
    }
       
    /* Getting Reconciled Map<String, List<Long>> and UnReconciled Id's for Source*/
    public Map<String, List<BigInteger>> getSourceRecNUnRecIds(Long dataViewId, Long tenantId, List<BigInteger> srcTotalIds, Long groupId) throws ClassNotFoundException{
    	List<Long> ruleIds = rulesRepository.fetchIdsByViewId(dataViewId, tenantId);
    	Map<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
    	List<BigInteger> reconciledIds = new ArrayList<BigInteger>();
    	List<BigInteger> sourceUnreconciledIds = new ArrayList<BigInteger>();
    	if(ruleIds.size()>0)
    	{
    		reconciledIds = reconciliationResultRepository.fetchOriginalRowIdsByTenantIdAndRuleIdsAndSourceViewId(tenantId, ruleIds, dataViewId, groupId);
    		/*reconciledIds = reconciliationResultRepository.fetchOriginalRowIdsByOriginalIdsAndJobReferenceNull(tenantId, dataViewId, srcTotalIds,groupId);*/
    	}
    	if(srcTotalIds.size()>0)
    	{
			for(BigInteger id : srcTotalIds)
			{
				if(!reconciledIds.contains(id))
				{
					sourceUnreconciledIds.add(id);
				}
			}
    	}
    	finalMap.put("reconciled", reconciledIds);
    	finalMap.put("unReconciled", sourceUnreconciledIds);
    	log.info("Source View ID: "+dataViewId+", Total Size: "+srcTotalIds.size());
    	log.info("Source View ID: "+dataViewId+", Reconciled Size: "+reconciledIds.size());
    	log.info("Source View ID: "+dataViewId+", UnReconciled Size: "+sourceUnreconciledIds.size());
		return finalMap;
    }
    
    public Map<String, List<BigInteger>> getSourceViewRecNUnRecIdsWithJobReference(Long dataViewId, Long tenantId, List<BigInteger> srcTotalIds, Long groupId, String jobReference) throws ClassNotFoundException{
    	List<Long> ruleIds = rulesRepository.fetchIdsByViewId(dataViewId, tenantId);
    	Map<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
    	List<BigInteger> reconciledIds = new ArrayList<BigInteger>();
    	List<BigInteger> sourceUnreconciledIds = new ArrayList<BigInteger>();
    	if(srcTotalIds.size()>0)
    	{
	    	if(ruleIds.size()>0)
	    	{
	    		/*if(jobReference.length()>0)
	    		{
	    			reconciledIds = reconciliationResultRepository.fetchReconciledIdswithJobReferenceForSource(tenantId, groupId, srcTotalIds, jobReference);
	    		}
	    		else
	    		{*/
	    			reconciledIds = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForSource(tenantId, groupId, srcTotalIds,dataViewId);
	    		/*}*/
	    	}
			for(BigInteger id : srcTotalIds)
			{
				if(!reconciledIds.contains(id))
				{
					sourceUnreconciledIds.add(id);
				}
			}
    	}
    	finalMap.put("reconciled", reconciledIds);
    	finalMap.put("unReconciled", sourceUnreconciledIds);
    	finalMap.put("totalIds", srcTotalIds);
    	log.info("Source View ID: "+dataViewId+", Total Size: "+srcTotalIds.size());
    	log.info("Source View ID: "+dataViewId+", Reconciled Size: "+reconciledIds.size());
    	log.info("Source View ID: "+dataViewId+", UnReconciled Size: "+sourceUnreconciledIds.size());
		return finalMap;
    }
    
    public Map<String, List<BigInteger>> getTargetViewRecNUnRecIdsWithJobReference(Long dataViewId, Long tenantId, List<BigInteger> srcTotalIds, Long groupId, String jobReference) throws ClassNotFoundException{
    	List<Long> ruleIds = rulesRepository.fetchIdsByViewId(dataViewId, tenantId);
    	Map<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
    	List<BigInteger> reconciledIds = new ArrayList<BigInteger>();
    	List<BigInteger> sourceUnreconciledIds = new ArrayList<BigInteger>();
    	if(ruleIds.size()>0)
    	{
    		if(jobReference.length()>0)
    		{
 
    			reconciledIds = reconciliationResultRepository.fetchTargetRowIdsByOriginalIdsAndJobReference(tenantId,dataViewId, srcTotalIds,groupId,jobReference);
    			
    		}
    		else
    		{
    			reconciledIds = reconciliationResultRepository.fetchTargetRowIdsByOriginalIdsAndJobReferenceNull(tenantId,dataViewId, srcTotalIds,groupId);
    		}
    	}
    	if(srcTotalIds.size()>0)
    	{
			for(BigInteger id : srcTotalIds)
			{
				if(!reconciledIds.contains(id))
				{
					sourceUnreconciledIds.add(id);
				}
			}
    	}
    	finalMap.put("reconciled", reconciledIds);
    	finalMap.put("unReconciled", sourceUnreconciledIds);
    	log.info("Source View ID: "+dataViewId+", Total Size: "+srcTotalIds.size());
    	log.info("Source View ID: "+dataViewId+", Reconciled Size: "+reconciledIds.size());
    	log.info("Source View ID: "+dataViewId+", UnReconciled Size: "+sourceUnreconciledIds.size());
		return finalMap;
    }
    
    public Map<String, List<BigInteger>> getTargetViewRecNUnRecIdsWithJobReferenceProcess(Long dataViewId, Long tenantId, List<BigInteger> srcTotalIds, Long groupId, String jobReference) throws ClassNotFoundException{
    	List<Long> ruleIds = rulesRepository.fetchIdsByViewId(dataViewId, tenantId);
    	Map<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
    	List<BigInteger> reconciledIds = new ArrayList<BigInteger>();
    	List<BigInteger> sourceUnreconciledIds = new ArrayList<BigInteger>();
    	if(srcTotalIds.size()>0)
    	{
	    	if(ruleIds.size()>0)
	    	{
	    		/*if(jobReference.length()>0)
	    		{
	 
	    			reconciledIds = reconciliationResultRepository.fetchReconciledIdswithJobReferenceForTarget(tenantId, groupId, srcTotalIds, jobReference);
	    			
	    		}
	    		else
	    		{*/
	    			reconciledIds = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForTarget(tenantId, groupId, srcTotalIds, dataViewId);
	    		/*}*/
	    	}
			for(BigInteger id : srcTotalIds)
			{
				if(!reconciledIds.contains(id))
				{
					sourceUnreconciledIds.add(id);
				}
			}
    	}
    	finalMap.put("reconciled", reconciledIds);
    	finalMap.put("unReconciled", sourceUnreconciledIds);
    	finalMap.put("totalIds", srcTotalIds);
    	log.info("Source View ID: "+dataViewId+", Total Size: "+srcTotalIds.size());
    	log.info("Source View ID: "+dataViewId+", Reconciled Size: "+reconciledIds.size());
    	log.info("Source View ID: "+dataViewId+", UnReconciled Size: "+sourceUnreconciledIds.size());
		return finalMap;
    }
    
    public Map<String, List<BigInteger>> getSourceRecNUnRecIdsNJobReference(Long dataViewId, Long tenantId, List<BigInteger> srcTotalIds, Long groupId, String jobReference) throws ClassNotFoundException{
    	List<Long> ruleIds = rulesRepository.fetchIdsByViewId(dataViewId, tenantId);
    	Map<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
    	List<BigInteger> reconciledIds = new ArrayList<BigInteger>();
    	List<BigInteger> recIds = new ArrayList<BigInteger>();
    	List<BigInteger> unRecIds = new ArrayList<BigInteger>();
    	if(ruleIds.size()>0)
    	{
    		if(jobReference.length()>0)
    		{
    			reconciledIds = reconciliationResultRepository.fetchOriginalRowIdsBySourceViewIdNJobReference(tenantId, srcTotalIds, groupId,jobReference);	
    			recIds = reconciliationResultRepository.fetchReconciledIdswithJobReferenceForSource(tenantId, groupId, srcTotalIds, jobReference,dataViewId);
    		}
    		else
    		{
    			reconciledIds = reconciliationResultRepository.fetchOriginalRowIdsBySourceViewidNJobReferenceNull(tenantId, srcTotalIds, groupId);
    			recIds = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForSource(tenantId, groupId, srcTotalIds,dataViewId);
    		}
    	}
    	if(srcTotalIds.size()>0)
    	{
    		for(BigInteger id : srcTotalIds)
    		{
    			if(!recIds.contains(id))
    				unRecIds.add(id);
    		}
    	}
    	finalMap.put("reconciled", reconciledIds);
    	finalMap.put("unReconciled", unRecIds);
    	log.info("Source View ID: "+dataViewId+", Total Size: "+srcTotalIds.size());
    	log.info("Source View ID: "+dataViewId+", Reconciled Size: "+reconciledIds.size());
    	log.info("Source View ID: "+dataViewId+", UnReconciled Size: "+unRecIds.size());
		return finalMap;
    }
    
	    /* Get Reconciled Map<String, List<Long>>and UnReconciled Id's for Target*/
		public Map<String, List<BigInteger>> getTargetRecNUnRecIds(Long dataViewId, Long tenantId, List<BigInteger> srcTotalIds,  Long groupId) throws ClassNotFoundException{
		List<Long> ruleIds = rulesRepository.fetchTargetIdsByViewId(dataViewId, tenantId);
		Map<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
		List<BigInteger> reconciledIds = new ArrayList<BigInteger>();
		List<BigInteger> sourceUnreconciledIds = new ArrayList<BigInteger>();
		if(ruleIds.size()>0)
		{
			reconciledIds = reconciliationResultRepository.fetchOriginalRowIdsByTenantIdAndRuleIdsAndTargetViewId(tenantId, ruleIds, dataViewId, groupId);
		}
		if(srcTotalIds.size()>0)
		{
			for(BigInteger id : srcTotalIds)
			{
			
				if(!reconciledIds.contains(id))
				{
					sourceUnreconciledIds.add(id);
				}
			}
		}
		finalMap.put("reconciled", reconciledIds);
		finalMap.put("unReconciled", sourceUnreconciledIds);
		log.info("Target View ID: "+dataViewId+", Total Size: "+srcTotalIds.size());
		log.info("Target View ID: "+dataViewId+", Reconciled Size: "+reconciledIds.size());
		log.info("Target View ID: "+dataViewId+", UnReconciled Size: "+sourceUnreconciledIds.size());
		return finalMap;
	}
    
    /* Get Reconciled Map<String, List<Long>>and UnReconciled Id's for Target*/
    	public Map<String, List<BigInteger>> getTargetRecNUnRecIds(Long dataViewId, Long tenantId, List<BigInteger> srcTotalIds, Long groupId, String jobReference) throws ClassNotFoundException{
    	List<Long> ruleIds = rulesRepository.fetchTargetIdsByViewId(dataViewId, tenantId);
    	Map<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
    	List<BigInteger> reconciledIds = new ArrayList<BigInteger>();
    	List<BigInteger> sourceUnreconciledIds = new ArrayList<BigInteger>();
    	if(ruleIds.size()>0)
    	{
    		if(jobReference.length()>0)
    		{
    			reconciledIds = reconciliationResultRepository.fetchReconciledIdswithJobReferenceForTarget(tenantId, groupId, srcTotalIds, jobReference, dataViewId);
    		}
    		else
    		{
    			reconciledIds = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForTarget(tenantId, groupId, srcTotalIds, dataViewId);
    		}
    	}
    	if(srcTotalIds.size()>0)
    	{
			for(BigInteger id : srcTotalIds)
			{
				if(!reconciledIds.contains(id))
				{
					sourceUnreconciledIds.add(id);
				}
			}
    	}
    	finalMap.put("reconciled", reconciledIds);
    	finalMap.put("unReconciled", sourceUnreconciledIds);
    	log.info("Target View ID: "+dataViewId+", Total Size: "+srcTotalIds.size());
    	log.info("Target View ID: "+dataViewId+", Reconciled Size: "+reconciledIds.size());
    	log.info("Target View ID: "+dataViewId+", UnReconciled Size: "+sourceUnreconciledIds.size());
		return finalMap;
    }
    	
       	public Map<String, List<BigInteger>> getTargetRecNUnRecIdsBatches(Long dataViewId, Long tenantId, List<BigInteger> srcTotalIds, Long groupId) throws ClassNotFoundException{
        	List<Long> ruleIds = rulesRepository.fetchTargetIdsByViewId(dataViewId, tenantId);
        	Map<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
        	List<BigInteger> reconciledIds = new ArrayList<BigInteger>();
        	List<BigInteger> sourceUnreconciledIds = new ArrayList<BigInteger>();
        	if(ruleIds.size()>0)
        	{
        		//reconciledIds = reconciliationResultRepository.fetchReconciledIdswithBatchesForTarget(tenantId, groupId, srcTotalIds);
        	}
        	if(srcTotalIds.size()>0)
        	{
    			for(BigInteger id : srcTotalIds)
    			{
    				if(!reconciledIds.contains(id))
    				{
    					sourceUnreconciledIds.add(id);
    				}
    			}
        	}
        	finalMap.put("reconciled", reconciledIds);
        	finalMap.put("unReconciled", sourceUnreconciledIds);
        	log.info("Target View ID: "+dataViewId+", Total Size: "+srcTotalIds.size());
        	log.info("Target View ID: "+dataViewId+", Reconciled Size: "+reconciledIds.size());
        	log.info("Target View ID: "+dataViewId+", UnReconciled Size: "+sourceUnreconciledIds.size());
    		return finalMap;
        }
       
   
    /* Getting Sum of amount qualifier field */
    public String getAmountSumByIds(List<BigInteger> ids, String qualifierField, BigInteger viewId)
    {
    	String idStr=ids.toString();
    	idStr=idStr.replace("[", "");
    	idStr=idStr.replace("]", "");
    	String res="";
    	if(idStr!=null && !(idStr.isEmpty())){
    		//log.info("Qualifier Filed: "+qualifierField);
    		// Connection to JDBC
    		Connection conn = null;
    		Statement stmt = null;
    		ResultSet result = null; 
        	try{
        		String dbUrl=env.getProperty("spring.datasource.url");
        		String[] parts=dbUrl.split("[\\s@&?$+-]+");
        		String host = parts[0].split("/")[2].split(":")[0];
        		String schemaName=parts[0].split("/")[3];
        		String userName = env.getProperty("spring.datasource.username");
        		String password = env.getProperty("spring.datasource.password");
        		String jdbcDriver = env.getProperty("spring.datasource.jdbcdriver");  
        		
        		Class.forName(jdbcDriver);
         	    conn = DriverManager.getConnection(dbUrl, userName, password);
         	    stmt = conn.createStatement();
         	    
         	    DataViews dv = dataViewsRepository.findById(viewId.longValue());
         	    if(dv != null)
         	    {
         	    	//log.info("SumQuery: SELECT SUM(`"+qualifierField+"`) from "+schemaName+".`"+dv.getDataViewName().toLowerCase()+"` WHERE scrIds IN ("+idStr+")");
         	    	result=stmt.executeQuery("SELECT SUM(`"+qualifierField+"`) from "+schemaName+".`"+dv.getDataViewName().toLowerCase()+"` WHERE scrIds IN ("+idStr+")");
         	    	while(result.next()){
         	    		if(result.getString(1) != null)
         	    			res = result.getString(1);
         	    		else
         	    			res = res + "0";
         	    	}
         	    //	log.info("Sum of amount : "+ res);
         	    }
         	    else
         	    {
         	    	res = res + "0";
         	    	log.info("Data View Doesn't Exist");
         	    }   
        	 }catch(SQLException se){
        		   log.info("Error while executing query: "+se);
             }
        	catch(Exception e)
        	{
            	 log.info("Exception while getting databse properties");
        	}
        	finally{
        		try {
            		if(result != null)
            			result.close();	
            		if(stmt != null)
            			stmt.close();
        			if(conn != null)
        				conn.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}	

    		}
    	}
    	else
    	{
    		res = res + "0";
    	}
		return res;
    }
    /* */
    public int getCustomFilterCount(Long viewId, List<BigInteger> ids, String whereString) throws SQLException
    {
    	int totalCount = 0;
    	List<HashMap> finalMap = new ArrayList<HashMap>();
    	String idStr=ids.toString();
    	idStr=idStr.replace("[", "");
    	idStr=idStr.replace("]", "");
		// Connection to JDBC
		Connection conn = null;
		Statement stmt = null;
		ResultSet result = null; 
    	try{
    		String dbUrl=env.getProperty("spring.datasource.url");
    		String[] parts=dbUrl.split("[\\s@&?$+-]+");
    		String host = parts[0].split("/")[2].split(":")[0];
    		String schemaName=parts[0].split("/")[3];
    		String userName = env.getProperty("spring.datasource.username");
    		String password = env.getProperty("spring.datasource.password");
    		String jdbcDriver = env.getProperty("spring.datasource.jdbcdriver");
    		Class.forName(jdbcDriver);
     	    conn = DriverManager.getConnection(dbUrl, userName, password);
     	    stmt = conn.createStatement();
     	    DataViews dv = dataViewsRepository.findById(viewId.longValue());
     	    if(dv != null)
     	    {
     	    	result=stmt.executeQuery("SELECT count(*) from "+schemaName+".`"+dv.getDataViewName().toLowerCase()+"` WHERE scrIds IN ("+idStr+")"+ whereString);
     	    	while(result.next()){
     	    		totalCount = totalCount + result.getInt(1);
     	    	}
     	    }
    	}
    	catch(Exception e)
    	{
    		log.info("Exception "+e);
    	}
    	finally{
    		if(result != null)
    			result.close();	
    		if(stmt != null)
    			stmt.close();
			if(conn != null)
				conn.close();
    	}
    	return totalCount;
    }
    
    public List<BigInteger> getOriginalIdsByColumnSearch(List<BigInteger> ids, String columnSearchQuery, Long viewId) throws SQLException
    {
    	List<BigInteger> finalIds = new ArrayList<BigInteger>();
		Connection conn = null;
		Statement stmt = null;
		ResultSet result = null; 
		
    	String idStr=ids.toString();
    	idStr=idStr.replace("[", "");
    	idStr=idStr.replace("]", "");
    	
    	try{
    		String dbUrl=env.getProperty("spring.datasource.url");
    		String[] parts=dbUrl.split("[\\s@&?$+-]+");
    		String host = parts[0].split("/")[2].split(":")[0];
    		String schemaName=parts[0].split("/")[3];
    		String userName = env.getProperty("spring.datasource.username");
    		String password = env.getProperty("spring.datasource.password");
    		String jdbcDriver = env.getProperty("spring.datasource.jdbcdriver");
    		Class.forName(jdbcDriver);
     	    conn = DriverManager.getConnection(dbUrl, userName, password);
     	    stmt = conn.createStatement();
     	    DataViews dv = dataViewsRepository.findOne(viewId);
     	    if(dv != null)
     	    {
     	    	//log.info("ColumnSearchQuery:>> SELECT scrIds from "+schemaName+".`"+dv.getDataViewName().toLowerCase()+"` WHERE scrIds in("+idStr+") "+columnSearchQuery);
     	    	result=stmt.executeQuery("SELECT scrIds from "+schemaName+".`"+dv.getDataViewName().toLowerCase()+"` WHERE scrIds in("+idStr+") "+columnSearchQuery);
         	 	while(result.next()){
         	 		finalIds.add(new BigInteger((result.getString(1))));
         	 	}  
     	    }
    	}
    	catch(Exception e)
    	{
    		log.info("Exception "+e);
    	}
    	finally
    	{
    		if(result != null)
    			result.close();	
    		if(stmt != null)
    			stmt.close();
			if(conn != null)
				conn.close();
    	}
    	return finalIds;
    }
    
    public List<BigInteger> getSearchKeywordFilteredOriginalIds(List<BigInteger> ids, String searchKeyWord, String columnAsString, Long viewId) throws SQLException
    {
    	List<BigInteger> finalIds = new ArrayList<BigInteger>();
		Connection conn = null;
		Statement stmt = null;
		ResultSet result = null; 
		
    	String idStr=ids.toString();
    	idStr=idStr.replace("[", "");
    	idStr=idStr.replace("]", "");
    	
    	try{
    		String dbUrl=env.getProperty("spring.datasource.url");
    		String[] parts=dbUrl.split("[\\s@&?$+-]+");
    		String host = parts[0].split("/")[2].split(":")[0];
    		String schemaName=parts[0].split("/")[3];
    		String userName = env.getProperty("spring.datasource.username");
    		String password = env.getProperty("spring.datasource.password");
    		String jdbcDriver = env.getProperty("spring.datasource.jdbcdriver");
    		Class.forName(jdbcDriver);
     	    conn = DriverManager.getConnection(dbUrl, userName, password);
     	    stmt = conn.createStatement();
     	    DataViews dv = dataViewsRepository.findOne(viewId);
     	    if(dv != null)
     	    {
     	    	//log.info("SearchQuery: "+" SELECT scrIds from "+schemaName+"."+dv.getDataViewName().toLowerCase()+" WHERE scrIds in("+idStr+") AND concat("+columnAsString+") LIKE '%"+searchKeyWord+"%'");
     	    	result=stmt.executeQuery("SELECT scrIds from "+schemaName+".`"+dv.getDataViewName().toLowerCase()+"` WHERE scrIds in("+idStr+") AND concat("+columnAsString+") LIKE '%"+searchKeyWord+"%'");
         	 	while(result.next()){
         	 		finalIds.add(new BigInteger((result.getString(1))));
         	 	}  
     	    }
    	}
    	catch(Exception e)
    	{
    		log.info("Exception "+e);
    	}
    	finally
    	{
    		if(result != null)
    			result.close();	
    		if(stmt != null)
    			stmt.close();
			if(conn != null)
				conn.close();
    	}
    	return finalIds;
    }
    public List<BigInteger> convertLongToBig(List<Long> longIds)
    {
    	List<BigInteger> finalList = new ArrayList<BigInteger>();
    	if(longIds.size()>0)
    	{
    		for(Long id: longIds)
    		{
    			finalList.add(BigInteger.valueOf(id));
    		}
    	}
    	return finalList;
    }
    
    public List<BigInteger> getFilteredIdsForSource(List<BigInteger> ids, Long tenantId, Long dataViewId, Long limit, Long pageSize, HashMap headerColumns, Long groupId, String amtQualifier, String searchWord, String columnAsString, String exportFile, HashMap columnInfo, String sortByOrder, String columnSearchQuery, String statusNRecRefQuery, String status) throws SQLException
    {
    	List<BigInteger> filteredIds = new ArrayList<BigInteger>();
    	String idsString = ids.toString();
    	idsString = idsString.replace("[", "");
    	idsString = idsString.replace("]", "");
    	log.info("Total Ids Size: "+ids.size());
    	log.info("columnSearchQuery: "+columnSearchQuery.length());
    	log.info("statusNRecRefQuery: "+statusNRecRefQuery.length());
    	if(ids.size()>0)
    	{
    		if(columnSearchQuery.length()>0 && statusNRecRefQuery.length()>0)
    		{
    			log.info("Filtering with column search and recon reference/status...");
    			List<BigInteger> colSearchIds = getOriginalIdsByColumnSearch(ids, columnSearchQuery, dataViewId);
    			log.info("Column Search Ids Size: "+colSearchIds.size());
    			if(colSearchIds.size()>0)
    			{
    				String idString = colSearchIds.toString();
    				idString = idString.replace("]", "");
    				idString = idString.replace("[", "");
    				List<Long> recStatusIds = new ArrayList<Long>(); 
    				if("suggestion".equalsIgnoreCase(status))
    				{
    					recStatusIds = em.createQuery("SELECT originalRowId from ReconciliationSuggestionResult where reconciliationRuleGroupId = "+groupId+" and originalViewId = "+dataViewId+" and originalRowId in ("+idString+") "+statusNRecRefQuery + " order by reconReference asc", Long.class).getResultList();
    				}
    				else
    				{
    					recStatusIds = em.createQuery("SELECT originalRowId from ReconciliationResult where reconciliationRuleGroupId = "+groupId+" and originalViewId = "+dataViewId+" and originalRowId in ("+idString+") "+statusNRecRefQuery + " order by reconReference asc", Long.class).getResultList();	
    				}
    				
    				filteredIds.addAll(convertLongToBig(recStatusIds));
    			}
    			log.info("Column and Recon Reference/Status Search Ids Size: "+filteredIds.size());
    		}
    		else if(columnSearchQuery.length() == 0 && statusNRecRefQuery.length()>0)
    		{
    			log.info("Filtering with Status/Recon Reference... ");
    			List<Long> recStatusIds = new ArrayList<Long>(); 
    			if("suggestion".equalsIgnoreCase(status))
    			{
    				recStatusIds = em.createQuery("SELECT originalRowId from ReconciliationSuggestionResult where reconciliationRuleGroupId = "+groupId+" and originalViewId = "+dataViewId+" and originalRowId in ("+idsString+") "+statusNRecRefQuery +" order by reconReference asc",  Long.class).getResultList();
    			}
    			else
    			{
    				recStatusIds = em.createQuery("SELECT originalRowId from ReconciliationResult where reconciliationRuleGroupId = "+groupId+" and originalViewId = "+dataViewId+" and originalRowId in ("+idsString+") "+statusNRecRefQuery +" order by reconReference asc",  Long.class).getResultList();
    			}
    			filteredIds.addAll(convertLongToBig(recStatusIds));
    			log.info("Status/ReconReference Search Ids Size: "+ filteredIds.size());
    		}
    		else if(columnSearchQuery.length()>0 && statusNRecRefQuery.length() == 0)
    		{
    			log.info("Filtering with columns...");
    			List<BigInteger> colSearchIds = new ArrayList<BigInteger>(); 
    			colSearchIds = getOriginalIdsByColumnSearch(ids, columnSearchQuery, dataViewId);
    			filteredIds.addAll(colSearchIds);
    			log.info("Column Search Ids Size: "+ filteredIds.size());
    		}
    		else
    		{
    			log.info("No column or recon reference or status search applying..");
    			filteredIds.addAll(ids);
    		}
    	}
    	return filteredIds;
    }
    
    public List<BigInteger> getFilteredIdsForTarget(List<BigInteger> ids, Long tenantId, Long dataViewId, Long limit, Long pageSize, HashMap headerColumns, Long groupId, String amtQualifier, String searchWord, String columnAsString, String exportFile, HashMap columnInfo, String sortByOrder, String columnSearchQuery, String statusNRecRefQuery, String status) throws SQLException
    {
    	List<BigInteger> filteredIds = new ArrayList<BigInteger>();
    	String idsString = ids.toString();
    	idsString = idsString.replace("[", "");
    	idsString = idsString.replace("]", "");
    	log.info("Total Ids Size: "+ids.size());
    	if(ids.size()>0)
    	{
    		if(columnSearchQuery.length()>0 && statusNRecRefQuery.length()>0)
    		{
    			log.info("Filtering with column search and recon reference/status...");
    			List<BigInteger> colSearchIds = getOriginalIdsByColumnSearch(ids, columnSearchQuery, dataViewId);
    			log.info("Column Search Ids Size: "+colSearchIds.size());
    			if(colSearchIds.size()>0)
    			{
    				String idString = colSearchIds.toString();
    				idString = idString.replace("]", "");
    				idString = idString.replace("[", "");
    				List<Long> recStatusIds = new ArrayList<Long>(); 
    				if("suggestion".equalsIgnoreCase(status))
    				{
    					recStatusIds = em.createQuery("SELECT targetRowId from ReconciliationSuggestionResult where reconciliationRuleGroupId = "+groupId+" and targetViewId = "+dataViewId+" and targetRowId in ("+idString+") "+statusNRecRefQuery+" order by reconReference asc", Long.class).getResultList();		
    				}
    				else
    				{
    					recStatusIds = em.createQuery("SELECT targetRowId from ReconciliationResult where reconciliationRuleGroupId = "+groupId+" and targetViewId = "+dataViewId+" and targetRowId in ("+idString+") "+statusNRecRefQuery+" order by reconReference asc", Long.class).getResultList();
    				}
    				filteredIds.addAll(convertLongToBig(recStatusIds));
    			}
    			log.info("Column and Recon Reference/Status Search Ids Size: "+filteredIds.size());
    		}
    		else if(columnSearchQuery.length() == 0 && statusNRecRefQuery.length()>0)
    		{
    			log.info("Filtering with Status/Recon Reference... ");
    			List<Long> recStatusIds = new ArrayList<Long>(); 
    			if("suggestion".equalsIgnoreCase(status))
    			{
    				recStatusIds = em.createQuery("SELECT targetRowId from ReconciliationSuggestionResult where reconciliationRuleGroupId = "+groupId+" and targetViewId = "+dataViewId+" and targetRowId in ("+idsString+") "+statusNRecRefQuery+" order by reconReference asc", Long.class).getResultList();
    			}
    			else
    			{
    				recStatusIds = em.createQuery("SELECT targetRowId from ReconciliationResult where reconciliationRuleGroupId = "+groupId+" and targetViewId = "+dataViewId+" and targetRowId in ("+idsString+") "+statusNRecRefQuery +" order by reconReference asc", Long.class).getResultList();
    			}
    			filteredIds.addAll(convertLongToBig(recStatusIds));
    			log.info("Recon Reference/Status Search Ids Size: "+filteredIds.size());
    		}
    		else if(columnSearchQuery.length()>0 && statusNRecRefQuery.length() == 0)
    		{
    			log.info("Filtering with columns...");
    			List<BigInteger> colSearchIds = new ArrayList<BigInteger>(); 
    			colSearchIds = getOriginalIdsByColumnSearch(ids, columnSearchQuery, dataViewId);
    			filteredIds.addAll(colSearchIds);
    			log.info("Column Search Ids Size: "+ filteredIds.size());
    		}
    		else
    		{
    			log.info("No column or recon reference or status search applying..");
    			filteredIds.addAll(ids);
    		}
    	}
    	return filteredIds;
    }
    
    public List<LinkedHashMap> getReconData(Map<String, List<BigInteger>> recUnrecIds, String status, Long tenantId, Long dataViewId, Long limit, Long pageSize, HashMap headerColumns, Long groupId, String amtQualifier, String searchWord, String columnAsString, String exportFile, HashMap columnInfo, String sortByOrder, String columnSearchQuery, String statusNRecRefQuery) throws ClassNotFoundException, SQLException, java.text.ParseException
    {
    	List<LinkedHashMap> finalList = new ArrayList<LinkedHashMap>();
    	HashMap info = new HashMap();
    	LinkedHashMap recMain = new LinkedHashMap();
    	
		if("reconciled".equalsIgnoreCase(status) || "suggestion".equalsIgnoreCase(status))
		{
			log.info("Fetching recociled data . .");
	    	List<BigInteger> recIds = recUnrecIds.get("reconciled");
	    	if(recIds.size()>0)
	    	{
	    		if(searchWord != null)
	    		{
	    			log.info("Filtering reconciled data with column search keyword...");
	    			List<BigInteger> searchIds = getSearchKeywordFilteredOriginalIds(recIds, searchWord, columnAsString,dataViewId);
	    			log.info("Reconciled Search Keyword ids: "+searchIds.size());
	    			List<BigInteger> filterIds = getFilteredIdsForSource(searchIds, tenantId, dataViewId, limit, pageSize, headerColumns, groupId, amtQualifier, searchWord, columnAsString, exportFile, columnInfo, sortByOrder, columnSearchQuery, statusNRecRefQuery, status);
	    			if(filterIds.size()>0)
	    			{
	    				finalList = reconciliationResultService.fetchDataByViewIdInSequence(dataViewId, filterIds, limit, pageSize, headerColumns, "source", tenantId, groupId, "", exportFile,columnInfo.get("columnName").toString(),columnInfo.get("dataType").toString(),sortByOrder, status);
	    			}
	    			info.put("totalCount", filterIds.size());
	    		}
	    		else
	    		{
	    			List<BigInteger> filterIds = getFilteredIdsForSource(recIds, tenantId, dataViewId, limit, pageSize, headerColumns, groupId, amtQualifier, searchWord, columnAsString, exportFile, columnInfo, sortByOrder, columnSearchQuery, statusNRecRefQuery, status);
	    			if(filterIds.size()>0)
	    			{
	    				finalList = reconciliationResultService.fetchDataByViewIdInSequence(dataViewId, filterIds, limit, pageSize, headerColumns, "source", tenantId, groupId, "", exportFile,columnInfo.get("columnName").toString(),columnInfo.get("dataType").toString(),sortByOrder,status);
	    			}
	    			info.put("totalCount", filterIds.size());
	    		}
	    	}
	    	info.put("amountQualifier", amtQualifier);
	    	recMain.put("info", info);
	    	finalList.add(recMain);
	    	return finalList;
		}
		else if("unreconciled".equalsIgnoreCase(status))
		{
			log.info("Fetching Un Reconciled data . .");
	    	List<BigInteger> unRecIds = recUnrecIds.get("unReconciled");
	    	if(unRecIds.size()>0)
	    	{
	    		if(searchWord != null)
	    		{
	    			List<BigInteger> searchIds = getSearchKeywordFilteredOriginalIds(unRecIds, searchWord, columnAsString,dataViewId);
	    			log.info("UnReconciled Search Keyword ids: "+searchIds.size());
	    			List<BigInteger> filterIds = getFilteredIdsForSource(searchIds, tenantId, dataViewId, limit, pageSize, headerColumns, groupId, amtQualifier, searchWord, columnAsString, exportFile, columnInfo, sortByOrder, columnSearchQuery, statusNRecRefQuery, status);
	    			if(filterIds.size()>0)
	    			{
	    				finalList = reconciliationResultService.fetchDataByViewIdInSequence(dataViewId, filterIds, limit, pageSize, headerColumns, "source", tenantId, groupId, "", exportFile,columnInfo.get("columnName").toString(),columnInfo.get("dataType").toString(),sortByOrder,status);
	    			}
	    			info.put("totalCount", filterIds.size());
	    		}
	    		else
	    		{
	    			List<BigInteger> filterIds = getFilteredIdsForSource(unRecIds, tenantId, dataViewId, limit, pageSize, headerColumns, groupId, amtQualifier, searchWord, columnAsString, exportFile, columnInfo, sortByOrder, columnSearchQuery, statusNRecRefQuery, status);
	    			if(filterIds.size()>0)
	    			{
	    				log.info("dataViewId: "+dataViewId);
	    				log.info("filterIds: "+filterIds.size());
	    				log.info("columnInfo.get('columnName').toString(): "+columnInfo.get("columnName"));
	    				log.info("columnInfo.get('dataType').toString(): "+columnInfo.get("dataType"));
	    				finalList = reconciliationResultService.fetchDataByViewIdInSequence(dataViewId, filterIds, limit, pageSize, headerColumns, "source", tenantId, groupId, "", exportFile,columnInfo.get("columnName").toString(),columnInfo.get("dataType").toString(),sortByOrder,status);
	    			}
	    			info.put("totalCount", filterIds.size());
	    		}
	    	}
	    	info.put("amountQualifier", amtQualifier);
	    	recMain.put("info", info);
	    	finalList.add(recMain);
	    	return finalList;
		}
		else
		{
			log.info("Fetching total data . .");
	    	List<BigInteger> totalIds = recUnrecIds.get("totalIds");
	    	if(totalIds.size()>0)
	    	{
	    		if(searchWord != null)
	    		{
	    			List<BigInteger> searchIds = getSearchKeywordFilteredOriginalIds(totalIds, searchWord, columnAsString,dataViewId);
	    			log.info("Total Search Keyword ids: "+searchIds.size());
	    			List<BigInteger> filterIds = getFilteredIdsForSource(searchIds, tenantId, dataViewId, limit, pageSize, headerColumns, groupId, amtQualifier, searchWord, columnAsString, exportFile, columnInfo, sortByOrder, columnSearchQuery, statusNRecRefQuery, status);
	    			if(filterIds.size()>0)
	    			{
	    				finalList = reconciliationResultService.fetchDataByViewIdInSequence(dataViewId, filterIds, limit, pageSize, headerColumns, "source", tenantId, groupId, "", exportFile,columnInfo.get("columnName").toString(),columnInfo.get("dataType").toString(),sortByOrder,status);
	    			}
	    			info.put("totalCount", filterIds.size());
	    		}
	    		else
	    		{
	    			List<BigInteger> filterIds = getFilteredIdsForSource(totalIds, tenantId, dataViewId, limit, pageSize, headerColumns, groupId, amtQualifier, searchWord, columnAsString, exportFile, columnInfo, sortByOrder, columnSearchQuery, statusNRecRefQuery, status);
	    			if(filterIds.size()>0)
	    			{
	    				finalList = reconciliationResultService.fetchDataByViewIdInSequence(dataViewId, filterIds, limit, pageSize, headerColumns, "source", tenantId, groupId, "", exportFile,columnInfo.get("columnName").toString(),columnInfo.get("dataType").toString(),sortByOrder,status);
	    			}
	    			info.put("totalCount", filterIds.size());
	    		}
	    	}
	    	info.put("amountQualifier", amtQualifier);
	    	recMain.put("info", info);
	    	finalList.add(recMain);
	    	return finalList;
		}
    }
    
    public List<LinkedHashMap> getReconDataTarget(Map<String, List<BigInteger>> recUnrecIds, String status, Long tenantId, Long dataViewId, Long limit, Long pageSize, HashMap headerColumns, Long groupId, String amtQualifier, String searchWord,String columnAsString, String exportFile, HashMap columnInfo, String sortByOrder, String columnSearchQuery,String statusNRecRefQuery) throws ClassNotFoundException, SQLException, java.text.ParseException
    {
    	List<LinkedHashMap> finalList = new ArrayList<LinkedHashMap>();
    	HashMap info = new HashMap();
    	LinkedHashMap recMain = new LinkedHashMap();
		if("reconciled".equalsIgnoreCase(status) || "suggestion".equalsIgnoreCase(status))
		{
			log.info("Fetching recociled data . .");
	    	List<BigInteger> recIds = recUnrecIds.get("reconciled");
	    	if(recIds.size()>0)
	    	{
	    		if(searchWord != null)
	    		{
	    			List<BigInteger> searchIds = getSearchKeywordFilteredOriginalIds(recIds, searchWord, columnAsString,dataViewId);
	    			List<BigInteger> filterIds = getFilteredIdsForTarget(searchIds, tenantId, dataViewId, limit, pageSize, headerColumns, groupId, amtQualifier, searchWord, columnAsString, exportFile, columnInfo, sortByOrder, columnSearchQuery, statusNRecRefQuery, status);
	    			if(filterIds.size()>0)
	    			{
	    				finalList = reconciliationResultService.fetchDataByViewIdInSequence(dataViewId, filterIds, limit, pageSize, headerColumns, "target", tenantId, groupId, "", exportFile,columnInfo.get("columnName").toString(),columnInfo.get("dataType").toString(),sortByOrder, status);
	    			}
	    			info.put("totalCount", filterIds.size());
	    		}
	    		else
	    		{
	    			List<BigInteger> filterIds = getFilteredIdsForTarget(recIds, tenantId, dataViewId, limit, pageSize, headerColumns, groupId, amtQualifier, searchWord, columnAsString, exportFile, columnInfo, sortByOrder, columnSearchQuery, statusNRecRefQuery, status);
	    			if(filterIds.size()>0)
	    			{
	    				finalList = reconciliationResultService.fetchDataByViewIdInSequence(dataViewId, filterIds, limit, pageSize, headerColumns, "target", tenantId, groupId, "", exportFile,columnInfo.get("columnName").toString(),columnInfo.get("dataType").toString(),sortByOrder, status);
	    			}
	    			info.put("totalCount", filterIds.size());
	    		}
	    	}
	    	info.put("amountQualifier", amtQualifier);
	    	recMain.put("info", info);
	    	finalList.add(recMain);
	    	return finalList;
		}
		else if("unreconciled".equalsIgnoreCase(status))
		{
			log.info("Fetching Un Reconciled data . .");
	    	List<BigInteger> unRecIds = recUnrecIds.get("unReconciled");
	    	if(unRecIds.size()>0)
	    	{
	    		if(searchWord != null)
	    		{
	    			List<BigInteger> searchIds = getSearchKeywordFilteredOriginalIds(unRecIds, searchWord, columnAsString,dataViewId);
	    			List<BigInteger> filterIds = getFilteredIdsForTarget(searchIds, tenantId, dataViewId, limit, pageSize, headerColumns, groupId, amtQualifier, searchWord, columnAsString, exportFile, columnInfo, sortByOrder, columnSearchQuery, statusNRecRefQuery, status);
	    			if(filterIds.size()>0)
	    			{
	    				finalList = reconciliationResultService.fetchDataByViewIdInSequence(dataViewId, filterIds, limit, pageSize, headerColumns, "target", tenantId, groupId, "", exportFile,columnInfo.get("columnName").toString(),columnInfo.get("dataType").toString(),sortByOrder,status);
	    			}
	    			info.put("totalCount", filterIds.size());
	    		}
	    		else
	    		{
	    			List<BigInteger> filterIds = getFilteredIdsForTarget(unRecIds, tenantId, dataViewId, limit, pageSize, headerColumns, groupId, amtQualifier, searchWord, columnAsString, exportFile, columnInfo, sortByOrder, columnSearchQuery, statusNRecRefQuery, status);
	    			if(filterIds.size()>0)
	    			{
	    				finalList = reconciliationResultService.fetchDataByViewIdInSequence(dataViewId, filterIds, limit, pageSize, headerColumns, "target", tenantId, groupId, "", exportFile,columnInfo.get("columnName").toString(),columnInfo.get("dataType").toString(),sortByOrder,status);
	    			}
	    			info.put("totalCount", filterIds.size());
	    		}
	    	}
	    	info.put("amountQualifier", amtQualifier);
	    	recMain.put("info", info);
	    	finalList.add(recMain);
	    	return finalList;
		}
		else
		{
			log.info("Fetching total data . .");
	    	List<BigInteger> totalIds = recUnrecIds.get("totalIds");
	    	if(totalIds.size()>0)
	    	{
	    		if(searchWord != null)
	    		{
	    			List<BigInteger> searchIds = getSearchKeywordFilteredOriginalIds(totalIds, searchWord, columnAsString,dataViewId);
	    			List<BigInteger> filterIds = getFilteredIdsForTarget(searchIds, tenantId, dataViewId, limit, pageSize, headerColumns, groupId, amtQualifier, searchWord, columnAsString, exportFile, columnInfo, sortByOrder, columnSearchQuery, statusNRecRefQuery, status);
	    			if(filterIds.size()>0)
	    			{
	    				finalList = reconciliationResultService.fetchDataByViewIdInSequence(dataViewId, filterIds, limit, pageSize, headerColumns, "target", tenantId, groupId, "", exportFile,columnInfo.get("columnName").toString(),columnInfo.get("dataType").toString(),sortByOrder,status);
	    			}
	    			info.put("totalCount", filterIds.size());
	    		}
	    		else
	    		{
	    			List<BigInteger> filterIds = getFilteredIdsForTarget(totalIds, tenantId, dataViewId, limit, pageSize, headerColumns, groupId, amtQualifier, searchWord, columnAsString, exportFile, columnInfo, sortByOrder, columnSearchQuery, statusNRecRefQuery, status);
	    			if(filterIds.size()>0)
	    			{
	    				finalList = reconciliationResultService.fetchDataByViewIdInSequence(dataViewId, filterIds, limit, pageSize, headerColumns, "target", tenantId, groupId, "", exportFile,columnInfo.get("columnName").toString(),columnInfo.get("dataType").toString(),sortByOrder,status);
	    			}
	    			info.put("totalCount", filterIds.size());
	    		}
	    	}
	    	info.put("amountQualifier", amtQualifier);
	    	recMain.put("info", info);
	    	finalList.add(recMain);
	    	return finalList;
		}
    }
    
    /*Fetching Reconciliation Data in Sequencing Order*/
    public List<LinkedHashMap> fetchDataByViewIdInSequence(Long viewId, List<BigInteger> ids, Long pageStartIndx, Long pageSize, HashMap headerColumns, String sourceOrTarget, Long tenantId, Long groupId, String whereString, String exportFile, String columnName, String dataType, String sortByOrder, String typeOfReconData) throws ClassNotFoundException, SQLException, java.text.ParseException
    {
    	log.info("Fetching data based on view id with proper sequence order for the status: "+typeOfReconData);
    	headerColumns.remove("Status");
    	List<LinkedHashMap> finalMap = new ArrayList<LinkedHashMap>();
    	Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
    	String currencyFormat = props.getProperty("currencyFormat");
    	String idStr=ids.toString();
    	idStr = idStr.replace(" ", "");
    	idStr=idStr.replace("[", "");
    	idStr=idStr.replace("]", "");
    	log.info("pageStartIndx: "+ pageStartIndx);
    	log.info("pageSize: "+ pageSize);
		Connection conn = null;
		Statement stmt = null;
		ResultSet result = null; 
    	try{
    		String dbUrl=env.getProperty("spring.datasource.url");
    		String[] parts=dbUrl.split("[\\s@&?$+-]+");
    		String host = parts[0].split("/")[2].split(":")[0];
    		String schemaName=parts[0].split("/")[3];
    		String userName = env.getProperty("spring.datasource.username");
    		String password = env.getProperty("spring.datasource.password");
    		String jdbcDriver = env.getProperty("spring.datasource.jdbcdriver");
    		Class.forName(jdbcDriver);
     	    conn = DriverManager.getConnection(dbUrl, userName, password);
     	    stmt = conn.createStatement();
     	    log.info("Successfully connected to JDBC");
     	    DataViews dv = dataViewsRepository.findById(viewId.longValue());
     	    List<HashMap> dataMap = new ArrayList<HashMap>();

     	    if(dv != null)
     	    {
     	    	log.info("View Name: "+ dv.getDataViewName());
     	    	if(exportFile != null)
     	    	{
     	    		log.info("Fetching data with pagination export file...");
     	    		log.info("SELECT * from "+schemaName+".`"+dv.getDataViewName().toLowerCase()+"` WHERE scrIds IN ("+idStr+")");
     	    		result=stmt.executeQuery("SELECT * from "+schemaName+".`"+dv.getDataViewName().toLowerCase()+"` WHERE scrIds IN ("+idStr+")");
     	    	}
     	    	else
     	    	{
         	    	log.info("Fetching Data with pagination.....");
         	    	if(pageSize>0)
         	    		result=stmt.executeQuery("SELECT * from "+schemaName+".`"+dv.getDataViewName().toLowerCase()+"` WHERE scrIds IN ("+idStr+") order by `"+columnName+"` "+ sortByOrder +" limit "+pageStartIndx+", "+ pageSize);
         	    	else
         	    		result=stmt.executeQuery("SELECT * from "+schemaName+".`"+dv.getDataViewName().toLowerCase()+"` WHERE scrIds IN ("+idStr+") order by `"+columnName+"` "+ sortByOrder);
     	    	}

     	    	ResultSetMetaData rsmd = result.getMetaData();
     	    	int colCount = rsmd.getColumnCount();
     	    	log.info("Column Count: "+ colCount);
     	    	while(result.next()){
     	    		HashMap hm = new HashMap();
     	    		for(int i=1; i<=colCount; i++)
     	    		{
     	    			hm.put(rsmd.getColumnName(i), result.getString(i));
     	    		}
     	    		dataMap.add(hm);
     	    	}
     	    	log.info("Data Size: "+ dataMap.size());
     	    }
     	    if(dataMap.size()>0)
     	    {
     	    	for(HashMap hm : dataMap)
     	    	{
     	    		Long id = Long.parseLong(hm.get("scrIds").toString());
     	    		List<LinkedHashMap> reconDataList = new ArrayList<LinkedHashMap>();
     	    		LinkedHashMap reconData = new LinkedHashMap();
     	    		reconData.put("Id", id);
    	     	    for(Object key : headerColumns.keySet())	// Adding data view columns
    	     	    {
    	     	    	if(hm.get(key.toString()) != null)
    	     	    	{
    	     	    		reconData.put(headerColumns.get(key.toString()), hm.get(key.toString()));
    	     	    	}
    	     	    }
    	     	    if("source".equalsIgnoreCase(sourceOrTarget))
    	     	    {
    	     	    	if("suggestion".equalsIgnoreCase(typeOfReconData))
    	     	    	{
    	     	    		List<ReconciliationDuplicateResult> rsDuplicates = new ArrayList<ReconciliationDuplicateResult>();
    	     	    		rsDuplicates = reconciliationDuplicateResultRepository.fetchSourceUniqueRecord(id, tenantId, viewId, groupId);
    	     	    		if(rsDuplicates.size()>0)
    						{
    							for(ReconciliationDuplicateResult rsDuplicate : rsDuplicates)
    							{
    								LinkedHashMap recSugg = new LinkedHashMap();
    								recSugg = (LinkedHashMap) reconData.clone();
    	    						Rules rule = rulesRepository.findOne(rsDuplicate.getReconciliationRuleId());
    	    						if(rule != null)
    	    						{
    	    							recSugg.put("Rule_Name", rule.getRuleCode());
    	    						}
    	    						recSugg.put("Rule Id", rsDuplicate.getReconciliationRuleId());
    	    						recSugg.put("Job Reference", rsDuplicate.getReconJobReference());
    	    						recSugg.put("reconReference", rsDuplicate.getReconReference());
    	    						reconDataList.add(recSugg);
    							}
    						}
    	     	    	}
    	     	    	else
    	     	    	{
    	     	    		ReconciliationResult rs = reconciliationResultRepository.fetchSourceUniqueRecord(id, tenantId, viewId, groupId);
    	     	    		if(rs != null)
    	     	    		{
	    						Rules rule = rulesRepository.findOne(rs.getReconciliationRuleId());
	    						if(rule != null)
	    						{
	    							reconData.put("Rule_Name", rule.getRuleCode());
	    						}
	    						else
	    						{
	    							reconData.put("Rule_Name", "MANUAL");
	    						}
	    						reconData.put("Rule Id", rs.getReconciliationRuleId());
	    						reconData.put("Job Reference", rs.getReconJobReference());
	    						reconData.put("reconReference", rs.getReconReference());
	    						reconData.put("Status", "R");
	    						reconData.put("Final Status", rs.getFinalStatus());
    	     	    		}
    	     	    		reconDataList.add(reconData);
    	     	    	}
    	     	    }
    	     	    else if("target".equalsIgnoreCase(sourceOrTarget))
    	     	    {
    	     	    	if("suggestion".equalsIgnoreCase(typeOfReconData))
    	     	    	{
    	     	    		List<ReconciliationDuplicateResult> rsDuplicates = reconciliationDuplicateResultRepository.fetchTargetUniqueRecord(id, tenantId, viewId, groupId);
    	     	    		if(rsDuplicates.size()>0)
    	     	    		{
	    						for(ReconciliationDuplicateResult rsDuplicate : rsDuplicates)
	    						{
	    							LinkedHashMap recSugg = new LinkedHashMap();
	    							recSugg = (LinkedHashMap) reconData.clone();
    	    						Rules rule = rulesRepository.findOne(rsDuplicate.getReconciliationRuleId());
    	    						if(rule != null)
    	    						{
    	    							recSugg.put("Rule_Name", rule.getRuleCode());
    	    						}
    	    						recSugg.put("Rule Id", rsDuplicate.getReconciliationRuleId());
    	    						recSugg.put("Job Reference", rsDuplicate.getReconJobReference());
    	    						recSugg.put("reconReference", rsDuplicate.getReconReference());
    	    						reconDataList.add(recSugg);
	    						}
    	     	    		}
    	     	    	}
    	     	    	else
    	     	    	{
    	     	    		ReconciliationResult rs = reconciliationResultRepository.fetchTargetUniqueRecord(id, tenantId, viewId, groupId);
	    					if(rs != null)
	    					{
	    						log.info("Source suggestion block2");
	    						Rules rule = rulesRepository.findOne(rs.getReconciliationRuleId());
	    						if(rule != null)
	    						{
	    							reconData.put("Rule_Name", rule.getRuleCode());
	    						}
	    						else
	    						{
	    							reconData.put("Rule_Name", "MANUAL");
	    						}
	    						reconData.put("Rule Id", rs.getReconciliationRuleId());
	    						reconData.put("Job Reference", rs.getReconJobReference());
	    						reconData.put("reconReference", rs.getReconReference());
	    						reconData.put("Status", "R");
	    						reconData.put("Final Status", rs.getFinalStatus());
	    					}
	    					reconDataList.add(reconData);
    	     	    	}
    	     	    }
    	     	  finalMap.addAll(reconDataList);
     	    	}
     	    }
    	}
    	catch(Exception e)
    	{
    		log.info("Exceptin while fetching data: "+ e);
    	}
    	finally
    	{
    		if(result != null)
    			result.close();	
    		if(stmt != null)
    			stmt.close();
			if(conn != null)
				conn.close();
    	}
    	return finalMap;
    }

    /*Getting View Name based on View Id*/
    public String getViewNameByViewId(Long viewId)
    {
    	String dataViewName = "";
    	DataViews dv = dataViewsRepository.findOne(viewId);
    	if(dv != null)
    	{
    		dataViewName = dv.getDataViewDispName();
    	}
    	log.info("View Id : " + viewId+", View Name: "+ dataViewName);
    	return dataViewName;
    }
    public String getColumnsAsString(HashMap colsMap)
    {
    	String finalString = "";
    	Iterator it = colsMap.entrySet().iterator();
    	while (it.hasNext()) {
    	        Map.Entry pair = (Map.Entry)it.next();
    	        // System.out.println(pair.getKey() + " = " + pair.getValue());
    	        finalString = finalString+"dv.`"+pair.getKey().toString()+"`,";
    	        //it.remove();
    	}
    	finalString = finalString.substring(0, finalString.length()-1);
    	return finalString;
    }
    
    public HashMap getColumnInfobyIds(List<BigInteger> colIds)
    {
    	HashMap finalMap = new HashMap();
		for(BigInteger id : colIds)
		{
			DataViewsColumns dc = dataViewsColumnsRepository.findOne(id.longValue());
			if(dc != null)
			{
				if("File Template".equalsIgnoreCase(dc.getRefDvType()))
				{
					FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dc.getRefDvColumn().toString()));
					if(ftl != null)
					{
						finalMap.put(ftl.getColumnAlias(), dc.getColumnName());
					}
				}
				else if("Data View".equalsIgnoreCase(dc.getRefDvType()) || dc.getRefDvType() == null)
				{
					finalMap.put(dc.getColumnName(), dc.getColumnName());
				}
			}
		}
		log.info("finalMap: "+finalMap);
		return finalMap;
    }
    
    public HashMap<BigInteger, String> getRecSequenceColumns(Long viewId, Long groupId, Long tenantId, String sourceOrTarget)
    {
    	HashMap<BigInteger, String> seqCols = new HashMap<BigInteger, String>();
    	log.info("In service for getting column headers in sequence");
    	List<BigInteger> ruleIds = ruleGroupDetailsRepository.fetchRuleIdsByGroupAndTenantId(groupId, tenantId);
    	log.info("Rule Ids "+ ruleIds+" for the group id "+ groupId);
    	if(ruleIds.size()>0)
    	{
    		if("source".equalsIgnoreCase(sourceOrTarget))
    		{
    			log.info("In Source : "+ viewId);
    			List<BigInteger> ids = rulesRepository.fetchIdsBySourceViewIdAndIds(tenantId, viewId, ruleIds);
    			log.info("Rule Ids "+ ids +" tagged to source view id"+ viewId);
    			if(ids.size()>0)
    			{
    				List<BigInteger> sColumnIds = ruleConditionsRepository.fetchSourceColumnIdsByRuleIds(ids);
    				log.info("Source Column Ids: "+ sColumnIds+" for Source View Id: "+viewId);
    				if(sColumnIds.size()>0 && !sColumnIds.contains(null))
    				{
    		   			for(BigInteger id : sColumnIds)
    		   			{
    		   				DataViewsColumns dc = dataViewsColumnsRepository.findOne(id.longValue());
    		   				if(dc != null)
    		   				{
    							if("File Template".equalsIgnoreCase(dc.getRefDvType()))
    							{
        							FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dc.getRefDvColumn().toString()));
        							if(ftl != null)
        							{
        								seqCols.put(id, ftl.getColumnAlias());
        							}
    							}
    							else if("Data View".equalsIgnoreCase(dc.getRefDvType()) || dc.getRefDvType() == null)
    							{
    								seqCols.put(id, dc.getColumnName());
    							}
    		   				}
    		   			}
    				}
    			}
    		}
    		else if("target".equalsIgnoreCase(sourceOrTarget))
    		{
    			log.info("In Target : "+ viewId);
    			List<BigInteger> ids = rulesRepository.fetchIdsByTargetViewIdAndIds(tenantId, viewId, ruleIds);
    			log.info("Rule Ids "+ ids + " which are tagged to target view id : "+ ids);
    			if(ids.size()>0)
    			{
    				List<BigInteger> tColumnIds = ruleConditionsRepository.fetchTargetColumnIdsByRuleIds(ids);
    				log.info("Target view id "+viewId+"Target Column Ids: "+ tColumnIds);
    				if(tColumnIds.size()>0 && !tColumnIds.contains(null))
    				{
    		   			for(BigInteger id : tColumnIds)
    		   			{
    		   				DataViewsColumns dc = dataViewsColumnsRepository.findOne(id.longValue());
    		   				if(dc != null)
    		   				{		 
       							if("File Template".equalsIgnoreCase(dc.getRefDvType()))
    							{
        							FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dc.getRefDvColumn().toString()));
        							if(ftl != null)
        							{
        								seqCols.put(id, ftl.getColumnAlias());
        							}
    							}
    							else if("Data View".equalsIgnoreCase(dc.getRefDvType()) || dc.getRefDvType() == null)
    							{
    								seqCols.put(id, dc.getColumnName());
    							}
    		   				}
    		   			}	
    				}
    			}
    		}
    	}
    	return seqCols;
    }
    /*Getting data view column alias names in sequence order*/
    public List<String> getViewColumnHeadersInSequence(Long viewId, Long groupId, Long tenantId, String sourceOrTarget)
    {
    	log.info("In service for getting column headers in sequence");
    	List<String> colNames = new ArrayList<String>();
    	List<BigInteger> ruleIds = ruleGroupDetailsRepository.fetchRuleIdsByGroupAndTenantId(groupId, tenantId);
    	log.info("Rule Ids "+ ruleIds+" for the group id "+ groupId);
    	List<BigInteger> allViewColIds = dataViewsColumnsRepository.fetchIdsByDataViewId(viewId);
    	log.info("All View Column Ids: "+ allViewColIds);
    	List<String> sysColumns = new ArrayList<String>();
    	sysColumns.add("Recon Ref Id");
    	sysColumns.add("Status");
    	List<BigInteger> remainingSequence = new ArrayList<BigInteger>();
    	if(ruleIds.size()>0)
    	{
    		if("source".equalsIgnoreCase(sourceOrTarget))
    		{
    			log.info("In Source : "+ viewId);
    			List<BigInteger> ids = rulesRepository.fetchIdsBySourceViewIdAndIds(tenantId, viewId, ruleIds);
    			log.info("Rule Ids "+ ids +" tagged to source view id"+ viewId);
    			if(ids.size()>0)
    			{
    				List<BigInteger> sColumnIds = ruleConditionsRepository.fetchSourceColumnIdsByRuleIds(ids);
    				sColumnIds.remove(null);
    				log.info("Source Column Ids: "+ sColumnIds+" for Source View Id: "+viewId);
    				if(sColumnIds.size()>0)
    				{
    	    			List<String> dvc = dataViewsColumnsRepository.fetchFileTemplateLineIdsByIds(sColumnIds);
    	    			List<String> seqColumns = new ArrayList<String>();
    	    	    	if(dvc.size()>0)
    	    	    	{
    	    	    		List<Long> idsAsLong = new ArrayList<Long>();
    	    	    		for(String idString : dvc)
    	    	    		{
    	    	    			idsAsLong.add(Long.parseLong(idString));
    	    	    		}
    	    	    		seqColumns = fileTemplateLinesRepository.fetchColumnAliasByIds(idsAsLong);
    	    	    		log.info("Sequence Columns "+ seqColumns);
    	    	    		colNames.addAll(seqColumns);
    	    	    	}
    				}
    				colNames.addAll(sysColumns);
    				log.info("System Columns: "+sysColumns);
    				if(allViewColIds.size()>0)
    				{
    					for(BigInteger id : allViewColIds)
    					{
    						if(!sColumnIds.contains(id))
    						{
    							remainingSequence.add(id);
    						}
    					}
    				}
    				log.info("Sourece View id: "+ viewId + ", Remaining Column Ids: "+ remainingSequence);
    				if(remainingSequence.size()>0)
    				{
    	    			List<String> dvc = dataViewsColumnsRepository.fetchFileTemplateLineIdsByIds(remainingSequence);
    	    			List<String> remainingColumns = new ArrayList<String>();
    	    	    	if(dvc.size()>0)
    	    	    	{
    	    	    		List<Long> idsAsLong = new ArrayList<Long>();
    	    	    		for(String idString : dvc)
    	    	    		{
    	    	    			idsAsLong.add(Long.parseLong(idString));
    	    	    		}
    	    	    		remainingColumns = fileTemplateLinesRepository.fetchColumnAliasByIds(idsAsLong);
    	    	    		log.info("Remaining Columns "+ remainingColumns);
    	    	    		colNames.addAll(remainingColumns);
    	    	    	}
    	    	    	log.info("Source View Id: "+ viewId + ", Remaining Columns: "+ remainingColumns);
    				}
    			}
    		}
    		else if("target".equalsIgnoreCase(sourceOrTarget))
    		{
    			log.info("In Target : "+ viewId);
    			List<BigInteger> ids = rulesRepository.fetchIdsByTargetViewIdAndIds(tenantId, viewId, ruleIds);
    			log.info("Rule Ids "+ ids + " which are tagged to target view id : "+ ids);
    			if(ids.size()>0)
    			{
    				List<BigInteger> tColumnIds = ruleConditionsRepository.fetchTargetColumnIdsByRuleIds(ids);
    				tColumnIds.remove(null);
    				log.info("Target view id "+viewId+"Target Column Ids: "+ tColumnIds);
    				if(tColumnIds.size()>0)
    				{
    	    			List<String> dvc = dataViewsColumnsRepository.fetchFileTemplateLineIdsByIds(tColumnIds);
    	    			List<String> seqColumns = new ArrayList<String>();
    	    	    	if(dvc.size()>0)
    	    	    	{
    	    	    		List<Long> idsAsLong = new ArrayList<Long>();
    	    	    		for(String idString : dvc)
    	    	    		{
    	    	    			idsAsLong.add(Long.parseLong(idString));
    	    	    		}
    	    	    		seqColumns = fileTemplateLinesRepository.fetchColumnAliasByIds(idsAsLong);
    	    	    		log.info("Target View Id"+viewId+"Sequence Columns "+ seqColumns);
    	    	    		colNames.addAll(seqColumns);
    	    	    	}
    				}
    				colNames.addAll(sysColumns);
    				log.info("System Columns Columns "+ sysColumns);
    				if(allViewColIds.size()>0)
    				{
    					for(BigInteger id : allViewColIds)
    					{
    						if(!tColumnIds.contains(id))
    						{
    							remainingSequence.add(id);
    						}
    					}
    				}
    				log.info("View Id : "+ viewId + ", Remaining Column Ids "+ remainingSequence);
    				if(remainingSequence.size()>0)
    				{
    	    			List<String> dvc = dataViewsColumnsRepository.fetchFileTemplateLineIdsByIds(remainingSequence);
    	    			List<String> remainingColumns = new ArrayList<String>();
    	    	    	if(dvc.size()>0)
    	    	    	{
    	    	    		List<Long> idsAsLong = new ArrayList<Long>();
    	    	    		for(String idString : dvc)
    	    	    		{
    	    	    			idsAsLong.add(Long.parseLong(idString));
    	    	    		}
    	    	    		remainingColumns = fileTemplateLinesRepository.fetchColumnAliasByIds(idsAsLong);
    	    	    		log.info("Target View Id "+viewId+"Remaining Columns "+ remainingColumns);
    	    	    		colNames.addAll(remainingColumns);
    	    	    	}
    				}
    			}
    		}
    	}
    	else
    	{
    		log.info("No Rule Ids found for the group id: "+ groupId);
    	}
    	return colNames;
    }
    
    public String getColumnNamesAsString(Long dataViewId)
    {
    	String columnString = "";
    	List<DataViewsColumns> dvcs = dataViewsColumnsRepository.findByDataViewId(dataViewId);
    	if(dvcs.size()>0)
    	{
    		for(DataViewsColumns dvc : dvcs)
    		{
				if("File Template".equalsIgnoreCase(dvc.getRefDvType()))
				{
					FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dvc.getRefDvColumn().toString()));
					if(ftl != null)
					{
						columnString = columnString + ftl.getColumnAlias()+", ";
					}
				}
				else if("Data View".equalsIgnoreCase(dvc.getRefDvType()) || dvc.getRefDvType() == null)
				{
					columnString = columnString + dvc.getColumnName()+", ";
				}
    		}
    		columnString = columnString.substring(0, columnString.length()-2);
    		//log.info("Column As String: "+ columnString);
    	}
    	return columnString;
    }
    
    
    /*Getting data view column alias and names map in sequence order*/
    public LinkedHashMap getColHeadersMapInSequence(Long viewId, Long groupId, Long tenantId, String sourceOrTarget)
    {
    	log.info("In service for getting column headers in sequence");
    	LinkedHashMap finalMap = new LinkedHashMap();
    	//List<String> colNames = new ArrayList<String>();
    	List<BigInteger> ruleIds = ruleGroupDetailsRepository.fetchRuleIdsByGroupAndTenantId(groupId, tenantId);
    	log.info("Rule Ids "+ ruleIds+" for the group id "+ groupId);
    	List<BigInteger> allViewColIds = dataViewsColumnsRepository.fetchIdsByDataViewId(viewId);
    	log.info("All View Column Ids: "+ allViewColIds);
    	List<BigInteger> remainingSequence = new ArrayList<BigInteger>();
    	if(ruleIds.size()>0)
    	{
    		if("source".equalsIgnoreCase(sourceOrTarget))
    		{
    			log.info("In Source : "+ viewId);
    			List<BigInteger> ids = rulesRepository.fetchIdsBySourceViewIdAndIds(tenantId, viewId, ruleIds);
    			log.info("Rule Ids "+ ids +" tagged to source view id"+ viewId);
    			if(ids.size()>0)
    			{
    				List<BigInteger> sColumnIds = ruleConditionsRepository.fetchSourceColumnIdsByRuleIds(ids);
    				sColumnIds.remove(null);
    				log.info("Source Column Ids: "+ sColumnIds+" for Source View Id: "+viewId);
    				finalMap.put("Recon Ref Id", "Recon Ref Id");
    				if(sColumnIds.size()>0)
    				{
    					for(BigInteger colId : sColumnIds)
    					{
    						DataViewsColumns dvc = dataViewsColumnsRepository.findOne(colId.longValue());
    						if(dvc != null)
    						{
    							if("File Template".equalsIgnoreCase(dvc.getRefDvType()))
    							{
        							FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dvc.getRefDvColumn().toString()));
        							if(ftl != null)
        							{
        								finalMap.put(ftl.getColumnAlias(), dvc.getColumnName());
        							}
    							}
    							else if("Data View".equalsIgnoreCase(dvc.getRefDvType()) || dvc.getRefDvType() == null)
    							{
    								finalMap.put(dvc.getColumnName(), dvc.getColumnName());
    							}
    						}
    					}
    				}
    				finalMap.put("Rule_Name", "Rule_Name");
    				finalMap.put("rowDescription", "rowDescription");
    				finalMap.put("adjustmentType", "adjustmentType");
    				finalMap.put("Status", "Status");
    				if(allViewColIds.size()>0)
    				{
    					for(BigInteger id : allViewColIds)
    					{
    						if(!sColumnIds.contains(id))
    						{
    							remainingSequence.add(id);
    						}
    					}
    				}
    				log.info("Sourece View id: "+ viewId + ", Remaining Column Ids: "+ remainingSequence);
    				if(remainingSequence.size()>0)
    				{
       					for(BigInteger colId : remainingSequence)
    					{
    						DataViewsColumns dvc = dataViewsColumnsRepository.findOne(colId.longValue());
    						if(dvc != null)
    						{
    							if("File Template".equalsIgnoreCase(dvc.getRefDvType()))
    							{
	    							FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dvc.getRefDvColumn().toString()));
	    							if(ftl != null)
	    							{
	    								finalMap.put(ftl.getColumnAlias(), dvc.getColumnName());
	    							}
    							}
       							else if("Data View".equalsIgnoreCase(dvc.getRefDvType()) || dvc.getRefDvType() == null)
    							{
    								finalMap.put(dvc.getColumnName(), dvc.getColumnName());
    							}
    						}
    					}
    				}
    			}
    		}
    		else if("target".equalsIgnoreCase(sourceOrTarget))
    		{
    			log.info("In Target : "+ viewId);
    			List<BigInteger> ids = rulesRepository.fetchIdsByTargetViewIdAndIds(tenantId, viewId, ruleIds);
    			log.info("Rule Ids "+ ids + " which are tagged to target view id : "+ ids);
    			if(ids.size()>0)
    			{
    				List<BigInteger> tColumnIds = ruleConditionsRepository.fetchTargetColumnIdsByRuleIds(ids);
    				tColumnIds.remove(null);
    				log.info("Target view id "+viewId+"Target Column Ids: "+ tColumnIds);
    				finalMap.put("Recon Ref Id", "Recon Ref Id");
    				if(tColumnIds.size()>0)
    				{
    					for(BigInteger colId : tColumnIds)
    					{
    						DataViewsColumns dvc = dataViewsColumnsRepository.findOne(colId.longValue());
    						if(dvc != null)
    						{
    							if("File Template".equalsIgnoreCase(dvc.getRefDvType()))
    							{
	    							FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dvc.getRefDvColumn().toString()));
	    							if(ftl != null)
	    							{
	    								finalMap.put(ftl.getColumnAlias(), dvc.getColumnName());
	    							}
    							}
       							else if("Data View".equalsIgnoreCase(dvc.getRefDvType()) || dvc.getRefDvType() == null)
    							{
       								finalMap.put(dvc.getColumnName(), dvc.getColumnName());
    							}
    						}
    					}
    				}
    				finalMap.put("Rule_Name", "Rule_Name");
    				finalMap.put("rowDescription", "rowDescription");
    				finalMap.put("adjustmentType", "adjustmentType");
    				finalMap.put("Status", "Status");
    				if(allViewColIds.size()>0)
    				{
    					for(BigInteger id : allViewColIds)
    					{
    						if(!tColumnIds.contains(id))
    						{
    							remainingSequence.add(id);
    						}
    					}
    				}
    				log.info("View Id : "+ viewId + ", Remaining Column Ids "+ remainingSequence);
    				if(remainingSequence.size()>0)
    				{
    					for(BigInteger colId : remainingSequence)
    					{
    						DataViewsColumns dvc = dataViewsColumnsRepository.findOne(colId.longValue());
    						if(dvc != null)
    						{
    							if("File Template".equalsIgnoreCase(dvc.getRefDvType()))
    							{
	    							FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dvc.getRefDvColumn().toString()));
	    							if(ftl != null)
	    							{
	    								finalMap.put(ftl.getColumnAlias(), dvc.getColumnName());
	    							}
    							}
       							else if("Data View".equalsIgnoreCase(dvc.getRefDvType()) || dvc.getRefDvType() == null)
    							{
       								finalMap.put(dvc.getColumnName(), dvc.getColumnName());
    							}
    						}
    					}
    				}
    			}
    		}
    	}
    	else
    	{
    		log.info("No Rule Ids found for the group id: "+ groupId);
    	}
    	return finalMap;
    }
    
    /*Building Query based on custom column filters*/
   public String buildCustomQuery(List<FilterColumns> filterCols, Long viewId)
    {
	    String whereString = "";
	    if(filterCols.size()>0)
	    {
	    	try{
		        for(FilterColumns fc : filterCols)
		        {
		        	String colDataType = "";
		        	String col = "";
		        	log.info("ViewId: "+ viewId+", ColumnName: "+fc.getColumnName());
		        	DataViewsColumns dvc = dataViewsColumnsRepository.findByDataViewIdAndColumnName(viewId, fc.getColumnName());
		        	if(dvc != null)
		        	{
		        		colDataType = colDataType+dvc.getColDataType();
		        		if("File Template".equalsIgnoreCase(dvc.getRefDvType()))
						{
			        		FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dvc.getRefDvColumn()));
			        		if(ftl != null)
			        		{
			        			col = ftl.getColumnAlias();
			        		}
						}
						else if("Data View".equalsIgnoreCase(dvc.getRefDvType()) || dvc.getRefDvType() == null)
						{
								col = dvc.getColumnName();
						}
		        	}
		        	else
		        	{
		        		log.info("Custom col found");
		        		whereString=whereString+"custom column";
		        	}
		        	if(colDataType!=null && !(colDataType.isEmpty()) && "VARCHAR".equalsIgnoreCase(colDataType) || "STRING".equalsIgnoreCase(colDataType))
		        	{
		        		log.info("Building query string");
		        		String columnValue = fc.getColumnValue();
		        		columnValue = "'"+columnValue.replace(",", "','")+"'";
		        		if("=".equalsIgnoreCase(fc.getOperator()) || "EQUALS".equals(fc.getOperator()))
		        		{
		        			whereString = whereString + " AND "+ col + " IN ("+columnValue+")";
		        		}
		        		else if("!=".equalsIgnoreCase(fc.getOperator()) || "NOT_EQUALS".equalsIgnoreCase(fc.getOperator()))
		        		{
		        			whereString = whereString + " AND "+ col + " NOT IN ("+columnValue+")";
		        		}
		        		else if("CONTAINS".equalsIgnoreCase(fc.getOperator()))
		        		{
		        			whereString = whereString + " AND "+col+" LIKE '%"+fc.getColumnValue()+"%'";
		        			whereString = whereString + " AND "+col+" REGEXP '"+fc.getColumnValue().replace(",", "|")+"'";
		        		}
		        		else if("BEGINS_WITH".equalsIgnoreCase(fc.getOperator()))
		        		{
		        			whereString = whereString + " AND "+col +" LIKE '"+fc.getColumnValue()+"%'";
		        		}
		        		else if("ENDS_WITH".equalsIgnoreCase(fc.getOperator()))
		        		{
		        			whereString = whereString + " AND " + col + " LIKE '%"+fc.getColumnValue()+"'";
		        		}
		        	}
		        	else if(colDataType!=null && !(colDataType.isEmpty()) && "INTEGER".equalsIgnoreCase(colDataType) || "NUMBER".equalsIgnoreCase(colDataType) || "DECIMAL".equalsIgnoreCase(colDataType))
		        	{
		        		log.info("Building query integer");
		        		if("=".equalsIgnoreCase(fc.getOperator()) || "EQUALS".equalsIgnoreCase(fc.getOperator()))
		        		{
		        			whereString = whereString + " AND "+ col + " IN("+fc.getColumnValue()+")";
		        		}
		        		else if("!=".equalsIgnoreCase(fc.getOperator()) || "NOT_EQUALS".equalsIgnoreCase(fc.getOperator()))
		        		{
		        			whereString = whereString + " AND "+ col + " NOT IN("+fc.getColumnValue()+")";
		        		}
		        		else if("BETWEEN".equalsIgnoreCase(fc.getOperator()))
		        		{
		        			String[] dateRange = fc.getColumnValue().toString().split("\\,");
		        			whereString = whereString + " AND (" + col + " BETWEEN "+dateRange[0]+" AND "+dateRange[1]+")";
		        		}
		        		else
		        		{
		        			whereString = whereString + " AND "+ col + " "+ fc.getOperator()+ " " + fc.getColumnValue();
		        		}
		        	}
		        	else if(colDataType!=null && !(colDataType.isEmpty()) && "DATE".equalsIgnoreCase(colDataType) || "DATETIME".equalsIgnoreCase(colDataType))
		        	{
		        		log.info("Building query date");
		        		String columnValue = fc.getColumnValue();
		        		columnValue = "'"+columnValue.replace(",", "','")+"'";
		        		if("=".equalsIgnoreCase(fc.getOperator()) || "EQUALS".equalsIgnoreCase(fc.getOperator()))
		        		{
		        			whereString = whereString + " AND " + col + " IN("+columnValue+")";
		        		}
		        		else if("!=".equalsIgnoreCase(fc.getOperator()) || "NOT_EQUALS".equalsIgnoreCase(fc.getOperator()))
		        		{
		        			whereString = whereString + " AND " + col + " NOT IN("+ columnValue +")";
		        		}
		        		else if("BETWEEN".equalsIgnoreCase(fc.getOperator()))
		        		{
		        			String[] dateRange = fc.getColumnValue().split("\\,");
		        			whereString = whereString + " AND ("+col+" BETWEEN '"+dateRange[0]+"' AND '"+ dateRange[1]+"')";
		        		}
		        		else
		        		{
		        			whereString = whereString + " AND "+col+fc.getOperator()+columnValue;
		        		}
		        	}
		        }
	    	}
	    	catch(Exception e)
	    	{
	    		log.info("Error while building query"+e);
	    	}
	    }
	    log.info("Final Where String in Service: "+ whereString);
    	return whereString;
    }
       
   public String getAmountInFormat(String value, String currencyType)
    {
	   //log.info("Service for displaying amounts in currency format");
    	String valueInCurrency = "";
    	if("US".equalsIgnoreCase(currencyType))
    	{
    		if(value.length()>0)
    		{
    			valueInCurrency = valueInCurrency+String.format("%,.2f", Double.parseDouble(value));
    		}
    	}
    	if(valueInCurrency.length() == 0)
    	{
    		valueInCurrency = valueInCurrency + "0";
    	}
    	return valueInCurrency;
    }
   
   public List<HashMap> getRecColsAlignInfo(Long viewId, Long groupId, Long tenantId, String sourceOrTarget, String status, String type, Long ruleId)
   {
   	log.info("In service for getting column headers in sequence");
   	List<HashMap> finalMap = new ArrayList<HashMap>();
   	List<BigInteger> ruleIds = ruleGroupDetailsRepository.fetchRuleIdsByGroupAndTenantId(groupId, tenantId);
   	log.info("Rule Ids "+ ruleIds+" for the group id "+ groupId);
   	List<BigInteger> allViewColIds = dataViewsColumnsRepository.fetchIdsByDataViewId(viewId);
   	log.info("All View Column Ids: "+ allViewColIds);
   	if(ruleIds.size()>0)
   	{
   		if(type.toLowerCase().contains("summary")) 
   		{
   			if("reconciled".equalsIgnoreCase(status))
   			{
   				HashMap reconRefMp = new HashMap();
		   			reconRefMp.put("field", "reconReference");
		   			reconRefMp.put("header", "Recon Reference");
		   			reconRefMp.put("columnName", "recon_reference");
		   			reconRefMp.put("align", "left");
		   			reconRefMp.put("width", "150px");
		   			reconRefMp.put("colId", "recon_reference");
		   			reconRefMp.put("dataType", "STRING");
		   			finalMap.add(reconRefMp);
	   			HashMap countRefMp = new HashMap();
		   	   		countRefMp.put("field", "count");
		   	   		countRefMp.put("header", "Transaction Count");
		   	   		countRefMp.put("align", "center");
		   	   		countRefMp.put("width", "150px");
		   	   		countRefMp.put("colId", "");
		   	   		countRefMp.put("dataType", "STRING");
		   	   		finalMap.add(countRefMp);
		   	   	HashMap amountRefMp = new HashMap();
			   	   	amountRefMp.put("field", "amount");
			   	   	amountRefMp.put("header", "Reconciled Amount");
			   	   	amountRefMp.put("align", "right");
			   	   	amountRefMp.put("width", "150px");
			   	   	amountRefMp.put("colId", "");
			   	   	amountRefMp.put("dataType", "DECIMAL");
		   	   		finalMap.add(amountRefMp);
		   	   	HashMap varianceRefMp = new HashMap();
	   				varianceRefMp.put("field", "varianceAmount");
	   				varianceRefMp.put("header", "Variance Amount");
	   				varianceRefMp.put("align", "right");
	   				varianceRefMp.put("width", "150px");
	   				varianceRefMp.put("colId", "");
	   				varianceRefMp.put("dataType", "DECIMAL");
		   	   		finalMap.add(varianceRefMp);
   			} 
   			else
   			{
   				if("suggestion".equalsIgnoreCase(status)){
   					HashMap suggRefMp = new HashMap();
		   				suggRefMp.put("field", "reconReference");
		   				suggRefMp.put("header", "Recon References");
		   				suggRefMp.put("columnName", "recon_reference");
		   				suggRefMp.put("align", "left");
		   				suggRefMp.put("width", "150px");
		   				suggRefMp.put("colId", "recon_reference");
			   			suggRefMp.put("dataType", "STRING");
			   			finalMap.add(suggRefMp);
   					if("source".equalsIgnoreCase(sourceOrTarget)){
   						/*List<BigInteger> ids = rulesRepository.fetchIdsBySourceViewIdAndIds(tenantId, viewId, ruleIds);*/
/*   						List<BigInteger> sColumnIds = ruleConditionsRepository.fetchSourceColumnIdsByRuleIds(ids);*/
   						List<BigInteger> sColumnIds = dataViewsColumnsRepository.fetchIdsByDataViewId(viewId);
   						if(sColumnIds.size()>0)
   		  				{
   		    	   		    finalMap.addAll(getColAlignInfo(sColumnIds));
   		  				}
   					} else {
/*   						List<BigInteger> ids = rulesRepository.fetchIdsByTargetViewIdAndIds(tenantId, viewId, ruleIds);
   						List<BigInteger> tColumnIds = ruleConditionsRepository.fetchTargetColumnIdsByRuleIds(ids);*/
   						List<BigInteger> tColumnIds = dataViewsColumnsRepository.fetchIdsByDataViewId(viewId);
   						if(tColumnIds.size()>0)
   		  				{
   		    	   		    finalMap.addAll(getColAlignInfo(tColumnIds));
   		  				}
   					}
   					
   				} else {
   					if(allViewColIds.size()>0)
	  				{
	    	   		    	finalMap.addAll(getColAlignInfo(allViewColIds));
	  				}
   				}
   				HashMap rowDescRefMp = new HashMap();
	   	   		  	rowDescRefMp.put("field", "rowDescription");
	   	   		  	rowDescRefMp.put("header", "Row Description");
	   	   		  	rowDescRefMp.put("columnName", "rowDescription");
	   	   		  	rowDescRefMp.put("align", "right");
	   	   		  	rowDescRefMp.put("width", "150px");
	   	   		  	rowDescRefMp.put("colId", "rowDescription");
	   	   		  	rowDescRefMp.put("dataType", "STRING");
		   	   		finalMap.add(rowDescRefMp);
	   	   		HashMap adjTypeRefMp = new HashMap();
		   	   		adjTypeRefMp.put("field", "adjustmentType");
		   	   		adjTypeRefMp.put("header", "Adjustment Type");
		   	   		adjTypeRefMp.put("columnName", "adjustmentType");
		   	   		adjTypeRefMp.put("align", "right");
		   	   		adjTypeRefMp.put("width", "150px");
		   	   		adjTypeRefMp.put("colId", "adjustmentType");
		   	   		adjTypeRefMp.put("dataType", "STRING");
		   	   		finalMap.add(adjTypeRefMp);
   			}
   		} else {
   			if(ruleId != null){
   				if("source".equalsIgnoreCase(sourceOrTarget))
   	   	   		{
   	   				if("reconciled".equalsIgnoreCase(status)){
   	   						HashMap reconRefMp = new HashMap();
   	   			   			reconRefMp.put("field", "reconReference");
   	   			   			reconRefMp.put("header", "Recon Reference");
   	   			   			reconRefMp.put("columnName", "recon_reference");
   	   			   			reconRefMp.put("align", "left");
   	   			   			reconRefMp.put("width", "150px");
   	   			   			reconRefMp.put("colId", "recon_reference");
   	   			   			reconRefMp.put("dataType", "STRING");
   	   			   			finalMap.add(reconRefMp);
   	   			   			
   	   			   			List<BigInteger> sColumnIds = ruleConditionsRepository.fetchSourceColumnIdsByRuleId(ruleId);
   	   		   				log.info("Source Column Ids: "+ sColumnIds+" for Source View Id: "+viewId);
   	   		   				if(sColumnIds.size()>0)
   	   		   				{
   	   		   					finalMap.addAll(getColAlignInfo(sColumnIds));
   	   		   				}
		   	   		   		HashMap rowDescRefMp = new HashMap();
			   	   		  	rowDescRefMp.put("field", "rowDescription");
			   	   		  	rowDescRefMp.put("header", "Row Description");
			   	   		  	rowDescRefMp.put("columnName", "rowDescription");
			   	   		  	rowDescRefMp.put("align", "left");
			   	   		  	rowDescRefMp.put("width", "150px");
			   	   		  	rowDescRefMp.put("colId", "rowDescription");
			   	   		  	rowDescRefMp.put("dataType", "STRING");
				   	   		finalMap.add(rowDescRefMp);
				   	   		HashMap adjTypeRefMp = new HashMap();
				   	   		adjTypeRefMp.put("field", "adjustmentType");
				   	   		adjTypeRefMp.put("header", "Adjustment Type");
				   	   		adjTypeRefMp.put("columnName", "adjustmentType");
				   	   		adjTypeRefMp.put("align", "left");
				   	   		adjTypeRefMp.put("width", "150px");
				   	   		adjTypeRefMp.put("colId", "adjustmentType");
				   	   		adjTypeRefMp.put("dataType", "STRING");
				   	   		finalMap.add(adjTypeRefMp);
   	   				}
   	   	   		} 
   	   			else
   	   	   		{
   	   				if("reconciled".equalsIgnoreCase(status)){
   	   						HashMap reconRefMp = new HashMap();
   	   			   			reconRefMp.put("field", "reconReference");
   	   			   			reconRefMp.put("header", "Recon Reference");
   	   			   			reconRefMp.put("columnName", "recon_reference");
   	   			   			reconRefMp.put("align", "left");
   	   			   			reconRefMp.put("width", "150px");
   	   			   			reconRefMp.put("colId", "recon_reference");
   	   			   			reconRefMp.put("dataType", "STRING");
   	   			   			finalMap.add(reconRefMp);
   	   			   			
   	   			   			List<BigInteger> tColumnIds = ruleConditionsRepository.fetchTargetColumnIdsByRuleId(ruleId);
   	   		   				log.info("Source Column Ids: "+ tColumnIds+" for Source View Id: "+viewId);
   	   		   				if(tColumnIds.size()>0)
   	   		   				{
   	   		   					finalMap.addAll(getColAlignInfo(tColumnIds));
   	   		   				}
		   	   		   		HashMap rowDescRefMp = new HashMap();
			   	   		  	rowDescRefMp.put("field", "rowDescription");
			   	   		  	rowDescRefMp.put("header", "Row Description");
			   	   		  	rowDescRefMp.put("columnName", "rowDescription");
			   	   		  	rowDescRefMp.put("align", "left");
			   	   		  	rowDescRefMp.put("width", "150px");
			   	   		  	rowDescRefMp.put("colId", "");
			   	   		  	rowDescRefMp.put("dataType", "STRING");
				   	   		finalMap.add(rowDescRefMp);
				   	   		HashMap adjTypeRefMp = new HashMap();
				   	   		adjTypeRefMp.put("field", "adjustmentType");
				   	   		adjTypeRefMp.put("header", "Adjustment Type");
				   	   		adjTypeRefMp.put("columnName", "Adjustment Type");
				   	   		adjTypeRefMp.put("align", "left");
				   	   		adjTypeRefMp.put("width", "150px");
				   	   		adjTypeRefMp.put("colId", "");
				   	   		adjTypeRefMp.put("dataType", "STRING");
				   	   		finalMap.add(adjTypeRefMp);
   	   				}
   	   	   		}
			}
   			
   		}
   	}
   	else
   	{
   		log.info("No Rule Ids found for the group id: "+ groupId);
   	}
   	return finalMap;
   }

   public List<HashMap> getColAlignInfo(List<BigInteger> columnIds)
   {
	   	List<HashMap> finalMap = new ArrayList<HashMap>();
		for(BigInteger id : columnIds)
		{
			HashMap hm = new HashMap();
			DataViewsColumns dvc = dataViewsColumnsRepository.findOne(id.longValue());
			if(dvc != null)
			{
				String columnName = "";
				if("File Template".equalsIgnoreCase(dvc.getRefDvType()))
				{
		    		FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dvc.getRefDvColumn()));
		    		if(ftl != null)
		    		{
		    			columnName = ftl.getColumnAlias();
		    		}
				}
				else if("Data View".equalsIgnoreCase(dvc.getRefDvType()) || dvc.getRefDvType() == null)
				{
					columnName = dvc.getColumnName();
				}
				
				if("CURRENCYCODE".equalsIgnoreCase(dvc.getQualifier()))
				{
					hm.put("field", dvc.getColumnName());
					hm.put("header", dvc.getColumnName());
					hm.put("columnName", columnName);
					hm.put("align", "left");
					hm.put("width", "100px");
					hm.put("colId", dvc.getId());
					hm.put("dataType", dvc.getColDataType());
				}
				else
				{
					hm.put("field", dvc.getColumnName());
					hm.put("header", dvc.getColumnName());
					if("DECIMAL".equalsIgnoreCase(dvc.getColDataType()))
					{
						hm.put("align", "right");
					}
					else
					{
						hm.put("align", "left");
					}
					hm.put("columnName", columnName);
					hm.put("width", "150px");
					hm.put("colId", dvc.getId());
					hm.put("dataType", dvc.getColDataType());
				}
				finalMap.add(hm);
			}
		}
		return finalMap;
   }
   
   /*Service for getting distinct column values for the column*/
   
   public List<String> getDistColumnValues(List<BigInteger> idStr, String columnAlias, String viewName) throws SQLException
   {
	   	String idsString=idStr.toString();
	   	idsString=idsString.replace("[", "");
	   	idsString=idsString.replace("]", "");
	   	List<String> distctValues = new ArrayList<String>();

	   	if(idStr!=null && !(idStr.isEmpty())){
	   		// Connection to JDBC
	   		Connection conn = null;
	   		Statement stmt = null;
	   		ResultSet result = null; 
	       	try{
	       		String dbUrl=env.getProperty("spring.datasource.url");
	       		String[] parts=dbUrl.split("[\\s@&?$+-]+");
	       		String host = parts[0].split("/")[2].split(":")[0];
	       		String schemaName=parts[0].split("/")[3];
	       		String userName = env.getProperty("spring.datasource.username");
	       		String password = env.getProperty("spring.datasource.password");
	       		String jdbcDriver = env.getProperty("spring.datasource.jdbcdriver");  
	       		
	       		Class.forName(jdbcDriver);
	        	conn = DriverManager.getConnection(dbUrl, userName, password);
	        	stmt = conn.createStatement();
	        	//log.info("Query: "+ "SELECT distinct("+columnAlias+") from "+schemaName+"."+viewName.toLowerCase()+" WHERE scrIds IN ("+idStr+")");
	     	    result=stmt.executeQuery("SELECT distinct(`"+columnAlias+"`) from "+schemaName+".`"+viewName.toLowerCase()+"` WHERE scrIds IN ("+idsString+")");
	     	    while(result.next()){
	     	    	distctValues.add(result.getString(1));
	     	    }
	       	}catch(Exception e)
	       	{
	       		
	       		log.info("Exception e: "+e);
	       	}
	       	finally
	       	{
	    		if(result != null)
	    			result.close();	
	    		if(stmt != null)
	    			stmt.close();
				if(conn != null)
					conn.close();
	       	}
       	}
	   	return distctValues;
   }
   
   public int getDistColValueCount(List<BigInteger> idStr, String viewName, String columnAlias, String columnValue) throws SQLException
   {
	   	String idsString=idStr.toString();
	   	idsString=idsString.replace("[", "");
	   	idsString=idsString.replace("]", "");
	   	int count = 0;

	   	if(idStr!=null && !(idStr.isEmpty())){
	   		// Connection to JDBC
	   		Connection conn = null;
	   		Statement stmt = null;
	   		ResultSet result = null; 
	       	try{
	       		String dbUrl=env.getProperty("spring.datasource.url");
	       		String[] parts=dbUrl.split("[\\s@&?$+-]+");
	       		String host = parts[0].split("/")[2].split(":")[0];
	       		String schemaName=parts[0].split("/")[3];
	       		String userName = env.getProperty("spring.datasource.username");
	       		String password = env.getProperty("spring.datasource.password");
	       		String jdbcDriver = env.getProperty("spring.datasource.jdbcdriver");  
	       		
	       		Class.forName(jdbcDriver);
	        	conn = DriverManager.getConnection(dbUrl, userName, password);
	        	stmt = conn.createStatement();
	
	     	    result=stmt.executeQuery("SELECT count(*) from "+schemaName+".`"+viewName.toLowerCase()+"` WHERE scrIds IN ("+idsString+") AND `"+columnAlias+"` = '"+columnValue+"'");
	     	    while(result.next()){
	     	    	count = count + result.getInt(1);
	     	    }
	       	}catch(Exception e)
	       	{
	       		log.info("Exception e: "+e);
	       	}
	       	finally{
	    		if(result != null)
	    			result.close();	
	    		if(stmt != null)
	    			stmt.close();
				if(conn != null)
					conn.close();
	       	}
      	}
	   	return count;
   }
   /*Service for getting data view's column set information to display in Side Bar*/
   public List<HashMap> getViewColumnSetWithStatus(String sourceOrTarget, Long viewId, Long groupId, Long tenantId, List<BigInteger> idStr) throws SQLException
   {
		log.info("In Service for getting column set information for the view id: "+viewId);
	   	DataViews dv = dataViewsRepository.findOne(viewId);
	   	String viewName = "";
	   	if(dv != null)
	   	{
	   		viewName = viewName + dv.getDataViewName();
	   	}
	   	List<HashMap> finalMap = new ArrayList<HashMap>();
		if("source".equalsIgnoreCase(sourceOrTarget))
		{
	   		HashMap<BigInteger, String> seqCols = reconciliationResultService.getRecSequenceColumns(viewId, groupId,tenantId, "source");
	       	if(seqCols.size()>0)
	       	{
	       		for(Map.Entry<BigInteger, String> entry : seqCols.entrySet())
	       		{
	       			log.info("Id: " + entry.getKey()+", Column Alias: " + entry.getValue());
	       			List<HashMap> colValuesMap = new ArrayList<HashMap>();
	           		HashMap colMap = new HashMap();
	           		colMap.put("id", entry.getKey());
	           		DataViewsColumns dvc = dataViewsColumnsRepository.findOne(Long.parseLong(entry.getKey().toString()));
	           		if(dvc != null)
	           		{
	           			colMap.put("columnName", dvc.getColumnName());
	           		}
	           		log.info("Column Field Name: "+ dvc.getColumnName());
	           		List<String> entity = getDistColumnValues(idStr, entry.getValue(), viewName);
	           		if(entity.size()<=15)
	           		{
	               		log.info("Distinct Values Size: "+entity.size() +", Column "+ dvc.getColumnName());
	               		log.info("Distinct Values: "+entity);
	           			for(String colValue : entity)
	           			{
	           				HashMap colValueMp = new HashMap();
	           				int count = getDistColValueCount(idStr, viewName, entry.getValue(), colValue);
	           				colValueMp.put("name", colValue);
	           				colValueMp.put("count", count);
	           				colValuesMap.add(colValueMp);
	           			}
	               		colMap.put("columnValuesSet", colValuesMap);
	               		finalMap.add(colMap);
	           		}
	           		else
	           		{
	           			log.info("Column "+ entry.getValue() +" has "+entity.size()+" size");
	           		}
	       		}
				return finalMap;
			}
	       	else
	       	{
	       		return null;
	       	}
	}
	else if("target".equalsIgnoreCase(sourceOrTarget))
	{
	 	HashMap<BigInteger, String> seqCols = reconciliationResultService.getRecSequenceColumns(viewId, groupId,tenantId, "target");
	   	if(seqCols.size()>0)
	   	{
	   		for(Map.Entry<BigInteger, String> entry : seqCols.entrySet())
	   		{
	   			log.info("Id: " + entry.getKey()+", Column Alias: " + entry.getValue());
	   			List<HashMap> colValuesMap = new ArrayList<HashMap>();
	       		HashMap colMap = new HashMap();
	       		colMap.put("id", entry.getKey());
           		DataViewsColumns dvc = dataViewsColumnsRepository.findOne(Long.parseLong(entry.getKey().toString()));
           		if(dvc != null)
           		{
           			colMap.put("columnName", dvc.getColumnName());
           		}
	       		List<String> entity = getDistColumnValues(idStr, entry.getValue(), viewName);
	       		if(entity.size()<=15)
	       		{
	           		log.info("Distinct Values Size: "+entity.size() +", Column "+ dvc.getColumnName());
	       			log.info("Distinct Values: "+entity);
	       			for(String colValue : entity)
	       			{
	       				HashMap colValueMp = new HashMap();
	       				int count = getDistColValueCount(idStr, viewName, entry.getValue(), colValue);
	       				colValueMp.put("name", colValue);
	       				colValueMp.put("count", count);
	       				colValuesMap.add(colValueMp);
	       			}
	           		colMap.put("columnValuesSet", colValuesMap);
	           		finalMap.add(colMap);
	       		}
	       		else
	       		{
	       			log.info("Column "+ entry.getValue() +" has "+entity.size()+" size");
	       		}
	   		}
			return finalMap;
	   		}
	   	else 
	   	{
	   		return null;
	   	}
		}
	else
	{
		return null;
	}
   }
   
   public List<String> getViewColumnHeadersInSequenceForApproval(Long viewId, Long groupId, Long tenantId, String sourceOrTarget)
   {
	   	log.info("In service for getting column headers in sequence");
	   	List<String> colNames = new ArrayList<String>();
	   	List<BigInteger> ruleIds = ruleGroupDetailsRepository.fetchRuleIdsByGroupAndTenantId(groupId, tenantId);
	   	log.info("Rule Ids "+ ruleIds+" for the group id "+ groupId);
	   	if(ruleIds.size()>0)
	   	{
	   		if("source".equalsIgnoreCase(sourceOrTarget))
	   		{
	   			log.info("In Source : "+ viewId);
	   			List<BigInteger> ids = rulesRepository.fetchIdsBySourceViewIdAndIds(tenantId, viewId, ruleIds);
	   			log.info("Rule Ids "+ ids +" tagged to source view id"+ viewId);
	   			if(ids.size()>0)
	   			{
	   				List<BigInteger> sColumnIds = ruleConditionsRepository.fetchSourceColumnIdsByRuleIds(ids);
	   				sColumnIds.remove(null);
	   				log.info("Source Column Ids: "+ sColumnIds+" for Source View Id: "+viewId);
	   				if(sColumnIds.size()>0)
	   				{
	   	    			List<String> dvc = dataViewsColumnsRepository.fetchFileTemplateLineIdsByIds(sColumnIds);
	   	    			List<String> seqColumns = new ArrayList<String>();
	   	    	    	if(dvc.size()>0)
	   	    	    	{
	   	    	    		List<Long> idsAsLong = new ArrayList<Long>();
	   	    	    		for(String idString : dvc)
	   	    	    		{
	   	    	    			idsAsLong.add(Long.parseLong(idString));
	   	    	    		}
	   	    	    		seqColumns = fileTemplateLinesRepository.fetchColumnAliasByIds(idsAsLong);
	   	    	    		log.info("Sequence Columns "+ seqColumns);
	   	    	    		colNames.addAll(seqColumns);
	   	    	    	}
	   	    	    	else
	   	    	    	{
	   	    	    			seqColumns=dataViewsColumnsRepository.findColumnName(sColumnIds);
	   	    	    			log.info("seqColumns :"+seqColumns);
	   	    	    			colNames.addAll(seqColumns);
	   	    	    	}
	   	    	    		
	   				}
	   				
	   			}
	   		}
	   		else if("target".equalsIgnoreCase(sourceOrTarget))
	   		{
	   			log.info("In Target : "+ viewId);
	   			List<BigInteger> ids = rulesRepository.fetchIdsByTargetViewIdAndIds(tenantId, viewId, ruleIds);
	   			log.info("Rule Ids "+ ids + " which are tagged to target view id : "+ ids);
	   			if(ids.size()>0)
	   			{
	   				List<BigInteger> tColumnIds = ruleConditionsRepository.fetchTargetColumnIdsByRuleIds(ids);
	   				tColumnIds.remove(null);
	   				log.info("Target view id "+viewId+"Target Column Ids: "+ tColumnIds);
	   				if(tColumnIds.size()>0)
	   				{
	   					List<String> dvc = dataViewsColumnsRepository.fetchFileTemplateLineIdsByIds(tColumnIds);
	   					List<String> seqColumns = new ArrayList<String>();
	   					if(dvc.size()>0)
	   					{
	   						List<Long> idsAsLong = new ArrayList<Long>();
	   						for(String idString : dvc)
	   						{
	   							idsAsLong.add(Long.parseLong(idString));
	   						}
	   						seqColumns = fileTemplateLinesRepository.fetchColumnAliasByIds(idsAsLong);
	   						log.info("Target View Id"+viewId+"Sequence Columns "+ seqColumns);
	   						colNames.addAll(seqColumns);
	   					}
	   					else
	   					{
	   							seqColumns=dataViewsColumnsRepository.findColumnName(tColumnIds);
	   							log.info("seqColumns :"+seqColumns);
	   							colNames.addAll(seqColumns);
	   					}


	   				}

	   			}
	   		}
	   	}
	   	else
	   	{
	   		log.info("No Rule Ids found for the group id: "+ groupId);
	   	}
	   	return colNames;
	   }

   /**
    * author ravali
    * @param columnIds
    * @param headerList
    * @return
    */
   public List<HashMap> getColAlignInfoForApproval(List<BigInteger> columnIds,List<String> headerList)
   {
	   		List<HashMap> finalMap = new ArrayList<HashMap>();
			for(BigInteger id : columnIds)
			{
				HashMap hm = new HashMap();
				DataViewsColumns dvc = dataViewsColumnsRepository.findOne(id.longValue());
				if(dvc != null)
				{
					for(String header:headerList)
					{
						log.info("header :"+header.replaceAll("[0-9]", "").replaceAll("_", "").split("(?=[A-Z])")[0]);
						log.info("dvc.getColumnName() :"+dvc.getColumnName().split(" ")[0]);
			        if(dvc.getColumnName().split(" ")[0].equalsIgnoreCase(header.replaceAll("[0-9]", "").replaceAll("_", "").split("(?=[A-Z])")[0]))
			        {
			        	log.info("in if");
					hm.put("field", header.replaceAll("[0-9]", "").replaceAll("_", ""));
					hm.put("header", dvc.getColumnName());
					if("DECIMAL".equalsIgnoreCase(dvc.getColDataType()))
					{
						hm.put("align", "right");
					}
					else
					{
						hm.put("align", "left");
					}
					hm.put("width", "150px");
					finalMap.add(hm);
					}
				}
				}
			}
			return finalMap;
   }
   
   
   

   
   
 /**
  * ravali
  * @param viewId
  * @param groupId
  * @param tenantId
  * @param sourceOrTarget
  * @param headerList
  * @return
  */
   public List<HashMap> getAppActOrRecColsAlignInfo(Long viewId, Long groupId, Long tenantId, String sourceOrTarget,List<String> headerList)
   {
	   	log.info("In service for getting column headers in sequence");
	   	List<HashMap> finalMap = new ArrayList<HashMap>();
	   	List<BigInteger> ruleIds = ruleGroupDetailsRepository.fetchRuleIdsByGroupAndTenantId(groupId, tenantId);
	   	log.info("Rule Ids "+ ruleIds+" for the group id "+ groupId);
	   	List<BigInteger> allViewColIds = dataViewsColumnsRepository.fetchIdsByDataViewId(viewId);
	   	log.info("All View Column Ids: "+ allViewColIds);
	   	List<String> sysColumns = new ArrayList<String>();
	   	sysColumns.add("Status");
	   	List<BigInteger> remainingSequence = new ArrayList<BigInteger>();
	   	if(ruleIds.size()>0)
	   	{
	   		if("source".equalsIgnoreCase(sourceOrTarget))
	   		{
		   		
	   			log.info("In Source : "+ viewId);
	   			List<BigInteger> ids = rulesRepository.fetchIdsBySourceViewIdAndIds(tenantId, viewId, ruleIds);
	   			log.info("Rule Ids "+ ids +" tagged to source view id"+ viewId);
	   			if(ids.size()>0)
	   			{
	   				List<BigInteger> sColumnIds = ruleConditionsRepository.fetchSourceColumnIdsByRuleIds(ids);
	   				log.info("Source Column Ids: "+ sColumnIds+" for Source View Id: "+viewId);
	   				if(sColumnIds.size()>0)
	   				{
	   					finalMap.addAll(reconciliationResultService.getColAlignInfoApp(sColumnIds));
	   				}
	   			}
	   		}
	      		else if("target".equalsIgnoreCase(sourceOrTarget))
	      		{
	   	   
	      			log.info("In Target : "+ viewId);
	      			List<BigInteger> ids = rulesRepository.fetchIdsByTargetViewIdAndIds(tenantId, viewId, ruleIds);
	      			log.info("Rule Ids "+ ids + " which are tagged to target view id : "+ ids);
	      			if(ids.size()>0)
	      			{
	      				List<BigInteger> tColumnIds = ruleConditionsRepository.fetchTargetColumnIdsByRuleIds(ids);
	      				log.info("Target view id "+viewId+"Target Column Ids: "+ tColumnIds);
	      				if(tColumnIds.size()>0)
	      				{
	      					finalMap.addAll(reconciliationResultService.getColAlignInfoApp(tColumnIds));
	      				}
	      			
	      			}
	      		}
	   	}
			return finalMap;
	   }
   /**
    * ravali setting alias name from file templates
    * @param viewId
    * @param groupId
    * @param tenantId
    * @param sourceOrTarget
    * @return
    */
   
 
   
   public List<HashMap> getColAlignInfoApp(List<BigInteger> columnIds)
   {
	   List<HashMap> finalMap = new ArrayList<HashMap>();
	   for(BigInteger id : columnIds)
	   {

		   HashMap hm = new HashMap();
		   DataViewsColumns dvc = dataViewsColumnsRepository.findOne(id.longValue());
		   if(dvc != null)
		   {
			   if(dvc.getRefDvColumn()!=null)
			   {
				   FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dvc.getRefDvColumn().toString()));
				   if(ftl != null)
					   hm.put("field", ftl.getColumnAlias());
			   }
			   else
				   hm.put("field", dvc.getColumnName());
			   hm.put("header", dvc.getColumnName());
			   if("DECIMAL".equalsIgnoreCase(dvc.getColDataType()))
			   {
				   hm.put("align", "right");
			   }
			   else
			   {
				   hm.put("align", "left");
			   }
			   hm.put("width", "150px");
			   finalMap.add(hm);
		   }
	   }
	   return finalMap;
   }
   
  /** Reconciliation Work Queue New Forms **/
   
   /**
    * Author: Shiva
    * Purpose: Fetching Batch Names based on tenant id and rule group id
    * Params: tenantId, ruleGroupid
 * @throws SQLException 
    **/
   public List<String> getBatchNames(Long tenantId, Long groupId) throws SQLException
   {
	   log.info("Fetching Batch Names for the tenant id: "+ tenantId + ", rule group id: "+ groupId);
	   List<String> batchNames = new ArrayList<String>();
	   String dbUrl=env.getProperty("spring.datasource.url");
	   String[] parts=dbUrl.split("[\\s@&?$+-]+");
	   String host = parts[0].split("/")[2].split(":")[0];
	   String schemaName=parts[0].split("/")[3];
	   String userName = env.getProperty("spring.datasource.username");
	   String password = env.getProperty("spring.datasource.password");
	   String jdbcDriver = env.getProperty("spring.datasource.jdbcdriver");

   	   Connection conn = null;
   	   Statement stmt = null;
   	   ResultSet result = null;
   	   
	   try{
 	      Class.forName(jdbcDriver);
 	      conn = DriverManager.getConnection(dbUrl, userName, password);
 	      log.info("Connected database successfully...");
	      stmt = conn.createStatement();
	      log.info("BatchesQuery: select distinct(recon_job_reference) from "+schemaName+".v_recon_job_refereces WHERE tenant_id = "+ tenantId +" AND rule_group_id = "+groupId+" order by recon_job_reference asc");
	      result = stmt.executeQuery("select distinct(recon_job_reference) from "+schemaName+".v_recon_job_refereces WHERE tenant_id = "+ tenantId +" AND rule_group_id = "+groupId+" order by recon_job_reference asc");
	 	  while(result.next()){
	 		 batchNames.add(result.getString(1));
	 	  }
	   }
	   catch(Exception e)
	   {
		   log.info("Un able to connect to the database");
	   }
	   finally
	   {
	   		if(result != null)
				result.close();	
			if(stmt != null)
				stmt.close();
			if(conn != null)
				conn.close();
	   }
	   log.info("Batch Names: "+ batchNames);
   	   return batchNames;
   }
   /**
    * Author: Shiva
    * Description: Fetching data view original ids within ranges
 * @throws SQLException 
    * **/
   public List<BigInteger> getViewOriginalIds(Long viewId, String rangeFrom, String rangeTo, String transDateColumn) throws SQLException /*throws SQLException*/
   {
	   log.info("Fetching total original ids for the view id "+ viewId+" between "+ rangeFrom + " and "+ rangeTo);
	   List<BigInteger> viewOriginalIds = new ArrayList<BigInteger>();
	   Connection conn = null;
	   Statement stmt = null;
	   ResultSet result = null; 
	   
	   try{
		   String dbUrl=env.getProperty("spring.datasource.url");
		   String[] parts=dbUrl.split("[\\s@&?$+-]+");
		   String host = parts[0].split("/")[2].split(":")[0];
		   String schemaName=parts[0].split("/")[3];
		   String userName = env.getProperty("spring.datasource.username");
		   String password = env.getProperty("spring.datasource.password");
		   String jdbcDriver = env.getProperty("spring.datasource.jdbcdriver");  
   		
		   Class.forName(jdbcDriver);
		   
    	   conn = DriverManager.getConnection(dbUrl, userName, password);
    	   stmt = conn.createStatement();
     	   DataViews dv=dataViewsRepository.findOne(viewId.longValue());
     	   if(dv!= null)
     	   {
     		   String viewName = dv.getDataViewName();
/*     		   log.info("Query: "+"select scrIds from "+schemaName+"."+viewName.toLowerCase()+" where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' order by "+transDateColumn+" desc");
        	   result=stmt.executeQuery("select scrIds from "+schemaName+"."+viewName.toLowerCase()+" where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' order by "+transDateColumn+" desc");
*/     		   log.info("Query: "+"select scrIds from "+schemaName+".`"+viewName.toLowerCase()+"` where Date(fileDate) between '"+rangeFrom+"' AND '"+rangeTo+"'");
			   result=stmt.executeQuery("select scrIds from "+schemaName+".`"+viewName.toLowerCase()+"` where Date(fileDate) between '"+rangeFrom+"' AND '"+rangeTo+"'");
			   stmt.setFetchSize(500);
			   while(result.next()){
        		   viewOriginalIds.add(new BigInteger((result.getString(1))));
        	   }  
			   log.info("viewOriginalIds size:"+viewOriginalIds.size());
     	   }
     	   else
     	   {
     		   log.info("View doen't not exist for the view id: "+viewId);
     	   }
	   }
	   catch(SQLException se){
		   log.info("Error while executing query: "+se);
       }
	   catch(Exception e)
	   {
		   log.info("Exception while getting databse properties");
	   }
	   finally{
	   		if(result != null)
	   			result.close();	
	   		if(stmt != null)
	   			stmt.close();
			if(conn != null)
				conn.close();
			}
   	//log.info("View ID: "+ viewId+", Row Ids Size: "+viewOriginalIds.size());
   	return viewOriginalIds;
   }
   
   public List<BigInteger> getTargetIds(Long viewId) throws SQLException /*throws SQLException*/
   {
	   log.info("Fetching total original ids for the view id "+ viewId);
	   List<BigInteger> viewOriginalIds = new ArrayList<BigInteger>();
	   Connection conn = null;
	   Statement stmt = null;
	   ResultSet result = null; 
	   
	   try{
		   String dbUrl=env.getProperty("spring.datasource.url");
		   String[] parts=dbUrl.split("[\\s@&?$+-]+");
		   String host = parts[0].split("/")[2].split(":")[0];
		   String schemaName=parts[0].split("/")[3];
		   String userName = env.getProperty("spring.datasource.username");
		   String password = env.getProperty("spring.datasource.password");
		   String jdbcDriver = env.getProperty("spring.datasource.jdbcdriver");  
   		
		   Class.forName(jdbcDriver);
		   
    	   conn = DriverManager.getConnection(dbUrl, userName, password);
    	   stmt = conn.createStatement();
     	   DataViews dv=dataViewsRepository.findOne(viewId.longValue());
     	   if(dv!= null)
     	   {
     		   String viewName = dv.getDataViewName();
/*     		   log.info("Query: "+"select scrIds from "+schemaName+"."+viewName.toLowerCase()+" where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' order by "+transDateColumn+" desc");
        	   result=stmt.executeQuery("select scrIds from "+schemaName+"."+viewName.toLowerCase()+" where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' order by "+transDateColumn+" desc");
*/     		   log.info("Query: "+"select scrIds from "+schemaName+".`"+viewName.toLowerCase()+"`");
			   result=stmt.executeQuery("select scrIds from "+schemaName+".`"+viewName.toLowerCase()+"`");
			   stmt.setFetchSize(500);
			   while(result.next()){
        		   viewOriginalIds.add(new BigInteger((result.getString(1))));
        	   }  
			   log.info("viewOriginalIds size:"+viewOriginalIds.size());
     	   }
     	   else
     	   {
     		   log.info("View doen't not exist for the view id: "+viewId);
     	   }
	   }
	   catch(SQLException se){
		   log.info("Error while executing query: "+se);
       }
	   catch(Exception e)
	   {
		   log.info("Exception while getting databse properties");
	   }
	   finally{
	   		if(result != null)
	   			result.close();	
	   		if(stmt != null)
	   			stmt.close();
			if(conn != null)
				conn.close();
			}
   	//log.info("View ID: "+ viewId+", Row Ids Size: "+viewOriginalIds.size());
   	return viewOriginalIds;
   }
   
   public Map<String, List<BigInteger>> getUnReconMap(Long dataViewId, Long tenantId,Long groupId,String rangeFrom, String rangeTo, String transDateColumn) throws ClassNotFoundException, SQLException{
	   	Map<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
		List<BigInteger> viewOriginalIds = getViewOriginalIds(dataViewId, rangeFrom, rangeTo,transDateColumn);
		List<BigInteger> reconciled = new ArrayList<BigInteger>();
	   	finalMap.put("reconciled", reconciled);
	   	finalMap.put("unReconciled", viewOriginalIds);
	   	finalMap.put("totalIds", viewOriginalIds);
		log.info("Source View ID: "+dataViewId+", total ids: "+viewOriginalIds.size()+", View Original Ids: "+viewOriginalIds.size());
	   	return finalMap;
	   }
   
   public List<HashMap> getUnReconData(Long viewId, String rangeFrom, String rangeTo, String transDateColumn, String amountQualifier, Long tenantId) throws SQLException, ParseException, ClassNotFoundException
   {
	   List<BigInteger> viewOriginalIds = getViewOriginalIds(viewId, rangeFrom, rangeTo,transDateColumn);
	   String currencyCodeColName = getTransDateQualifier(new BigInteger(viewId.toString()), "CURRENCYCODE");
	   DataViews dv = dataViewsRepository.findOne(viewId);
	   List<HashMap> finalList = new ArrayList<HashMap>();
	   Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	   String currencyFormat = props.getProperty("currencyFormat");
	   if(dv != null)
	   {
		   List<String> currenciesRec = getDistColumnValues(viewOriginalIds,currencyCodeColName,dv.getDataViewName());
		   String currencySymbol = "";
		   if(currenciesRec.size()==1)
		   {
			   currencySymbol = currencySymbol+getCurrencySymbol(currenciesRec.get(0));
		   }
		   else if(currenciesRec.size()>1)
		   {
			   currencySymbol = currencySymbol+"*";
		   }
		   HashMap recMap = new HashMap();
		   recMap.put("name", "Others");
		   HashMap recAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, amountQualifier,viewOriginalIds);
		   recMap.put("tAmount", currencySymbol+" "+reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
		   recMap.put("tCount", recAmountCount.get("totalCount"));
		  // recMap.put("tdCount", viewOriginalIds.size());
		   
		   recMap.put("rAmount", 0.0);
		   recMap.put("rCount", 0);
		 //  recMap.put("rdCount", 0);
		   
		   recMap.put("uAmount", currencySymbol+" "+reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
		   recMap.put("uCount", recAmountCount.get("totalCount"));
		 //  recMap.put("udCount", viewOriginalIds.size());
		   
		   finalList.add(recMap);
	   }

	   return finalList;
   }
   
   public List<HashMap> getUnReconDataTarget(Long viewId, String rangeFrom, String rangeTo, String transDateColumn, String amountQualifier, Long tenantId) throws SQLException, ParseException, ClassNotFoundException
   {
	   List<BigInteger> viewOriginalIds = getTargetIds(viewId);
	   String currencyCodeColName = getTransDateQualifier(new BigInteger(viewId.toString()), "CURRENCYCODE");
	   DataViews dv = dataViewsRepository.findOne(viewId);
	   List<HashMap> finalList = new ArrayList<HashMap>();
	   Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	   String currencyFormat = props.getProperty("currencyFormat");
	   if(dv != null)
	   {
		   List<String> currenciesRec = getDistColumnValues(viewOriginalIds,currencyCodeColName,dv.getDataViewName());
		   String currencySymbol = "";
		   if(currenciesRec.size()==1)
		   {
			   currencySymbol = currencySymbol+getCurrencySymbol(currenciesRec.get(0));
		   }
		   else if(currenciesRec.size()>1)
		   {
			   currencySymbol = currencySymbol+"*";
		   }
		   HashMap recMap = new HashMap();
		   recMap.put("name", "Others");
		   HashMap recAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, amountQualifier,viewOriginalIds);
		   recMap.put("tAmount", currencySymbol+" "+reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
		   recMap.put("tCount", recAmountCount.get("totalCount"));
		   
		   recMap.put("rAmount", 0.0);
		   recMap.put("rCount", 0);
		   
		   recMap.put("uAmount", currencySymbol+" "+reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
		   recMap.put("uCount", recAmountCount.get("totalCount"));
		   
		   finalList.add(recMap);
	   }

	   return finalList;
   }
   
   /**
    * Author: Shiva
    * Purpose: Fetching rule's grouped list
    * @throws ClassNotFoundException 
 * @throws ParseException 
    * **/
   public List<HashMap> getGroupedRulesList(List<BigInteger> ruleIds, String rangeFrom, String rangeTo, Long viewId, Long tenantId, Long groupId, String qualifier, String jobReference) throws ClassNotFoundException, ParseException
   {
	   log.info("Fetching rules grouped list for the rules: "+ ruleIds+", View Id: "+ viewId);
	   List<HashMap> finalList = new ArrayList<HashMap>();
	   Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	   String currencyFormat = props.getProperty("currencyFormat");
	   DataViews dv = dataViewsRepository.findOne(viewId);
	   try {
		   if(dv != null)
		   {
			   String transDateColumn = reconciliationResultService.getTransDateQualifier(new BigInteger(viewId.toString()), "TRANSDATE");
			   List<BigInteger> viewOriginalIds = getViewOriginalIds(viewId, rangeFrom, rangeTo,transDateColumn);
			   List<BigInteger> othersRecIds = new ArrayList<BigInteger>();
			   if(viewOriginalIds.size()>0)
			   {
				   String currencyCodeColName = getTransDateQualifier(new BigInteger(viewId.toString()), "CURRENCYCODE"); 
		 	    
				   List<BigInteger> unRecIds = new ArrayList<BigInteger>();
				   //HashMap others = new HashMap();
				   HashMap othersMap = new HashMap();
				   List<BigInteger> manualRecIds = new ArrayList<BigInteger>();
				   for(BigInteger ruleId: ruleIds)
				   {
					   List<BigInteger> recIds = new ArrayList<BigInteger>();
					   HashMap total = new HashMap();
					   HashMap recMap = new HashMap();
					   HashMap unRecon = new HashMap();
					   List<Long> ruleIdSingle = new ArrayList<Long>();
					   ruleIdSingle.add(ruleId.longValue());
					   recIds = reconciliationResultRepository.fetchReconciledIdsWithOutJobRefWithStatusReconciledForSource(tenantId, ruleIdSingle, groupId, viewOriginalIds,viewId);
					   if(ruleId.longValue() == 0L)
					   {
						   manualRecIds.addAll(recIds);
						   othersRecIds.addAll(recIds);
					   }
					   else
					   {
						   othersRecIds.addAll(recIds);
						   Rules rule = rulesRepository.findOne(ruleId.longValue());
						   HashMap reconciled = new HashMap();
						   if(rule != null)
						   {
							   recMap.put("id", ruleId);
							   recMap.put("name", rule.getRuleCode());
						   }
						   String currencySymbol = "";
						   List<String> currenciesRec = getDistColumnValues(recIds,currencyCodeColName,dv.getDataViewName());
						   if(currenciesRec.size()==1)
						   {
							   currencySymbol = currencySymbol+getCurrencySymbol(currenciesRec.get(0));
						   }
						   else if(currenciesRec.size()>1)
						   {
							   currencySymbol = currencySymbol+"*";
						   }
						   HashMap recAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, qualifier,recIds);
						   
						   recMap.put("tAmount", currencySymbol+" "+reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
						   recMap.put("tCount", recAmountCount.get("totalCount"));
						  // recMap.put("tdCount", recIds.size());
						   
						   recMap.put("rAmount", currencySymbol+" "+reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
						   recMap.put("rCount", recAmountCount.get("totalCount"));
						   //recMap.put("rdCount", recIds.size());
						   
						   recMap.put("uAmount", 0.0);
						   recMap.put("uCount", 0);
						 //  recMap.put("udCount", 0);
						   
						   finalList.add(recMap);
					   }
				   }
				   //Others
				   for(BigInteger id : viewOriginalIds)
				   {
					   if(!othersRecIds.contains(id))
					   {
						   unRecIds.add(id);
					   }
				   }
				   log.info("ManualUnReconciledSize: "+unRecIds.size());
				   HashMap othersTotal = new HashMap();
				   HashMap othersRec = new HashMap();
				   HashMap othersUnRec = new HashMap();
				   List<BigInteger> allOtherIds = new ArrayList<BigInteger>();
				   allOtherIds.addAll(manualRecIds);
				   allOtherIds.addAll(unRecIds);
				   
				   HashMap totalRecAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, qualifier,allOtherIds);
				   HashMap recAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, qualifier,manualRecIds);
				   HashMap unRecAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, qualifier,unRecIds);
				   
				   String currencySymbolRec = "";
				   List<String> currenciesRec = getDistColumnValues(manualRecIds,currencyCodeColName,dv.getDataViewName());
				   if(currenciesRec.size()==1)
				   {
					   currencySymbolRec = currencySymbolRec+getCurrencySymbol(currenciesRec.get(0));
				   }
				   else if(currenciesRec.size()>1)
				   {
					   currencySymbolRec = currencySymbolRec+"*";
				   }
				   
				   String currencySymbolTotal = "";
				   List<String> currenciesTotal = getDistColumnValues(viewOriginalIds,currencyCodeColName,dv.getDataViewName());
				   if(currenciesTotal.size()==1)
				   {
					   currencySymbolTotal = currencySymbolTotal+getCurrencySymbol(currenciesTotal.get(0));
				   }
				   else if(currenciesTotal.size()>1)
				   {
					   currencySymbolTotal = currencySymbolTotal+"*";
				   }
				   
				   String currencySymbolUnRec = "";
				   List<String> currenciesUnRec = getDistColumnValues(unRecIds,currencyCodeColName,dv.getDataViewName());
				   if(currenciesUnRec.size()==1)
				   {
					   currencySymbolUnRec = currencySymbolUnRec+getCurrencySymbol(currenciesUnRec.get(0));
				   }
				   else if(currenciesUnRec.size()>1)
				   {
					   currencySymbolUnRec = currencySymbolUnRec+"*";
				   }
				   
				   othersMap.put("name", "Manual");
				   othersMap.put("id", 0);			   
				   othersMap.put("tAmount", currencySymbolTotal + " "+reconciliationResultService.getAmountInFormat(totalRecAmountCount.get("totalAmount").toString(),currencyFormat));
				   othersMap.put("tCount", totalRecAmountCount.get("totalCount"));
				   //othersMap.put("tdCount", allOtherIds.size());
				   
				   othersMap.put("rAmount", currencySymbolRec + " "+reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
				   othersMap.put("rCount", recAmountCount.get("totalCount"));
				  // othersMap.put("trCount", manualRecIds.size());
				   
				   othersMap.put("uAmount", currencySymbolUnRec+ " "+ reconciliationResultService.getAmountInFormat(unRecAmountCount.get("totalAmount").toString(),currencyFormat));
				   othersMap.put("uCount", unRecAmountCount.get("totalCount"));
				  // othersMap.put("tuCount", unRecIds.size());
				   
				   finalList.add(othersMap);
			   }
		   }
	   }catch (SQLException e) {
			e.printStackTrace();
	   }
	   return finalList;
   }
   
   public List<HashMap> getGroupedRulesListForTarget(List<BigInteger> ruleIds, String rangeFrom, String rangeTo, Long viewId, Long tenantId, Long groupId, String qualifier, String jobReference) throws ClassNotFoundException, ParseException
   {
	   log.info("Fetching rules grouped list for the rules: "+ ruleIds+", View Id: "+ viewId);
	   List<HashMap> finalList = new ArrayList<HashMap>();
	   Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	   String currencyFormat = props.getProperty("currencyFormat");
	   DataViews dv = dataViewsRepository.findOne(viewId);
	   try {
		   if(dv != null)
		   {
			   String transDateColumn = reconciliationResultService.getTransDateQualifier(new BigInteger(viewId.toString()), "TRANSDATE");
			   List<BigInteger> viewOriginalIds = getTargetIds(viewId);
			   List<BigInteger> othersRecIds = new ArrayList<BigInteger>();
			   if(viewOriginalIds.size()>0)
			   {
				   String currencyCodeColName = getTransDateQualifier(new BigInteger(viewId.toString()), "CURRENCYCODE"); 
		 	    
				   List<BigInteger> unRecIds = new ArrayList<BigInteger>();
				   //HashMap others = new HashMap();
				   HashMap othersMap = new HashMap();
				   List<BigInteger> manualRecIds = new ArrayList<BigInteger>();
				   for(BigInteger ruleId: ruleIds)
				   {
					   List<BigInteger> recIds = new ArrayList<BigInteger>();
					   HashMap total = new HashMap();
					   HashMap recMap = new HashMap();
					   HashMap unRecon = new HashMap();
					   List<Long> ruleIdSingle = new ArrayList<Long>();
					   ruleIdSingle.add(ruleId.longValue());
/*					   if(jobReference.length()>0)
					   {
						   recIds = reconciliationResultRepository.fetchReconciledIdswithJobRefAndStatusReconciledForSource(tenantId, ruleIdSingle, groupId, viewOriginalIds,jobReference);
					   }
					   else
					   {*/
						   recIds = reconciliationResultRepository.fetchReconciledIdsWithOutJobRefWithStatusReconciledForTarget(tenantId, ruleIdSingle, groupId, viewOriginalIds, viewId);
					   /*}*/
					   if(ruleId.longValue() == 0L)
					   {
						   manualRecIds.addAll(recIds);
						   othersRecIds.addAll(recIds);
					   }
					   else
					   {
						   othersRecIds.addAll(recIds);
						   Rules rule = rulesRepository.findOne(ruleId.longValue());
						   HashMap reconciled = new HashMap();
						   if(rule != null)
						   {
							   recMap.put("id", ruleId);
							   recMap.put("name", rule.getRuleCode());
						   }
						   String currencySymbol = "";
						   List<String> currenciesRec = getDistColumnValues(recIds,currencyCodeColName,dv.getDataViewName());
						   if(currenciesRec.size()==1)
						   {
							   currencySymbol = currencySymbol+getCurrencySymbol(currenciesRec.get(0));
						   }
						   else if(currenciesRec.size()>1)
						   {
							   currencySymbol = currencySymbol+"*";
						   }
						   HashMap recAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, qualifier,recIds);
						   
						   recMap.put("tAmount", currencySymbol+" "+reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
						   recMap.put("tCount", recAmountCount.get("totalCount"));
						   
						   recMap.put("rAmount", currencySymbol+" "+reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
						   recMap.put("rCount", recAmountCount.get("totalCount"));
						   
						   recMap.put("uAmount", 0.0);
						   recMap.put("uCount", 0);
						   
						   finalList.add(recMap);
					   }
				   }
				   //Others
				   for(BigInteger id : viewOriginalIds)
				   {
					   if(!othersRecIds.contains(id))
					   {
						   unRecIds.add(id);
					   }
				   }
				   log.info("ManualUnReconciledSize: "+unRecIds.size());
				   HashMap othersTotal = new HashMap();
				   HashMap othersRec = new HashMap();
				   HashMap othersUnRec = new HashMap();
				   List<BigInteger> allOtherIds = new ArrayList<BigInteger>();
				   allOtherIds.addAll(manualRecIds);
				   allOtherIds.addAll(unRecIds);
				   
				   HashMap totalRecAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, qualifier,allOtherIds);
				   HashMap recAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, qualifier,manualRecIds);
				   HashMap unRecAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, qualifier,unRecIds);
				   
				   String currencySymbolRec = "";
				   List<String> currenciesRec = getDistColumnValues(manualRecIds,currencyCodeColName,dv.getDataViewName());
				   if(currenciesRec.size()==1)
				   {
					   currencySymbolRec = currencySymbolRec+getCurrencySymbol(currenciesRec.get(0));
				   }
				   else if(currenciesRec.size()>1)
				   {
					   currencySymbolRec = currencySymbolRec+"*";
				   }
				   
				   String currencySymbolTotal = "";
				   List<String> currenciesTotal = getDistColumnValues(viewOriginalIds,currencyCodeColName,dv.getDataViewName());
				   if(currenciesTotal.size()==1)
				   {
					   currencySymbolTotal = currencySymbolTotal+getCurrencySymbol(currenciesTotal.get(0));
				   }
				   else if(currenciesTotal.size()>1)
				   {
					   currencySymbolTotal = currencySymbolTotal+"*";
				   }
				   
				   String currencySymbolUnRec = "";
				   List<String> currenciesUnRec = getDistColumnValues(unRecIds,currencyCodeColName,dv.getDataViewName());
				   if(currenciesUnRec.size()==1)
				   {
					   currencySymbolUnRec = currencySymbolUnRec+getCurrencySymbol(currenciesUnRec.get(0));
				   }
				   else if(currenciesUnRec.size()>1)
				   {
					   currencySymbolUnRec = currencySymbolUnRec+"*";
				   }
				   
				   othersMap.put("name", "Manual");
				   othersMap.put("id", 0);			   
				   othersMap.put("tAmount", currencySymbolTotal + " "+reconciliationResultService.getAmountInFormat(totalRecAmountCount.get("totalAmount").toString(),currencyFormat));
				   othersMap.put("tCount", totalRecAmountCount.get("totalCount"));
				   
				   othersMap.put("rAmount", currencySymbolRec + " "+reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
				   othersMap.put("rCount", recAmountCount.get("totalCount"));
				   
				   othersMap.put("uAmount", currencySymbolUnRec+ " "+ reconciliationResultService.getAmountInFormat(unRecAmountCount.get("totalAmount").toString(),currencyFormat));
				   othersMap.put("uCount", unRecAmountCount.get("totalCount"));
				   
				   finalList.add(othersMap);
			   }
		   }
	   }catch (SQLException e) {
			e.printStackTrace();
	   }
	   return finalList;
   }
   
	public String getViewColumnQualifier(BigInteger dataViewId, String qualifierCode){
    	DataViewsColumns dvc = dataViewsColumnsRepository.findByDataViewIdAndQualifier(dataViewId.longValue(),qualifierCode);
    	String qualifier = "";
    	if(dvc != null)
    	{
			if("File Template".equalsIgnoreCase(dvc.getRefDvType()))
			{
	    		FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dvc.getRefDvColumn()));
	    		if(ftl != null)
	    		{
	    			qualifier = ftl.getColumnAlias();
	    		}
			}
			else if("Data View".equalsIgnoreCase(dvc.getRefDvType()) || dvc.getRefDvType() == null)
			{
				qualifier = dvc.getColumnName();
			}
    	}
    	else
    	{
    		log.info("There is no Transdate Qualifier for the view id : "+ dataViewId);
    	}
    	return qualifier;
	}
   
	public String getTransDateQualifier(BigInteger dataViewId, String qualifierCode) throws ClassNotFoundException{
		//log.info("In Service for getting qualifier column name for the view id: "+ dataViewId);
		//log.info("Data View Id:>>  "+dataViewId+", Qualifier Code: "+qualifierCode);
    	DataViewsColumns dvc = dataViewsColumnsRepository.findByDataViewIdAndQualifier(dataViewId.longValue(),qualifierCode);
    	String qualifier = "";
    	if(dvc != null)
    	{
			if("File Template".equalsIgnoreCase(dvc.getRefDvType()))
			{
	    		FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dvc.getRefDvColumn()));
	    		if(ftl != null)
	    		{
	    			qualifier = ftl.getColumnAlias();
	    		}
			}
			else if("Data View".equalsIgnoreCase(dvc.getRefDvType()) || dvc.getRefDvType() == null)
			{
				qualifier = dvc.getColumnName();
			}
    	}
    	else
    	{
    		log.info("There is no Transdate Qualifier for the view id : "+ dataViewId);
    	}
    	return qualifier;
	}
	
	public List<String> getDistinctColumnValues(Long viewId, String rangeFrom, String rangeTo, String transDateQualifier) throws SQLException
	{
		   log.info("Fetching distinct transdates for the view id "+ viewId+" between "+ rangeFrom + " and "+ rangeTo +", qualifier: "+ transDateQualifier);
		   List<String> transDates = new ArrayList<String>();
		   Connection conn = null;
		   Statement stmt = null;
		   ResultSet result = null; 
		   
		   try{
			   String dbUrl=env.getProperty("spring.datasource.url");
			   String[] parts=dbUrl.split("[\\s@&?$+-]+");
			   String host = parts[0].split("/")[2].split(":")[0];
			   String schemaName=parts[0].split("/")[3];
			   String userName = env.getProperty("spring.datasource.username");
			   String password = env.getProperty("spring.datasource.password");
			   String jdbcDriver = env.getProperty("spring.datasource.jdbcdriver");  
	   		
			   Class.forName(jdbcDriver);
	    	   conn = DriverManager.getConnection(dbUrl, userName, password);
	    	   stmt = conn.createStatement();
	     	   DataViews dv=dataViewsRepository.findOne(viewId.longValue());
	     	   
	     	   if(dv!= null)
	     	   {
	     		   String viewName = dv.getDataViewName();
	     		   log.info("select distinct(`"+transDateQualifier+"`) FROM "+ schemaName+".`"+viewName.toLowerCase() + "` where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' order by `"+ transDateQualifier+"` desc");
	        	   result=stmt.executeQuery("select distinct(`"+transDateQualifier+"`) FROM "+ schemaName+".`"+viewName.toLowerCase() + "` where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' order by `"+ transDateQualifier+"` desc");
	        	   while(result.next()){
	        		   transDates.add((result.getString(1)));
	        	   }  
	     	   }
	     	   else
	     	   {
	     		   log.info("View doen't not exist for the view id: "+viewId);
	     	   }
		   }
		   catch(SQLException se){
			   log.info("Error while executing query: "+se);
	       }
		   catch(Exception e)
		   {
			   log.info("Exception while getting databse properties");
		   }
		   finally{
		   		if(result != null)
		   			result.close();	
		   		if(stmt != null)
		   			stmt.close();
				if(conn != null)
					conn.close();
				}
	   	log.info("View ID: "+ viewId+", TransDates Size: "+transDates.size());
	   	return transDates;
	}
	
	public List<String> getDistinctDates(Long viewId, String periodFactor, String rangeFrom, String rangeTo, String transDateQualifier) throws SQLException
	{
		List<String> distinctDates = new ArrayList<String>();
		if("fileDate".equalsIgnoreCase(periodFactor))
		{
			distinctDates = getDistinctTransDates(viewId, rangeFrom, rangeTo, transDateQualifier);
		}
		else if("dateQualifier".equalsIgnoreCase(periodFactor))
		{
			distinctDates = getDatesByDateQualifier(viewId, rangeFrom, rangeTo, transDateQualifier);
		}
		return distinctDates;
	}
	
	public List<String> getDatesByDateQualifier(Long viewId, String rangeFrom, String rangeTo, String transDateQualifier) throws SQLException
	{
		   log.info("Fetching distinct transdates for the view id "+ viewId+" between "+ rangeFrom + " and "+ rangeTo +", qualifier: "+ transDateQualifier);
		   List<String> transDates = new ArrayList<String>();
		   Connection conn = null;
		   Statement stmt = null;
		   ResultSet result = null; 
		   try{
			   String dbUrl=env.getProperty("spring.datasource.url");
			   String[] parts=dbUrl.split("[\\s@&?$+-]+");
			   String host = parts[0].split("/")[2].split(":")[0];
			   String schemaName=parts[0].split("/")[3];
			   String userName = env.getProperty("spring.datasource.username");
			   String password = env.getProperty("spring.datasource.password");
			   String jdbcDriver = env.getProperty("spring.datasource.jdbcdriver");  
			   Class.forName(jdbcDriver);
	    	   conn = DriverManager.getConnection(dbUrl, userName, password);
	    	   stmt = conn.createStatement();
	     	   DataViews dv=dataViewsRepository.findOne(viewId.longValue());
	     	   if(dv!= null)
	     	   {
	     		   String viewName = dv.getDataViewName();
	     		   log.info("SELECT DATE(`"+transDateQualifier+"`) FROM "+schemaName+".`"+viewName.toLowerCase()+"` where `"+transDateQualifier+"` between '"+rangeFrom+"' AND '"+rangeTo+"' group by DATE(`"+transDateQualifier+"`) ORDER BY DATE(`"+transDateQualifier+"`) DESC");
	     		   //log.info("select distinct("+transDateQualifier+") FROM "+ schemaName+"."+viewName.toLowerCase() + " where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' order by "+ transDateQualifier+" desc");
	        	   result=stmt.executeQuery("SELECT DATE(`"+transDateQualifier+"`) FROM "+schemaName+".`"+viewName.toLowerCase()+"` where `"+transDateQualifier+"` between '"+rangeFrom+"' AND '"+rangeTo+"' group by DATE(`"+transDateQualifier+"`) ORDER BY DATE(`"+transDateQualifier+"`) DESC");
	        	   while(result.next()){
	        		   transDates.add((result.getString(1)));
	        	   }
	     	   }
	     	   else
	     	   {
	     		   log.info("View doen't not exist for the view id: "+viewId);
	     	   }
		   }
		   catch(SQLException se){
			   log.info("Error while executing query: "+se);
	       }
		   catch(Exception e)
		   {
			   log.info("Exception while getting databse properties");
		   }
		   finally{
		   		if(result != null)
		   			result.close();	
		   		if(stmt != null)
		   			stmt.close();
				if(conn != null)
					conn.close();
				}
	   	log.info("View ID: "+ viewId+", TransDates Size: "+transDates.size());
	   	log.info("Distinct Trans Dates: "+ transDates);
	   	return transDates;
	}
	
	public List<String> getDistinctTransDates(Long viewId, String rangeFrom, String rangeTo, String transDateQualifier) throws SQLException
	{
		   log.info("Fetching distinct transdates for the view id "+ viewId+" between "+ rangeFrom + " and "+ rangeTo +", qualifier: "+ transDateQualifier);
		   List<String> transDates = new ArrayList<String>();
		   Connection conn = null;
		   Statement stmt = null;
		   ResultSet result = null; 
		   try{
			   String dbUrl=env.getProperty("spring.datasource.url");
			   String[] parts=dbUrl.split("[\\s@&?$+-]+");
			   String host = parts[0].split("/")[2].split(":")[0];
			   String schemaName=parts[0].split("/")[3];
			   String userName = env.getProperty("spring.datasource.username");
			   String password = env.getProperty("spring.datasource.password");
			   String jdbcDriver = env.getProperty("spring.datasource.jdbcdriver");  
			   Class.forName(jdbcDriver);
	    	   conn = DriverManager.getConnection(dbUrl, userName, password);
	    	   stmt = conn.createStatement();
	     	   DataViews dv=dataViewsRepository.findOne(viewId.longValue());
	     	   if(dv!= null)
	     	   {
	     		   String viewName = dv.getDataViewName();
	     		   log.info("SELECT DATE(fileDate) FROM "+schemaName+".`"+viewName.toLowerCase()+"` where Date(fileDate )between '"+rangeFrom+"' AND '"+rangeTo+"' group by DATE(fileDate) ORDER BY DATE(fileDate) DESC");
	     		   //log.info("select distinct("+transDateQualifier+") FROM "+ schemaName+"."+viewName.toLowerCase() + " where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' order by "+ transDateQualifier+" desc");
	        	   result=stmt.executeQuery("SELECT DATE(fileDate) FROM "+schemaName+".`"+viewName.toLowerCase()+"` where Date(fileDate) between '"+rangeFrom+"' AND '"+rangeTo+"' group by DATE(fileDate) ORDER BY DATE(fileDate) DESC");
	        	   while(result.next()){
	        		   transDates.add((result.getString(1)));
	        	   }
	     	   }
	     	   else
	     	   {
	     		   log.info("View doen't not exist for the view id: "+viewId);
	     	   }
		   }
		   catch(SQLException se){
			   log.info("Error while executing query: "+se);
	       }
		   catch(Exception e)
		   {
			   log.info("Exception while getting databse properties");
		   }
		   finally{
		   		if(result != null)
		   			result.close();	
		   		if(stmt != null)
		   			stmt.close();
				if(conn != null)
					conn.close();
				}
	   	log.info("View ID: "+ viewId+", TransDates Size: "+transDates.size());
	   	log.info("Distinct Trans Dates: "+ transDates);
	   	return transDates;
	}
   
   /**
    * Author: Shiva
    * Purpose: Fetching batch's grouped list
    * @throws ClassNotFoundException 
 * @throws ParseException 
    * **/
   public List<HashMap> getGroupedBatchesList(List<String> batches, String rangeFrom, String rangeTo, Long viewId, Long tenantId, Long groupId, String qualifier, String jobReference) throws ClassNotFoundException, ParseException
   {
	   //log.info("Fetching rules grouped list for the rules: "+ batches+", View Id: "+ viewId);
	   List<HashMap> finalList = new ArrayList<HashMap>();
	   Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	   String currencyFormat = props.getProperty("currencyFormat");
	   DataViews dv = dataViewsRepository.findOne(viewId);
	   try {
		   if(dv != null)
		   {
			   String currencyCodeColName = getTransDateQualifier(new BigInteger(viewId.toString()), "CURRENCYCODE");
			   String transDateColumn = reconciliationResultService.getTransDateQualifier(new BigInteger(viewId.toString()), "TRANSDATE");
			   List<BigInteger> viewOriginalIds = getViewOriginalIds(viewId, rangeFrom, rangeTo,transDateColumn);
			   List<BigInteger> allRecIds = new ArrayList<BigInteger>();
			   if(viewOriginalIds.size()>0)
			   {
				   List<BigInteger> unRecIds = new ArrayList<BigInteger>();
				   HashMap others = new HashMap();
				   HashMap totalAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, qualifier,viewOriginalIds);
				   for(String batch: batches)
				   {
					   HashMap total = new HashMap();
					   HashMap recMap = new HashMap();
					   List<BigInteger> recIds = reconciliationResultRepository.fetchReconciledIdswithJobReferenceForSource(tenantId, groupId, viewOriginalIds, batch, viewId);
					   allRecIds.addAll(recIds);
					   HashMap reconciled = new HashMap();
					   HashMap unReconciled = new HashMap();
					   recMap.put("name", batch);
					   
					   String currencySymbolRec = "";
					   
					   List<String> currenciesRec = getDistColumnValues(recIds,currencyCodeColName,dv.getDataViewName());
					   if(currenciesRec.size()==1)
					   {
						   currencySymbolRec = currencySymbolRec+getCurrencySymbol(currenciesRec.get(0));
					   }
					   else if(currenciesRec.size()>1)
					   {
						   currencySymbolRec = currencySymbolRec+"*";
					   }

					   HashMap recAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, qualifier,recIds);
					   
					   recMap.put("tAmount", currencySymbolRec+" "+reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
					   recMap.put("tCount", recAmountCount.get("totalCount"));
					 //  recMap.put("tdCount", recIds.size());

					   recMap.put("rAmount", currencySymbolRec+" "+reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
					   recMap.put("rCount", recAmountCount.get("totalCount"));
					//   recMap.put("rdCount", recIds.size());
					   
					   recMap.put("uAmount", 0.0);
					   recMap.put("uCount", 0);
					//   recMap.put("udCount", 0);
					   
					   finalList.add(recMap);
				   }
				   //Others
				   for(BigInteger id : viewOriginalIds)
				   {
					   if(!allRecIds.contains(id))
					   {
						   unRecIds.add(id);
					   }
				   }
				   if(unRecIds.size()>0)
				   {
					   HashMap othersTotal = new HashMap();
					   HashMap othersUnRec = new HashMap();
					   HashMap othersRec = new HashMap();
					   
					   String currencySymbolOthers = "";
					   
					   List<String> currenciesOthers = getDistColumnValues(unRecIds,currencyCodeColName,dv.getDataViewName());
					   if(currenciesOthers.size()==1)
					   {
						   currencySymbolOthers = currencySymbolOthers+getCurrencySymbol(currenciesOthers.get(0));
					   }
					   else if(currenciesOthers.size()>1)
					   {
						   currencySymbolOthers = currencySymbolOthers+"*";
					   }
					   
					   HashMap unRecAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, qualifier,unRecIds);

					   others.put("name", "Others");
					   others.put("tAmount", currencySymbolOthers+" "+reconciliationResultService.getAmountInFormat(unRecAmountCount.get("totalAmount").toString(),currencyFormat));
					   others.put("tCount", unRecAmountCount.get("totalCount"));
					//   others.put("tCount", unRecIds.size());
					   
					   others.put("rAmount", 0.0);
					   others.put("rCount", 0);
					//   others.put("rCount", 0);
					   
					   others.put("uAmount", currencySymbolOthers+" "+reconciliationResultService.getAmountInFormat(unRecAmountCount.get("totalAmount").toString(),currencyFormat));
					   others.put("uCount", unRecAmountCount.get("totalCount"));
					//   others.put("uCount", unRecIds.size());

				   }
				   finalList.add(others);
			   }
		   }

	   }catch (SQLException e) {
			e.printStackTrace();
	   }
	   return finalList;
   }
   
   public List<HashMap> getGroupedBatchesListForTarget(List<String> batches, String rangeFrom, String rangeTo, Long viewId, Long tenantId, Long groupId, String qualifier, String jobReference) throws ClassNotFoundException, ParseException
   {
	   //log.info("Fetching rules grouped list for the rules: "+ batches+", View Id: "+ viewId);
	   List<HashMap> finalList = new ArrayList<HashMap>();
	   Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	   String currencyFormat = props.getProperty("currencyFormat");
	   DataViews dv = dataViewsRepository.findOne(viewId);
	   try {
		   if(dv != null)
		   {
			   String currencyCodeColName = getTransDateQualifier(new BigInteger(viewId.toString()), "CURRENCYCODE"); 
			   String transDateColumn = reconciliationResultService.getTransDateQualifier(new BigInteger(viewId.toString()), "TRANSDATE");
			   List<BigInteger> viewOriginalIds = getTargetIds(viewId);
			   List<BigInteger> allRecIds = new ArrayList<BigInteger>();
			   if(viewOriginalIds.size()>0)
			   {
				   List<BigInteger> unRecIds = new ArrayList<BigInteger>();
				   HashMap others = new HashMap();
				   HashMap totalAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, qualifier,viewOriginalIds);
				   for(String batch: batches)
				   {
					   HashMap total = new HashMap();
					   HashMap recMap = new HashMap();
					   List<BigInteger> recIds = reconciliationResultRepository.fetchReconciledIdswithJobReferenceForTarget(tenantId, groupId, viewOriginalIds, batch, viewId);
					   allRecIds.addAll(recIds);
					   HashMap reconciled = new HashMap();
					   HashMap unReconciled = new HashMap();
					   recMap.put("name", batch);
					   
					   String currencySymbolRec = "";
					   
					   List<String> currenciesRec = getDistColumnValues(recIds,currencyCodeColName,dv.getDataViewName());
					   if(currenciesRec.size()==1)
					   {
						   currencySymbolRec = currencySymbolRec+getCurrencySymbol(currenciesRec.get(0));
					   }
					   else if(currenciesRec.size()>1)
					   {
						   currencySymbolRec = currencySymbolRec+"*";
					   }

					   HashMap recAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, qualifier,recIds);
					   
					   recMap.put("tAmount", currencySymbolRec+" "+reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
					   recMap.put("tCount", recAmountCount.get("totalCount"));

					   recMap.put("rAmount", currencySymbolRec+" "+reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
					   recMap.put("rCount", recAmountCount.get("totalCount"));
					   
					   recMap.put("uAmount", 0.0);
					   recMap.put("uCount", 0);
					   
					   finalList.add(recMap);
				   }
				   //Others
				   for(BigInteger id : viewOriginalIds)
				   {
					   if(!allRecIds.contains(id))
					   {
						   unRecIds.add(id);
					   }
				   }
				   if(unRecIds.size()>0)
				   {
					   HashMap othersTotal = new HashMap();
					   HashMap othersUnRec = new HashMap();
					   HashMap othersRec = new HashMap();
					   
					   String currencySymbolOthers = "";
					   
					   List<String> currenciesOthers = getDistColumnValues(unRecIds,currencyCodeColName,dv.getDataViewName());
					   if(currenciesOthers.size()==1)
					   {
						   currencySymbolOthers = currencySymbolOthers+getCurrencySymbol(currenciesOthers.get(0));
					   }
					   else if(currenciesOthers.size()>1)
					   {
						   currencySymbolOthers = currencySymbolOthers+"*";
					   }
					   
					   HashMap unRecAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, qualifier,unRecIds);

					   others.put("name", "Others");
					   others.put("tAmount", currencySymbolOthers+" "+reconciliationResultService.getAmountInFormat(unRecAmountCount.get("totalAmount").toString(),currencyFormat));
					   others.put("tCount", unRecAmountCount.get("totalCount"));
					   
					   others.put("rAmount", 0.0);
					   others.put("rCount", 0);
					   
					   others.put("uAmount", currencySymbolOthers+" "+reconciliationResultService.getAmountInFormat(unRecAmountCount.get("totalAmount").toString(),currencyFormat));
					   others.put("uCount", unRecAmountCount.get("totalCount"));

				   }
				   finalList.add(others);
			   }
		   }

	   }catch (SQLException e) {
			e.printStackTrace();
	   }
	   return finalList;
   }
   
   @Transactional
   public List<BigInteger> getOriginalIdsByDateQualifier(Long viewId, String transDateQualifier, String rangeFrom, String rangeTo) throws SQLException
   {
	   List<BigInteger> viewOriginalIds = new ArrayList<BigInteger>();
	   Connection conn = null;
	   Statement stmt = null;
	   ResultSet result = null; 
	   try{
		   String dbUrl=env.getProperty("spring.datasource.url");
		   String[] parts=dbUrl.split("[\\s@&?$+-]+");
		   String host = parts[0].split("/")[2].split(":")[0];
		   String schemaName=parts[0].split("/")[3];
		   String userName = env.getProperty("spring.datasource.username");
		   String password = env.getProperty("spring.datasource.password");
		   String jdbcDriver = env.getProperty("spring.datasource.jdbcdriver");  
		   Class.forName(jdbcDriver);
    	   conn = DriverManager.getConnection(dbUrl, userName, password);
    	   stmt = conn.createStatement();
     	   DataViews dv=dataViewsRepository.findOne(viewId.longValue());
     	   if(dv!= null)
     	   {
     		   String viewName = dv.getDataViewName();
         	   String query = "SELECT scrIds FROM "+schemaName+".`"+viewName.toLowerCase()+"` where Date(`"+transDateQualifier+"`) between '"+rangeFrom+"' AND '"+rangeTo+"'";
         	   result=stmt.executeQuery(query);
        	   while(result.next()){
        		   viewOriginalIds.add(new BigInteger((result.getString(1))));
        	   }  
     	   }
     	   else
     	   {
     		   log.info("View doen't not exist for the view id: "+viewId);
     	   }
	   }
	   catch(SQLException se){
		   log.info("Error while executing query: "+se);
       }
	   catch(Exception e)
	   {
		   log.info("Exception while getting databse properties");
	   }
	   finally{
	   		if(result != null)
	   			result.close();	
	   		if(stmt != null)
	   			stmt.close();
			if(conn != null)
				conn.close();
	   }
   		return viewOriginalIds;
   }

   @Transactional
   public List<BigInteger> getOriginalIdsByTransDatesAndColValue(Long viewId, String rangeFrom, String rangeTo, String columnName, String columnValue, String dataType, String transDateQualifier, List<String> values) throws SQLException
   {
	   List<BigInteger> viewOriginalIds = new ArrayList<BigInteger>();
	   Connection conn = null;
	   Statement stmt = null;
	   ResultSet result = null; 
	   try{
		   String dbUrl=env.getProperty("spring.datasource.url");
		   String[] parts=dbUrl.split("[\\s@&?$+-]+");
		   String host = parts[0].split("/")[2].split(":")[0];
		   String schemaName=parts[0].split("/")[3];
		   String userName = env.getProperty("spring.datasource.username");
		   String password = env.getProperty("spring.datasource.password");
		   String jdbcDriver = env.getProperty("spring.datasource.jdbcdriver");  
		   Class.forName(jdbcDriver);
    	   conn = DriverManager.getConnection(dbUrl, userName, password);
    	   stmt = conn.createStatement();
     	   DataViews dv=dataViewsRepository.findOne(viewId.longValue());
     	   if(dv!= null)
     	   {
     		   String viewName = dv.getDataViewName();
         	   String query = "";
         	   String valueIn = "";
         	   String dateString = values.toString();
         	   dateString = dateString.replace("[", "");
         	   dateString = dateString.replace("]", "");
         	   dateString = dateString.replace(",","|");
         	   dateString = dateString.replace(" ", "");
         	   if("DATE".equalsIgnoreCase(dataType))
         	   {
         		  query = "select scrIds from "+schemaName+".`"+viewName.toLowerCase()+"` where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' and `"+columnName +"` LIKE '%"+columnValue+"%' AND `"+transDateQualifier+"` REGEXP '"+dateString+"'";
         	   }
         	   else if("string".equalsIgnoreCase(dataType) || "VARCHAR".equalsIgnoreCase(dataType))
         	   {
         		  query = "select scrIds from "+schemaName+".`"+viewName.toLowerCase()+"` where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' and `"+columnName+"` = '"+columnValue+"' AND `"+transDateQualifier+"` REGEXP '"+dateString+"'";
         	   }
         	   else if("integer".equalsIgnoreCase(dataType) || "DECIMAL".equalsIgnoreCase(dataType))
         	   {
         		  query = "select scrIds from "+schemaName+".`"+viewName.toLowerCase()+"` where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' and `"+columnName+"` = "+columnValue+" AND `"+transDateQualifier+"` REGEXP '"+dateString+"'";
         	   }
         	   result=stmt.executeQuery(query);
        	   while(result.next()){
        		   viewOriginalIds.add(new BigInteger((result.getString(1))));
        	   }  
     	   }
     	   else
     	   {
     		   log.info("View doen't not exist for the view id: "+viewId);
     	   }
	   }
	   catch(SQLException se){
		   log.info("Error while executing query: "+se);
       }
	   catch(Exception e)
	   {
		   log.info("Exception while getting databse properties");
	   }
	   finally{
	   		if(result != null)
	   			result.close();	
	   		if(stmt != null)
	   			stmt.close();
			if(conn != null)
				conn.close();
	   }
   		return viewOriginalIds;
   }

   
   @Transactional
   public List<BigInteger> getOriginalIdsByColumnValuesNTransDate(Long viewId, String rangeFrom, String rangeTo, String qualifier, List<String> values, String dataType, String transDateQualifier, String transDate) throws SQLException
   {
	   List<BigInteger> viewOriginalIds = new ArrayList<BigInteger>();
	   Connection conn = null;
	   Statement stmt = null;
	   ResultSet result = null; 
	   try{
		   String dbUrl=env.getProperty("spring.datasource.url");
		   String[] parts=dbUrl.split("[\\s@&?$+-]+");
		   String host = parts[0].split("/")[2].split(":")[0];
		   String schemaName=parts[0].split("/")[3];
		   String userName = env.getProperty("spring.datasource.username");
		   String password = env.getProperty("spring.datasource.password");
		   String jdbcDriver = env.getProperty("spring.datasource.jdbcdriver");  
		   Class.forName(jdbcDriver);
    	   conn = DriverManager.getConnection(dbUrl, userName, password);
    	   stmt = conn.createStatement();
     	   DataViews dv=dataViewsRepository.findOne(viewId.longValue());
     	   if(dv!= null)
     	   {
     		   String viewName = dv.getDataViewName();
         	   String query = "";
         	   String valueIn = "";
         	   if("DATE".equalsIgnoreCase(dataType))
         	   {
         			String dateString = values.toString();
         			dateString = dateString.replace("[", "");
         			dateString = dateString.replace("]", "");
         			dateString = dateString.replace(",","|");
         			dateString = dateString.replace(" ", "");
         		   ////SELECT scrIds FROM agree_application_2712.accounting_2_data_view_9 where fileDate between '2018-01-04 00:00:00' AND '2018-01-05 00:00:00' and Date_46  like '%2014-01-03%' and Date_46 REGEXP '2014-01-03|2014-01-01|2014-01-02|2014-01-04';
         		   query = "SELECT scrIds FROM "+schemaName+".`"+viewName.toLowerCase()+"` where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' and `"+transDateQualifier+"` LIKE '%"+transDate+"%' AND `"+qualifier+"` REGEXP '"+dateString+"'";
         	   }
         	   else if("string".equalsIgnoreCase(dataType) || "VARCHAR".equalsIgnoreCase(dataType))
         	   {
				   for(int i=0; i<values.size(); i++)
				   {
					   if(i == values.size()-1)
					   {
						   valueIn = valueIn + "'"+values.get(i).trim()+"'";
					   }
					   else
					   {
						   valueIn = valueIn + "'"+values.get(i).trim()+"',";
					   }
				   }
				   query = "select scrIds from "+schemaName+".`"+viewName.toLowerCase()+"` where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' and `"+transDateQualifier+"` LIKE '%"+transDate+"%' AND `"+qualifier +"` in ("+valueIn+")";
         	   }
         	   else if("integer".equalsIgnoreCase(dataType) || "DECIMAL".equalsIgnoreCase(dataType))
        	   {
				   for(int i=0; i<values.size(); i++)
				   {
					   if(i == values.size()-1)
					   {
						   valueIn = valueIn + ""+values.get(i).trim()+"";
					   }
					   else
					   {
						   valueIn = valueIn + ""+values.get(i).trim()+",";
					   }
				   }
				   query = "select scrIds from "+schemaName+".`"+viewName.toLowerCase()+"` where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' and `"+transDateQualifier+"` LIKE '%"+transDate+"%' AND `"+qualifier +"` in ("+valueIn+")";
        	   }
         	   log.info("Query:>> "+ query);
         	   result=stmt.executeQuery(query);
        	   while(result.next()){
        		   viewOriginalIds.add(new BigInteger((result.getString(1))));
        	   }  
     	   }
     	   else
     	   {
     		   log.info("View doen't not exist for the view id: "+viewId);
     	   }
	   }
	   catch(SQLException se){
		   log.info("Error while executing query: "+se);
       }
	   catch(Exception e)
	   {
		   log.info("Exception while getting databse properties");
	   }
	   finally{
	   		if(result != null)
	   			result.close();	
	   		if(stmt != null)
	   			stmt.close();
			if(conn != null)
				conn.close();
	   }
   		return viewOriginalIds;
   }
   
   @Transactional
   public List<BigInteger> getOriginalIdsByColumnAndTransDate(Long viewId, String rangeFrom, String rangeTo, String qualifier, String qualifierValue, String dataType, String transDateQualifier, String transDate) throws SQLException
   {
	   List<BigInteger> viewOriginalIds = new ArrayList<BigInteger>();
	   Connection conn = null;
	   Statement stmt = null;
	   ResultSet result = null; 
	   
	   try{
		   String dbUrl=env.getProperty("spring.datasource.url");
		   String[] parts=dbUrl.split("[\\s@&?$+-]+");
		   String host = parts[0].split("/")[2].split(":")[0];
		   String schemaName=parts[0].split("/")[3];
		   String userName = env.getProperty("spring.datasource.username");
		   String password = env.getProperty("spring.datasource.password");
		   String jdbcDriver = env.getProperty("spring.datasource.jdbcdriver");  
   		
		   Class.forName(jdbcDriver);
    	   conn = DriverManager.getConnection(dbUrl, userName, password);
    	   stmt = conn.createStatement();
     	   DataViews dv=dataViewsRepository.findOne(viewId.longValue());
     	   
     	   if(dv!= null)
     	   {
     		   String viewName = dv.getDataViewName();
         	   String query = "";
         	   if("DATE".equalsIgnoreCase(dataType))
         	   {
         		   //SELECT scrIds FROM agree_application_2712.accounting_2_data_view_9 where fileDate between '2018-01-04 00:00:00' AND '2018-01-05 00:00:00' and Date_46  like '%2014-01-03%' and Date_46 REGEXP '2014-01-03|2014-01-01|2014-01-02|2014-01-04';
         		   query = "SELECT scrIds FROM "+schemaName+".`"+viewName.toLowerCase()+"` where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' and `"+transDateQualifier+ "` LIKE '%"+transDate+"%'"+ " AND `"+qualifier+"` REGEXP "+"'"+qualifierValue+"'";
         	   }
         	   else if("string".equalsIgnoreCase(dataType) || "VARCHAR".equalsIgnoreCase(dataType))
         	   {
         		   query = "select scrIds from "+schemaName+".`"+viewName.toLowerCase()+"` where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' and `"+transDateQualifier+ "` LIKE '%"+transDate+"%'"+ " AND `"+qualifier +"` = '"+qualifierValue+"'";
         	   }
         	   else if("integer".equalsIgnoreCase(dataType) || "DECIMAL".equalsIgnoreCase(dataType))
         	   {
         		   query = "select scrIds from "+schemaName+".`"+viewName.toLowerCase()+"` where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' and `"+transDateQualifier+ "` LIKE '%"+transDate+"%'"+ " AND `"+qualifier +"` = "+qualifierValue+"";
         	   }
         	  // log.info("TotalIds Size: "+ query);
         	   result=stmt.executeQuery(query);
        	   while(result.next()){
        		   viewOriginalIds.add(new BigInteger((result.getString(1))));
        	   }  
     	   }
     	   else
     	   {
     		   log.info("View doen't not exist for the view id: "+viewId);
     	   }
	   }
	   catch(SQLException se){
		   log.info("Error while executing query: "+se);
       }
	   catch(Exception e)
	   {
		   log.info("Exception while getting databse properties");
	   }
	   finally{
	   		if(result != null)
	   			result.close();	
	   		if(stmt != null)
	   			stmt.close();
			if(conn != null)
				conn.close();
			}
   	return viewOriginalIds;

   }


   @Transactional
   public List<BigInteger> getOriginalIdsByTransDate(Long viewId, String rangeFrom, String rangeTo, String qualifier, String transDate, String dataType, String periodFactor) throws SQLException
   {
	   List<BigInteger> viewOriginalIds = new ArrayList<BigInteger>();
	   Connection conn = null;
	   Statement stmt = null;
	   ResultSet result = null; 
	   
	   try{
		   String dbUrl=env.getProperty("spring.datasource.url");
		   String[] parts=dbUrl.split("[\\s@&?$+-]+");
		   String host = parts[0].split("/")[2].split(":")[0];
		   String schemaName=parts[0].split("/")[3];
		   String userName = env.getProperty("spring.datasource.username");
		   String password = env.getProperty("spring.datasource.password");
		   String jdbcDriver = env.getProperty("spring.datasource.jdbcdriver");  
   		
		   Class.forName(jdbcDriver);
    	   conn = DriverManager.getConnection(dbUrl, userName, password);
    	   stmt = conn.createStatement();
     	   DataViews dv=dataViewsRepository.findOne(viewId.longValue());
     	   
     	   if(dv!= null)
     	   {
     		   String viewName = dv.getDataViewName();
         	   String query = "";
         	   if("fileDate".equalsIgnoreCase(periodFactor))
         	   {
             	   if("DATE".equalsIgnoreCase(dataType))
             	   {
             		   query = "SELECT scrIds FROM "+schemaName+".`"+viewName.toLowerCase()+"` where Date(fileDate) between '"+rangeFrom+"' AND '"+rangeTo+"' and Date(`"+qualifier+"`) REGEXP '"+transDate+"'";
             	   }
             	   else if("string".equalsIgnoreCase(dataType) || "VARCHAR".equalsIgnoreCase(dataType))
             	   {
             		   log.info("TotalIdsQuery: select scrIds from "+schemaName+".`"+viewName.toLowerCase()+"` where Date(fileDate) between '"+rangeFrom+"' AND '"+rangeTo+"' and `"+qualifier +"` = '"+transDate+"'");
             		   query = "select scrIds from "+schemaName+".`"+viewName.toLowerCase()+"` where Date(fileDate) between '"+rangeFrom+"' AND '"+rangeTo+"' and `"+qualifier +"` = '"+transDate+"'";
             	   }
             	   else if("integer".equalsIgnoreCase(dataType) || "DECIMAL".equalsIgnoreCase(dataType))
             	   {
             		   query = "select scrIds from "+schemaName+".`"+viewName.toLowerCase()+"` where Date(fileDate) between '"+rangeFrom+"' AND '"+rangeTo+"' and `"+qualifier +"` = "+transDate+"";
             	   }
         	   }
         	   else if("dateQualifier".equalsIgnoreCase(periodFactor))
         	   {
         		   String dateQualifier = getTransDateQualifier(new BigInteger(viewId.toString()), "TRANSDATE"); 
         		   if(dateQualifier.length()>0)
         		   {
                 	   if("DATE".equalsIgnoreCase(dataType))
                 	   {
                 		   query = "SELECT scrIds FROM "+schemaName+".`"+viewName.toLowerCase()+"` where Date(`"+dateQualifier+"`) between '"+rangeFrom+"' AND '"+rangeTo+"' and Date(`"+qualifier+"`) REGEXP '"+transDate+"'";
                 	   }
                 	   else if("string".equalsIgnoreCase(dataType) || "VARCHAR".equalsIgnoreCase(dataType))
                 	   {
                 		   query = "select scrIds from "+schemaName+".`"+viewName.toLowerCase()+"` where Date(`"+dateQualifier+"`) between '"+rangeFrom+"' AND '"+rangeTo+"' and `"+qualifier +"` = '"+transDate+"'";
                 	   }
                 	   else if("integer".equalsIgnoreCase(dataType) || "DECIMAL".equalsIgnoreCase(dataType))
                 	   {
                 		   query = "select scrIds from "+schemaName+".`"+viewName.toLowerCase()+"` where Date(`"+dateQualifier+"`) between '"+rangeFrom+"' AND '"+rangeTo+"' and `"+qualifier +"` = "+transDate+"";
                 	   }
         		   }
         	   }

         	   result=stmt.executeQuery(query);
        	   while(result.next()){
        		   viewOriginalIds.add(new BigInteger((result.getString(1))));
        	   }  
     	   }
     	   else
     	   {
     		   log.info("View doen't not exist for the view id: "+viewId);
     	   }
	   }
	   catch(SQLException se){
		   log.info("Error while executing query: "+se);
       }
	   catch(Exception e)
	   {
		   log.info("Exception while getting databse properties");
	   }
	   finally{
	   		if(result != null)
	   			result.close();	
	   		if(stmt != null)
	   			stmt.close();
			if(conn != null)
				conn.close();
			}
	  // log.info("Ids Size: "+viewOriginalIds.size());
   	return viewOriginalIds;

   }
   
   @Transactional
   public List<BigInteger> getOriginalIdsByTransDateWithCurrency(Long viewId, String rangeFrom, String rangeTo, String qualifier, String transDate, String dataType, String currencyQualifier, String currencyCode) throws SQLException
   {
	 //  log.info("Fetching total original ids for the view id "+ viewId+" between "+ rangeFrom + " and "+ rangeTo +" trans date: "+ transDate+" column name: "+ qualifier);
	   List<BigInteger> viewOriginalIds = new ArrayList<BigInteger>();
	   Connection conn = null;
	   Statement stmt = null;
	   ResultSet result = null; 
	   
	   try{
		   String dbUrl=env.getProperty("spring.datasource.url");
		   String[] parts=dbUrl.split("[\\s@&?$+-]+");
		   String host = parts[0].split("/")[2].split(":")[0];
		   String schemaName=parts[0].split("/")[3];
		   String userName = env.getProperty("spring.datasource.username");
		   String password = env.getProperty("spring.datasource.password");
		   String jdbcDriver = env.getProperty("spring.datasource.jdbcdriver");  
   		
		   Class.forName(jdbcDriver);
    	   conn = DriverManager.getConnection(dbUrl, userName, password);
    	   stmt = conn.createStatement();
     	   DataViews dv=dataViewsRepository.findOne(viewId.longValue());
     	   
     	   if(dv!= null)
     	   {
     		   String viewName = dv.getDataViewName();
         	   String query = "";
         	   if("string".equalsIgnoreCase(dataType))
         	   {
         		   query = "select scrIds from "+schemaName+".`"+viewName.toLowerCase()+"` where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' and `"+qualifier +"` = '"+transDate+"' AND `"+currencyQualifier+"` = '"+currencyCode.trim()+"'";
         	   }
         	   else if("integer".equalsIgnoreCase(dataType))
         	   {
         		  query = "select scrIds from "+schemaName+".`"+viewName.toLowerCase()+"` where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' and `"+qualifier +"` = '"+transDate+"' AND `"+currencyQualifier+"` = '"+currencyCode.trim()+"'";
         	   }
         	   //log.info("Query: "+query);
        	   result=stmt.executeQuery(query);
        	   while(result.next()){
        		   viewOriginalIds.add(new BigInteger((result.getString(1))));
        	   }  
     	   }
     	   else
     	   {
     		   log.info("View doen't not exist for the view id: "+viewId);
     	   }
	   }
	   catch(SQLException se){
		   log.info("Error while executing query: "+se);
       }
	   catch(Exception e)
	   {
		   log.info("Exception while getting databse properties");
	   }
	   finally{
	   		if(result != null)
	   			result.close();	
	   		if(stmt != null)
	   			stmt.close();
			if(conn != null)
				conn.close();
			}
   	//log.info("View ID: "+ viewId+", Row Ids Size: "+viewOriginalIds.size());
   	return viewOriginalIds;

   }
   
   public List<BigInteger> getTargetIdsByTransDates(Long viewId,String qualifier, List<String> transDates) throws SQLException
   {
	   //	log.info("Fetching reconciled and unreconciled ids for the trans dates");
	   	
		String dateString = transDates.toString();
		dateString = dateString.replace("[", "");
		dateString = dateString.replace("]", "");
		dateString = dateString.replace(",","|");
		dateString = dateString.replace(" ", "");
	   	
		List<BigInteger> viewOriginalIds = new ArrayList<BigInteger>();
		Connection conn = null;
		Statement stmt = null;
		ResultSet result = null; 
	   
		try{
			String dbUrl=env.getProperty("spring.datasource.url");
			String[] parts=dbUrl.split("[\\s@&?$+-]+");
			String host = parts[0].split("/")[2].split(":")[0];
			String schemaName=parts[0].split("/")[3];
			String userName = env.getProperty("spring.datasource.username");
			String password = env.getProperty("spring.datasource.password");
			String jdbcDriver = env.getProperty("spring.datasource.jdbcdriver");  
   		
			Class.forName(jdbcDriver);
			conn = DriverManager.getConnection(dbUrl, userName, password);
			
			stmt = conn.createStatement();
     	   	DataViews dv=dataViewsRepository.findOne(viewId.longValue());
     	   
     	   	if(dv!= null)
     	   	{
     	   		String viewName = dv.getDataViewName();
     	   		result=stmt.executeQuery("SELECT scrIds FROM "+schemaName+".`"+viewName.toLowerCase()+"` where `"+qualifier+"` REGEXP '"+dateString+"'");
     	   		stmt.setFetchSize(500);
     	   		while(result.next()){
     	   			viewOriginalIds.add(new BigInteger((result.getString(1))));
     	   		}  
     	   	}
     	   	else
     	   	{
     	   		log.info("View doen't not exist for the view id: "+viewId);
     	   	}
		}
		catch(SQLException se){
			log.info("Error while executing query: "+se);
		}
		catch(Exception e)
		{
			log.info("Exception while getting databse properties");
		}
		finally{
			if(result != null)
				result.close();	
	   		if(stmt != null)
	   			stmt.close();
			if(conn != null)
				conn.close();
		}
		//log.info("View ID: "+ viewId+", Row Ids Size: "+viewOriginalIds.size());
		return viewOriginalIds;
   }
   public List<BigInteger> getOriginalIdsForDateQualifier(Long viewId, String rangeFrom, String rangeTo, String qualifier, List<String> transDates) throws SQLException
   {
	   //	log.info("Fetching reconciled and unreconciled ids for the trans dates");
	   	
		String dateString = transDates.toString();
		dateString = dateString.replace("[", "");
		dateString = dateString.replace("]", "");
		dateString = dateString.replace(",","|");
		dateString = dateString.replace(" ", "");
	   	
		List<BigInteger> viewOriginalIds = new ArrayList<BigInteger>();
		Connection conn = null;
		Statement stmt = null;
		ResultSet result = null; 
	   
		try{
			String dbUrl=env.getProperty("spring.datasource.url");
			String[] parts=dbUrl.split("[\\s@&?$+-]+");
			String host = parts[0].split("/")[2].split(":")[0];
			String schemaName=parts[0].split("/")[3];
			String userName = env.getProperty("spring.datasource.username");
			String password = env.getProperty("spring.datasource.password");
			String jdbcDriver = env.getProperty("spring.datasource.jdbcdriver");  
   		
			Class.forName(jdbcDriver);
			conn = DriverManager.getConnection(dbUrl, userName, password);
			
			stmt = conn.createStatement();
     	   	DataViews dv=dataViewsRepository.findOne(viewId.longValue());
     	   
     	   	if(dv!= null)
     	   	{
     	   		String viewName = dv.getDataViewName();
     	   		result=stmt.executeQuery("SELECT scrIds FROM "+schemaName+".`"+viewName.toLowerCase()+"` where Date(`"+qualifier+"`) between '"+rangeFrom+"' AND '"+rangeTo+"' AND Date(`"+qualifier+"`) REGEXP '"+dateString+"'");
     	   		stmt.setFetchSize(500);
     	   		while(result.next()){
     	   			viewOriginalIds.add(new BigInteger((result.getString(1))));
     	   		}  
     	   	}
     	   	else
     	   	{
     	   		log.info("View doen't not exist for the view id: "+viewId);
     	   	}
		}
		catch(SQLException se){
			log.info("Error while executing query: "+se);
		}
		catch(Exception e)
		{
			log.info("Exception while getting databse properties");
		}
		finally{
			if(result != null)
				result.close();	
	   		if(stmt != null)
	   			stmt.close();
			if(conn != null)
				conn.close();
		}
		//log.info("View ID: "+ viewId+", Row Ids Size: "+viewOriginalIds.size());
		return viewOriginalIds;
   }
   
   public List<BigInteger> getOriginalIdsByTransDates(Long viewId, String rangeFrom, String rangeTo, String qualifier, List<String> transDates) throws SQLException
   {
	   //	log.info("Fetching reconciled and unreconciled ids for the trans dates");
	   	
		String dateString = transDates.toString();
		dateString = dateString.replace("[", "");
		dateString = dateString.replace("]", "");
		dateString = dateString.replace(",","|");
		dateString = dateString.replace(" ", "");
	   	
		List<BigInteger> viewOriginalIds = new ArrayList<BigInteger>();
		Connection conn = null;
		Statement stmt = null;
		ResultSet result = null; 
	   
		try{
			String dbUrl=env.getProperty("spring.datasource.url");
			String[] parts=dbUrl.split("[\\s@&?$+-]+");
			String host = parts[0].split("/")[2].split(":")[0];
			String schemaName=parts[0].split("/")[3];
			String userName = env.getProperty("spring.datasource.username");
			String password = env.getProperty("spring.datasource.password");
			String jdbcDriver = env.getProperty("spring.datasource.jdbcdriver");  
   		
			Class.forName(jdbcDriver);
			conn = DriverManager.getConnection(dbUrl, userName, password);
			
			stmt = conn.createStatement();
     	   	DataViews dv=dataViewsRepository.findOne(viewId.longValue());
     	   
     	   	if(dv!= null)
     	   	{
     	   		String viewName = dv.getDataViewName();
     	   		result=stmt.executeQuery("SELECT scrIds FROM "+schemaName+".`"+viewName.toLowerCase()+"` where Date(`"+qualifier+"`) between '"+rangeFrom+"' AND '"+rangeTo+"' AND Date(`"+qualifier+"`) REGEXP '"+dateString+"'");
     	   		stmt.setFetchSize(500);
     	   		while(result.next()){
     	   			viewOriginalIds.add(new BigInteger((result.getString(1))));
     	   		}  
     	   	}
     	   	else
     	   	{
     	   		log.info("View doen't not exist for the view id: "+viewId);
     	   	}
		}
		catch(SQLException se){
			log.info("Error while executing query: "+se);
		}
		catch(Exception e)
		{
			log.info("Exception while getting databse properties");
		}
		finally{
			if(result != null)
				result.close();	
	   		if(stmt != null)
	   			stmt.close();
			if(conn != null)
				conn.close();
		}
		//log.info("View ID: "+ viewId+", Row Ids Size: "+viewOriginalIds.size());
		return viewOriginalIds;
   }
   
   public Map<String, List<BigInteger>> getUnRecIdsForSource(Long tenantId,Long groupId, Long viewId, String rangeFrom, String rangeTo, String transDateQualifier, List<String> transDates, String periodFactor) throws SQLException, ClassNotFoundException
   {
	   log.info("Fetching Reconciled, Un-Reconciled With Days...");
	   Map<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
	   List<BigInteger> reconciledIds = new ArrayList<BigInteger>();
	   List<BigInteger> suggestedIds = new ArrayList<BigInteger>();
	   List<BigInteger> unReconciledIds = new ArrayList<BigInteger>();
	   
	   List<BigInteger> totalOriginalIds = new ArrayList<BigInteger>();
	   HashMap stotalIdsMap = getTotalByPeriodFactorForDays(viewId, periodFactor, rangeFrom, rangeTo,transDates);
	   /*if("Success".equalsIgnoreCase(stotalIdsMap.get("status").toString()))
	   {*/
		   totalOriginalIds = (List<BigInteger>) stotalIdsMap.get("totalIds");
	  /* }*/
	   
	   if(totalOriginalIds.size()>0)
	   {
		   reconciledIds = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForSource(tenantId, groupId, totalOriginalIds, viewId);
		   suggestedIds = reconciliationDuplicateResultRepository.fetchReconciledIdswithStatusUnreconciledForSource(tenantId, groupId, totalOriginalIds, viewId);
		   for(BigInteger id: totalOriginalIds)
		   {
			   if(!reconciledIds.contains(id))
			   {
				   unReconciledIds.add(id);
			   }
		   }
		   unReconciledIds.removeAll(suggestedIds);
	   }
	   	finalMap.put("reconciled", reconciledIds);
	   	finalMap.put("unReconciled", unReconciledIds);
	   	finalMap.put("totalIds", totalOriginalIds);
	   	log.info("reconciled: "+ reconciledIds.size() + "unReconciled: "+ unReconciledIds.size() +"total: "+ totalOriginalIds.size());
	   return finalMap;
   }
   
   public Map<String, List<BigInteger>> getSourceRecNUnRecIdsByDays(Long tenantId,Long groupId, Long viewId, String rangeFrom, String rangeTo, String transDateQualifier, List<String> transDates, String jobReference) throws SQLException
   {
	   log.info("Fetching Reconciled, Un-Reconciled With Days...");
	   Map<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
	   List<BigInteger> reconciledIds = new ArrayList<BigInteger>();
	   List<BigInteger> unReconciledIds = new ArrayList<BigInteger>();
	   
	   List<BigInteger> totalOriginalIds = getOriginalIdsByTransDates(viewId, rangeFrom, rangeTo, transDateQualifier, transDates);
	   if(totalOriginalIds.size()>0)
	   {
			   reconciledIds = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForSource(tenantId, groupId, totalOriginalIds, viewId);
		   for(BigInteger id: totalOriginalIds)
		   {
			   if(!reconciledIds.contains(id))
			   {
				   unReconciledIds.add(id);
			   }
		   }
	   }
	   	finalMap.put("reconciled", reconciledIds);
	   	finalMap.put("unReconciled", unReconciledIds);
	   	finalMap.put("totalIds", totalOriginalIds);
	   	log.info("reconciled: "+ reconciledIds.size() + "unReconciled: "+ unReconciledIds.size() +"total: "+ totalOriginalIds.size());
	   return finalMap;
   }
   
   public Map<String, List<BigInteger>> getUnRecIdsForTarget(Long tenantId,Long groupId, Long viewId, String rangeFrom, String rangeTo, String transDateQualifier, List<String> transDates, String periodFactor) throws SQLException, ClassNotFoundException
   {
	   log.info("Fetch rec unrec for days");
	   Map<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
	   List<BigInteger> reconciledIds = new ArrayList<BigInteger>();
	   List<BigInteger> unReconciledIds = new ArrayList<BigInteger>();
	   List<BigInteger> suggestedIds = new ArrayList<BigInteger>();
	   List<BigInteger> totalOriginalIds = new ArrayList<BigInteger>();
	   
	   /*HashMap stotalIdsMap = getTotalByPeriodFactorForDays(viewId, periodFactor, rangeFrom, rangeTo,transDates);*/
	   HashMap stotalIdsMap = getTotalByPeriodFactor(viewId, periodFactor, rangeFrom, rangeTo);
	   
	   /*if("Success".equalsIgnoreCase(stotalIdsMap.get("status").toString()))
	   {*/
		   /*totalOriginalIds = (List<BigInteger>) stotalIdsMap.get("totalIds");*/
	   
/*s	   HashMap stotalIdsMap = getTotalByPeriodFactor(viewId, periodFactor, rangeFrom, rangeTo);*/
	   if("Success".equalsIgnoreCase(stotalIdsMap.get("status").toString()))
	   {
		   totalOriginalIds = (List<BigInteger>) stotalIdsMap.get("totalIds");
	   }
	   if(totalOriginalIds.size()>0)
	   {
		   reconciledIds = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForTarget(tenantId, groupId, totalOriginalIds, viewId);
		   suggestedIds = reconciliationDuplicateResultRepository.fetchReconciledIdswithStatusUnreconciledForTarget(tenantId, groupId, totalOriginalIds, viewId);
		   for(BigInteger id: totalOriginalIds)
		   {
			   if(!reconciledIds.contains(id))
			   {
				   unReconciledIds.add(id);
			   }
		   }
		   unReconciledIds.removeAll(suggestedIds);
	   }
	   	finalMap.put("reconciled", reconciledIds);
	   	finalMap.put("unReconciled", unReconciledIds);
	   	finalMap.put("totalIds", totalOriginalIds);
	   	log.info("reconciled: "+ reconciledIds.size() + "unReconciled: "+ unReconciledIds.size() +"total: "+ totalOriginalIds.size());
	   return finalMap;
   }
   
   public Map<String, List<BigInteger>> getTargetRecNUnRecIdsByDays(Long tenantId,Long groupId, Long viewId, String rangeFrom, String rangeTo, String transDateQualifier, List<String> transDates, String jobReference) throws SQLException
   {
	   log.info("Fetch rec unrec for days");
	   Map<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
	   List<BigInteger> reconciledIds = new ArrayList<BigInteger>();
	   List<BigInteger> unReconciledIds = new ArrayList<BigInteger>();
	   List<BigInteger> totalOriginalIds = getTargetIdsByTransDates(viewId, transDateQualifier, transDates);
	   if(totalOriginalIds.size()>0)
	   {
			   reconciledIds = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForTarget(tenantId, groupId, totalOriginalIds, viewId);
		   for(BigInteger id: totalOriginalIds)
		   {
			   if(!reconciledIds.contains(id))
			   {
				   unReconciledIds.add(id);
			   }
		   }
	   }
	   	finalMap.put("reconciled", reconciledIds);
	   	finalMap.put("unReconciled", unReconciledIds);
	   	finalMap.put("totalIds", totalOriginalIds);
	   	log.info("reconciled: "+ reconciledIds.size() + "unReconciled: "+ unReconciledIds.size() +"total: "+ totalOriginalIds.size());
	   return finalMap;
   }
   
   /**
    * Author: Shiva
    * Purpose: Fetching column values grouped list
    * @throws ClassNotFoundException 
    * @throws SQLException 
 * @throws ParseException 
    * **/
   public List<HashMap> getGroupColumnValuesListForTarget(List<String> colValues, String rangeFrom, String rangeTo, Long viewId, Long tenantId, Long groupId, String amountQualifier, Long colId, String jobReference) throws ClassNotFoundException, SQLException, ParseException
   {
	   List<HashMap> finalList = new ArrayList<HashMap>();
	   Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	   String currencyFormat = props.getProperty("currencyFormat");
	   
	   DataViewsColumns dvc = dataViewsColumnsRepository.findOne(colId);
	   String columnName = "";
	   String dataType = "";
	   String currencyCodeColName = getTransDateQualifier(new BigInteger(viewId.toString()), "CURRENCYCODE"); 
	   DataViews dv = dataViewsRepository.findOne(viewId);
	   if(dv != null)
	   {
		   if(dvc != null)
		   {
			   if("VARCHAR".equals(dvc.getColDataType()) || "DATE".equalsIgnoreCase(dvc.getColDataType()))
			   {
				   dataType = dataType+"string";
			   }
			   else if("INTEGER".equalsIgnoreCase(dvc.getColDataType()) || "DECIMAL".equalsIgnoreCase(dvc.getColDataType()))
			   {
				   dataType = dataType+"integer";
			   }   
			   if("File Template".equalsIgnoreCase(dvc.getRefDvType()))
			   {
				   FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dvc.getRefDvColumn().toString()));
				   if(ftl != null)
				   {
					   columnName = columnName + ftl.getColumnAlias();
				   }
			   }
			   else if("Data View".equalsIgnoreCase(dvc.getRefDvType()) || dvc.getRefDvType() == null)
			   {
				   columnName = columnName + dvc.getColumnName();
			   }
		   }
		   for(String colValue: colValues)
		   {
			   HashMap colValuMP = new HashMap();
			   colValuMP.put("name", colValue);
			   List<BigInteger> totalOriginalIds = getOriginalIdsByTransDate(viewId, rangeFrom, rangeTo, columnName, colValue, dataType,"fileDate");
			   
			   List<BigInteger> unRecIds = new ArrayList<BigInteger>();
			   if(totalOriginalIds.size()>0)
			   {
				   List<BigInteger> recIds = new ArrayList<BigInteger>();
				   
				   /*if(jobReference.length()>0)
				   {
					   recIds = reconciliationResultRepository.fetchReconciledIdswithJobReferenceForSource(tenantId,groupId, totalOriginalIds, jobReference);
				   }
				   else
				   {*/
					   recIds = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForTarget(tenantId, groupId, totalOriginalIds, viewId);
				   /*}*/

				   for(BigInteger id: totalOriginalIds)
				   {
					   if(!recIds.contains(id))
					   {
						   unRecIds.add(id);
					   }
				   }
				   
				   HashMap total = new HashMap();
				   HashMap recon = new HashMap();
				   HashMap unRecon = new HashMap();
				   
				   String currencySymbolRec = "";
				   
				   List<String> currenciesRec = getDistColumnValues(recIds,currencyCodeColName,dv.getDataViewName());
				   if(currenciesRec.size()==1)
				   {
					   currencySymbolRec = currencySymbolRec+getCurrencySymbol(currenciesRec.get(0));
				   }
				   else if(currenciesRec.size()>1)
				   {
					   currencySymbolRec = currencySymbolRec+"*";
				   }
				   
				   String currencySymbolUnRec = "";
				   
				   List<String> currenciesUnRec = getDistColumnValues(unRecIds,currencyCodeColName,dv.getDataViewName());
				   if(currenciesUnRec.size()==1)
				   {
					   currencySymbolUnRec = currencySymbolUnRec+getCurrencySymbol(currenciesUnRec.get(0));
				   }
				   else if(currenciesUnRec.size()>1)
				   {
					   currencySymbolUnRec = currencySymbolUnRec+"*";
				   }
				   
				   String currencySymbolTot = "";
				   
				   List<String> currenciesTot = getDistColumnValues(totalOriginalIds,currencyCodeColName,dv.getDataViewName());
				   if(currenciesTot.size()==1)
				   {
					   currencySymbolTot = currencySymbolTot+getCurrencySymbol(currenciesTot.get(0));
				   }
				   else if(currenciesTot.size()>1)
				   {
					   currencySymbolTot = currencySymbolTot+"*";
				   }
				   
				   HashMap totalAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, amountQualifier,totalOriginalIds);

				   colValuMP.put("tAmount", currencySymbolTot + " " + reconciliationResultService.getAmountInFormat(totalAmountCount.get("totalAmount").toString(),currencyFormat));
				   colValuMP.put("tCount", totalAmountCount.get("totalCount"));
				   
				   HashMap recAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, amountQualifier,recIds);

				   colValuMP.put("rAmount", currencySymbolRec + " " + reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
				   colValuMP.put("rCount", recAmountCount.get("totalCount"));
				   
				   HashMap unRecAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, amountQualifier,unRecIds);

				   colValuMP.put("uAmount", currencySymbolUnRec + " " + reconciliationResultService.getAmountInFormat(unRecAmountCount.get("totalAmount").toString(),currencyFormat));
				   colValuMP.put("uCount", unRecAmountCount.get("totalCount"));
			   }
			   finalList.add(colValuMP);
		   }

	   }
	   log.info("Grouped by trans date size: "+finalList.size());
	   return finalList;
   }
   
   public List<HashMap> getGroupColumnValuesList(List<String> colValues, String rangeFrom, String rangeTo, Long viewId, Long tenantId, Long groupId, String amountQualifier, Long colId, String jobReference) throws ClassNotFoundException, SQLException, ParseException
   {
	   List<HashMap> finalList = new ArrayList<HashMap>();
	   Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	   String currencyFormat = props.getProperty("currencyFormat");	   
	   DataViewsColumns dvc = dataViewsColumnsRepository.findOne(colId);
	   String columnName = "";
	   String dataType = "";
	   String currencyCodeColName = getTransDateQualifier(new BigInteger(viewId.toString()), "CURRENCYCODE"); 
	   DataViews dv = dataViewsRepository.findOne(viewId);
	   if(dv != null)
	   {
		   if(dvc != null)
		   {
				   if("VARCHAR".equals(dvc.getColDataType()) || "DATE".equalsIgnoreCase(dvc.getColDataType()))
				   {
					   dataType = dataType+"string";
				   }
				   else if("INTEGER".equalsIgnoreCase(dvc.getColDataType()) || "DECIMAL".equalsIgnoreCase(dvc.getColDataType()))
				   {
					   dataType = dataType+"integer";
				   }
				   
				   if("File Template".equalsIgnoreCase(dvc.getRefDvType()))
				   {
					   FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dvc.getRefDvColumn().toString()));
					   if(ftl != null)
					   {
						   columnName = columnName + ftl.getColumnAlias();
					   }
				   }
				   else if("Data View".equalsIgnoreCase(dvc.getRefDvType()) || dvc.getRefDvType() == null)
				   {
					   columnName = columnName + dvc.getColumnName();
				   }
		   }
		   for(String colValue: colValues)
		   {
			   HashMap colValuMP = new HashMap();
			   colValuMP.put("name", colValue);
			   List<BigInteger> totalOriginalIds = getOriginalIdsByTransDate(viewId, rangeFrom, rangeTo, columnName, colValue, dataType, "fileDate");
			   
			   List<BigInteger> unRecIds = new ArrayList<BigInteger>();
			   if(totalOriginalIds.size()>0)
			   {
				   List<BigInteger> recIds = new ArrayList<BigInteger>();
				   recIds = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForSource(tenantId, groupId, totalOriginalIds, viewId);
				   for(BigInteger id: totalOriginalIds)
				   {
					   if(!recIds.contains(id))
					   {
						   unRecIds.add(id);
					   }
				   }
				   
				   HashMap total = new HashMap();
				   HashMap recon = new HashMap();
				   HashMap unRecon = new HashMap();
				   
				   String currencySymbolRec = "";
				   
				   List<String> currenciesRec = getDistColumnValues(recIds,currencyCodeColName,dv.getDataViewName());
				   if(currenciesRec.size()==1)
				   {
					   currencySymbolRec = currencySymbolRec+getCurrencySymbol(currenciesRec.get(0));
				   }
				   else if(currenciesRec.size()>1)
				   {
					   currencySymbolRec = currencySymbolRec+"*";
				   }
				   
				   String currencySymbolUnRec = "";
				   
				   List<String> currenciesUnRec = getDistColumnValues(unRecIds,currencyCodeColName,dv.getDataViewName());
				   if(currenciesUnRec.size()==1)
				   {
					   currencySymbolUnRec = currencySymbolUnRec+getCurrencySymbol(currenciesUnRec.get(0));
				   }
				   else if(currenciesUnRec.size()>1)
				   {
					   currencySymbolUnRec = currencySymbolUnRec+"*";
				   }
				   
				   String currencySymbolTot = "";
				   
				   List<String> currenciesTot = getDistColumnValues(totalOriginalIds,currencyCodeColName,dv.getDataViewName());
				   if(currenciesTot.size()==1)
				   {
					   currencySymbolTot = currencySymbolTot+getCurrencySymbol(currenciesTot.get(0));
				   }
				   else if(currenciesTot.size()>1)
				   {
					   currencySymbolTot = currencySymbolTot+"*";
				   }
				   
				   HashMap totalAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, amountQualifier,totalOriginalIds);

				   colValuMP.put("tAmount", currencySymbolTot + " " + reconciliationResultService.getAmountInFormat(totalAmountCount.get("totalAmount").toString(),currencyFormat));
				   colValuMP.put("tCount", totalAmountCount.get("totalCount"));
				//   colValuMP.put("tdCount", totalOriginalIds.size());
				   
				   HashMap recAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, amountQualifier,recIds);

				   colValuMP.put("rAmount", currencySymbolRec + " " + reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
				   colValuMP.put("rCount", recAmountCount.get("totalCount"));
				//   colValuMP.put("rdCount", recIds.size());
				   
				   HashMap unRecAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, amountQualifier,unRecIds);

				   colValuMP.put("uAmount", currencySymbolUnRec + " " + reconciliationResultService.getAmountInFormat(unRecAmountCount.get("totalAmount").toString(),currencyFormat));
				   colValuMP.put("uCount", unRecAmountCount.get("totalCount"));
				//   colValuMP.put("udCount", unRecIds.size());
			   }
			   finalList.add(colValuMP);
		   }

	   }
	   log.info("Grouped by trans date size: "+finalList.size());
	   return finalList;
   }
   
   /**
    * Author: Shiva
    * Purpose: Fetching trans date's grouped list
    * @throws ClassNotFoundException 
    * @throws SQLException 
 * @throws ParseException 
 * @throws java.text.ParseException 
    * **/
   public List<HashMap> getGroupedTransDatesList(List<String> transDates, String rangeFrom, String rangeTo, Long viewId, Long tenantId, Long groupId, String qualifier, String amountQualifier, String jobReference) throws ClassNotFoundException, SQLException, ParseException, java.text.ParseException
   {
	   //log.info("Fetching grouped list for the transdates: "+ transDates+", View Id: "+ viewId);
	   List<HashMap> finalList = new ArrayList<HashMap>();
	   Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	   String currencyFormat = props.getProperty("currencyFormat");
	   
	   String currencyCodeColName = getTransDateQualifier(new BigInteger(viewId.toString()), "CURRENCYCODE"); 
	   DataViews dv = dataViewsRepository.findOne(viewId);
	   
	   if(dv != null)
	   {
		   for(String transDate: transDates)
		   {
			   DateFormat df = new SimpleDateFormat("yyyy-MM-dd");
			   HashMap transDateMp = new HashMap();
			   Date date= df.parse(transDate);
			   df = new SimpleDateFormat("dd-MMM-yy");
			   transDateMp.put("name", df.format(date));
			   
			   List<BigInteger> totalOriginalIds = getOriginalIdsByTransDate(viewId, rangeFrom, rangeTo, qualifier, transDate, "DATE","fileDate");
			   List<BigInteger> unRecIds = new ArrayList<BigInteger>();
			   if(totalOriginalIds.size()>0)
			   {
				   List<BigInteger> recIds = new ArrayList<BigInteger>();
				   recIds = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForSource(tenantId, groupId, totalOriginalIds,viewId);

				   for(BigInteger id: totalOriginalIds)
				   {
					   if(!recIds.contains(id))
					   {
						   unRecIds.add(id);
					   }
				   }
				   
				   HashMap total = new HashMap();
				   HashMap recon = new HashMap();
				   HashMap unRecon = new HashMap();

				   String currencySymbolRec = "";
				   
				   List<String> currenciesRec = getDistColumnValues(recIds,currencyCodeColName,dv.getDataViewName());
				   if(currenciesRec.size()==1)
				   {
					   currencySymbolRec = currencySymbolRec+getCurrencySymbol(currenciesRec.get(0));
				   }
				   else if(currenciesRec.size()>1)
				   {
					   currencySymbolRec = currencySymbolRec+"*";
				   }
				   
				   String currencySymbolUnRec = "";
				   
				   List<String> currenciesUnRec = getDistColumnValues(unRecIds,currencyCodeColName,dv.getDataViewName());
				   if(currenciesUnRec.size()==1)
				   {
					   currencySymbolUnRec = currencySymbolUnRec+getCurrencySymbol(currenciesUnRec.get(0));
				   }
				   else if(currenciesUnRec.size()>1)
				   {
					   currencySymbolUnRec = currencySymbolUnRec+"*";
				   }
				   
				   String currencySymbolTot = "";
				   
				   List<String> currenciesTot = getDistColumnValues(totalOriginalIds,currencyCodeColName,dv.getDataViewName());
				   if(currenciesTot.size()==1)
				   {
					   currencySymbolTot = currencySymbolTot+getCurrencySymbol(currenciesTot.get(0));
				   }
				   else if(currenciesTot.size()>1)
				   {
					   currencySymbolTot = currencySymbolTot+"*";
				   }
				   
				   HashMap totalAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, amountQualifier,totalOriginalIds);

				   transDateMp.put("tAmount", currencySymbolTot + " " + reconciliationResultService.getAmountInFormat(totalAmountCount.get("totalAmount").toString(),currencyFormat));
				   transDateMp.put("tCount", totalAmountCount.get("totalCount"));
				//   transDateMp.put("tdCount", totalOriginalIds.size());
				   
				   HashMap recAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, amountQualifier,recIds);
				   
				   transDateMp.put("rAmount", currencySymbolRec + " " + reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
				   transDateMp.put("rCount", recAmountCount.get("totalCount"));
				//   transDateMp.put("rdCount", recIds.size());
				   
				   HashMap unRecAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, amountQualifier,unRecIds);
				   transDateMp.put("uAmount", currencySymbolUnRec + " " + reconciliationResultService.getAmountInFormat(unRecAmountCount.get("totalAmount").toString(),currencyFormat));
				   transDateMp.put("uCount", unRecAmountCount.get("totalCount"));
				//   transDateMp.put("udCount", unRecIds.size());
			   }
			   finalList.add(transDateMp);
		   }
	   }
	  
	   log.info("Grouped by trans date size: "+finalList.size());
	   return finalList;
   }

   public List<HashMap> getGroupedTransDatesListForTarget(List<String> transDates, String rangeFrom, String rangeTo, Long viewId, Long tenantId, Long groupId, String qualifier, String amountQualifier, String jobReference) throws ClassNotFoundException, SQLException, ParseException, java.text.ParseException
   {
	   //log.info("Fetching grouped list for the transdates: "+ transDates+", View Id: "+ viewId);
	   List<HashMap> finalList = new ArrayList<HashMap>();
	   Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	   String currencyFormat = props.getProperty("currencyFormat");
	   
	   String currencyCodeColName = getTransDateQualifier(new BigInteger(viewId.toString()), "CURRENCYCODE"); 
	   DataViews dv = dataViewsRepository.findOne(viewId);
	   
	   if(dv != null)
	   {
		   for(String transDate: transDates)
		   {
			   DateFormat df = new SimpleDateFormat("yyyy-MM-dd");
			   HashMap transDateMp = new HashMap();
			   Date date= df.parse(transDate);
			   df = new SimpleDateFormat("dd-MMM-yy");
			   transDateMp.put("name", df.format(date));
			   
			   List<BigInteger> totalOriginalIds = getOriginalIdsByTransDate(viewId, rangeFrom, rangeTo, qualifier, transDate, "DATE","fileDate");
			   List<BigInteger> unRecIds = new ArrayList<BigInteger>();
			   if(totalOriginalIds.size()>0)
			   {
				   List<BigInteger> recIds = new ArrayList<BigInteger>();
				/*   if(jobReference.length()>0)
	s			   {
					   recIds = reconciliationResultRepository.fetchReconciledIdswithJobReferenceForSource(tenantId, groupId, totalOriginalIds, jobReference);
				   }
				   else
				   {*/
					   recIds = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForTarget(tenantId, groupId, totalOriginalIds,viewId);
				   /*}*/

				   for(BigInteger id: totalOriginalIds)
				   {
					   if(!recIds.contains(id))
					   {
						   unRecIds.add(id);
					   }
				   }
				   
				   HashMap total = new HashMap();
				   HashMap recon = new HashMap();
				   HashMap unRecon = new HashMap();

				   String currencySymbolRec = "";
				   
				   List<String> currenciesRec = getDistColumnValues(recIds,currencyCodeColName,dv.getDataViewName());
				   if(currenciesRec.size()==1)
				   {
					   currencySymbolRec = currencySymbolRec+getCurrencySymbol(currenciesRec.get(0));
				   }
				   else if(currenciesRec.size()>1)
				   {
					   currencySymbolRec = currencySymbolRec+"*";
				   }
				   
				   String currencySymbolUnRec = "";
				   
				   List<String> currenciesUnRec = getDistColumnValues(unRecIds,currencyCodeColName,dv.getDataViewName());
				   if(currenciesUnRec.size()==1)
				   {
					   currencySymbolUnRec = currencySymbolUnRec+getCurrencySymbol(currenciesUnRec.get(0));
				   }
				   else if(currenciesUnRec.size()>1)
				   {
					   currencySymbolUnRec = currencySymbolUnRec+"*";
				   }
				   
				   String currencySymbolTot = "";
				   
				   List<String> currenciesTot = getDistColumnValues(totalOriginalIds,currencyCodeColName,dv.getDataViewName());
				   if(currenciesTot.size()==1)
				   {
					   currencySymbolTot = currencySymbolTot+getCurrencySymbol(currenciesTot.get(0));
				   }
				   else if(currenciesTot.size()>1)
				   {
					   currencySymbolTot = currencySymbolTot+"*";
				   }
				   
				   HashMap totalAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, amountQualifier,totalOriginalIds);

				   transDateMp.put("tAmount", currencySymbolTot + " " + reconciliationResultService.getAmountInFormat(totalAmountCount.get("totalAmount").toString(),currencyFormat));
				   transDateMp.put("tCount", totalAmountCount.get("totalCount"));
				   
				   HashMap recAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, amountQualifier,recIds);
				   
				   transDateMp.put("rAmount", currencySymbolRec + " " + reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
				   transDateMp.put("rCount", recAmountCount.get("totalCount"));
				   
				   HashMap unRecAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, amountQualifier,unRecIds);
				   transDateMp.put("uAmount", currencySymbolUnRec + " " + reconciliationResultService.getAmountInFormat(unRecAmountCount.get("totalAmount").toString(),currencyFormat));
				   transDateMp.put("uCount", unRecAmountCount.get("totalCount"));
			   }
			   finalList.add(transDateMp);
		   }
	   }
	  
	   log.info("Grouped by trans date size: "+finalList.size());
	   return finalList;
   }
   
   /**
    * Author: Shiva
    * Purpose: Fetching process grouped list
    * @throws ClassNotFoundException 
    * @throws SQLException 
 * @throws ParseException 
    * **/
   public List<HashMap> getGroupedProcessList(List<BigInteger> sourceIds, String rangeFrom, String rangeTo, Long tenantId, Long groupId, String jobReference) throws ClassNotFoundException, SQLException, ParseException
   {
	   log.info("Fetching grouped list for process tenant id: "+ tenantId+", group id: "+ groupId);
	   List<Long> ruleIds = ruleGroupDetailsRepository.fetchByRuleGroupIdAndTenantId(groupId, tenantId);
	   Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	   String currencyFormat = props.getProperty("currencyFormat");
	   List<HashMap> finalList = new ArrayList<HashMap>();
	   for(BigInteger viewId : sourceIds)
	   {
		   String qualifier = reconciliationResultService.getQualifier(viewId);
		   String currencyCodeColName = getTransDateQualifier(new BigInteger(viewId.toString()), "CURRENCYCODE"); 
		   if(qualifier.length()>0)
		   {
			   HashMap sourceMap = new HashMap();
			   String transDateColumn = reconciliationResultService.getTransDateQualifier(new BigInteger(viewId.toString()), "TRANSDATE");
			   List<BigInteger> totalOriginalIds = getViewOriginalIds(viewId.longValue(), rangeFrom, rangeTo,transDateColumn);
			   List<BigInteger> unRecIds = new ArrayList<BigInteger>();
			   if(totalOriginalIds.size()>0)
			   {
				   List<BigInteger> recIds = new ArrayList<BigInteger>();
				  /* if(jobReference.length()>0)
				   {
					   recIds = reconciliationResultRepository.fetchReconciledIdswithJobReferenceForSource(tenantId,groupId, totalOriginalIds, jobReference);
				   }
				   else
				   {*/
					   recIds = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForSource(tenantId,groupId, totalOriginalIds, viewId.longValue());
				   /*}*/
				   //log.info("totalids: "+ totalOriginalIds);
				   for(BigInteger id : totalOriginalIds)
				   {
					   if(!recIds.contains(id))
					   {
						   unRecIds.add(id);
					   }
				   }
				   HashMap total = new HashMap();
				   HashMap reconciled = new HashMap();
				   HashMap unReconciled = new HashMap();
				   DataViews dv = dataViewsRepository.findOne(viewId.longValue());
				   if(dv != null)
				   {
					   sourceMap.put("id", viewId);
					   sourceMap.put("name", dv.getDataViewDispName());
					   log.info("Reconciled: "+ recIds.size());
					   log.info("Un-Reconciled: "+ unRecIds.size());
					   log.info("Total: "+ totalOriginalIds.size());
					   String currencySymbolRec = "";
					   List<String> currenciesRec = getDistColumnValues(recIds,currencyCodeColName,dv.getDataViewName());
					   if(currenciesRec.size()==1)
					   {
						   currencySymbolRec = currencySymbolRec+getCurrencySymbol(currenciesRec.get(0));
					   }
					   else if(currenciesRec.size()>1)
					   {
						   currencySymbolRec = currencySymbolRec+"*";
					   }
					   String currencySymbolUnRec = "";
					   List<String> currenciesUnRec = getDistColumnValues(unRecIds,currencyCodeColName,dv.getDataViewName());
					   if(currenciesUnRec.size()==1)
					   {
						   currencySymbolUnRec = currencySymbolUnRec+getCurrencySymbol(currenciesUnRec.get(0));
					   }
					   else if(currenciesUnRec.size()>1)
					   {
						   currencySymbolUnRec = currencySymbolUnRec+"*";
					   }
					   String currencySymbolTot = "";
					   List<String> currenciesTot = getDistColumnValues(totalOriginalIds,currencyCodeColName,dv.getDataViewName());
					   if(currenciesTot.size()==1)
					   {
						   currencySymbolTot = currencySymbolTot+getCurrencySymbol(currenciesTot.get(0));
					   }
					   else if(currenciesTot.size()>1)
					   {
						   currencySymbolTot = currencySymbolTot+"*";
					   }
					   HashMap totalCountNAmount = reconciliationResultService.getCountNAmountForDVId(viewId, tenantId, qualifier,totalOriginalIds);

					   sourceMap.put("tAmount", currencySymbolTot + " " + reconciliationResultService.getAmountInFormat(totalCountNAmount.get("totalAmount").toString(),currencyFormat));
					   sourceMap.put("tCount", totalCountNAmount.get("totalCount"));
				//	   sourceMap.put("tdCount", totalOriginalIds.size());
					   HashMap reconCountNAmount = reconciliationResultService.getCountNAmountForDVId(viewId, tenantId, qualifier,recIds);

					   sourceMap.put("rAmount", currencySymbolRec + " " + reconciliationResultService.getAmountInFormat(reconCountNAmount.get("totalAmount").toString(),currencyFormat));
					   sourceMap.put("rCount", reconCountNAmount.get("totalCount"));
				//	   sourceMap.put("rdCount", recIds.size());
					   HashMap unRecCountNAmount = reconciliationResultService.getCountNAmountForDVId(viewId, tenantId, qualifier,unRecIds);

					   sourceMap.put("uAmount", currencySymbolUnRec + " " +reconciliationResultService.getAmountInFormat(unRecCountNAmount.get("totalAmount").toString(),currencyFormat));
					   sourceMap.put("uCount", unRecCountNAmount.get("totalCount"));
					   sourceMap.put("udCount", unRecIds.size());
					   finalList.add(sourceMap);
				   }
			   }
		   }
	   }
	   log.info("Final Process List: "+ finalList);
	   return finalList;
   }
   
   public List<HashMap> getGroupedProcessListForTarget(List<BigInteger> sourceIds, String rangeFrom, String rangeTo, Long tenantId, Long groupId, String jobReference) throws ClassNotFoundException, SQLException, ParseException
   {
	   log.info("Fetching grouped list for process tenant id: "+ tenantId+", group id: "+ groupId);
	   List<Long> ruleIds = ruleGroupDetailsRepository.fetchByRuleGroupIdAndTenantId(groupId, tenantId);
	   Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	   String currencyFormat = props.getProperty("currencyFormat");
	   List<HashMap> finalList = new ArrayList<HashMap>();
	   for(BigInteger viewId : sourceIds)
	   {
		   String qualifier = reconciliationResultService.getQualifier(viewId);
		   String currencyCodeColName = getTransDateQualifier(new BigInteger(viewId.toString()), "CURRENCYCODE"); 
		   if(qualifier.length()>0)
		   {
			   HashMap sourceMap = new HashMap();
			   String transDateColumn = reconciliationResultService.getTransDateQualifier(new BigInteger(viewId.toString()), "TRANSDATE");
			   List<BigInteger> totalOriginalIds = getViewOriginalIds(viewId.longValue(), rangeFrom, rangeTo,transDateColumn);
			   List<BigInteger> unRecIds = new ArrayList<BigInteger>();
			   if(totalOriginalIds.size()>0)
			   {
				   List<BigInteger> recIds = new ArrayList<BigInteger>();
				   recIds = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForTarget(tenantId,groupId, totalOriginalIds, viewId.longValue());
				   for(BigInteger id : totalOriginalIds)
				   {
					   if(!recIds.contains(id))
					   {
						   unRecIds.add(id);
					   }
				   }
				   HashMap total = new HashMap();
				   HashMap reconciled = new HashMap();
				   HashMap unReconciled = new HashMap();
				   DataViews dv = dataViewsRepository.findOne(viewId.longValue());
				   if(dv != null)
				   {
					   sourceMap.put("id", viewId);
					   sourceMap.put("name", dv.getDataViewDispName());
					   log.info("Reconciled: "+ recIds.size());
					   log.info("Un-Reconciled: "+ unRecIds.size());
					   log.info("Total: "+ totalOriginalIds.size());
					   String currencySymbolRec = "";
					   List<String> currenciesRec = getDistColumnValues(recIds,currencyCodeColName,dv.getDataViewName());
					   if(currenciesRec.size()==1)
					   {
						   currencySymbolRec = currencySymbolRec+getCurrencySymbol(currenciesRec.get(0));
					   }
					   else if(currenciesRec.size()>1)
					   {
						   currencySymbolRec = currencySymbolRec+"*";
					   }
					   String currencySymbolUnRec = "";
					   List<String> currenciesUnRec = getDistColumnValues(unRecIds,currencyCodeColName,dv.getDataViewName());
					   if(currenciesUnRec.size()==1)
					   {
						   currencySymbolUnRec = currencySymbolUnRec+getCurrencySymbol(currenciesUnRec.get(0));
					   }
					   else if(currenciesUnRec.size()>1)
					   {
						   currencySymbolUnRec = currencySymbolUnRec+"*";
					   }
					   String currencySymbolTot = "";
					   List<String> currenciesTot = getDistColumnValues(totalOriginalIds,currencyCodeColName,dv.getDataViewName());
					   if(currenciesTot.size()==1)
					   {
						   currencySymbolTot = currencySymbolTot+getCurrencySymbol(currenciesTot.get(0));
					   }
					   else if(currenciesTot.size()>1)
					   {
						   currencySymbolTot = currencySymbolTot+"*";
					   }
					   HashMap totalCountNAmount = reconciliationResultService.getCountNAmountForDVId(viewId, tenantId, qualifier,totalOriginalIds);

					   sourceMap.put("tAmount", currencySymbolTot + " " + reconciliationResultService.getAmountInFormat(totalCountNAmount.get("totalAmount").toString(),currencyFormat));
					   sourceMap.put("tCount", totalCountNAmount.get("totalCount"));
					   HashMap reconCountNAmount = reconciliationResultService.getCountNAmountForDVId(viewId, tenantId, qualifier,recIds);

					   sourceMap.put("rAmount", currencySymbolRec + " " + reconciliationResultService.getAmountInFormat(reconCountNAmount.get("totalAmount").toString(),currencyFormat));
					   sourceMap.put("rCount", reconCountNAmount.get("totalCount"));
					   HashMap unRecCountNAmount = reconciliationResultService.getCountNAmountForDVId(viewId, tenantId, qualifier,unRecIds);

					   sourceMap.put("uAmount", currencySymbolUnRec + " " +reconciliationResultService.getAmountInFormat(unRecCountNAmount.get("totalAmount").toString(),currencyFormat));
					   sourceMap.put("uCount", unRecCountNAmount.get("totalCount"));
					   finalList.add(sourceMap);
				   }
			   }
		   }
	   }
	   log.info("Final Process List: "+ finalList);
	   return finalList;
   }
   
   
   /* Getting Reconciled, Un-Reconciled Ids for Source*/
   public Map<String, List<BigInteger>> getSourceRecNUnRecIdsWithRange(Long dataViewId, Long tenantId, List<BigInteger> srcTotalIds, Long groupId) throws ClassNotFoundException{
	   	List<Long> ruleIds = rulesRepository.fetchIdsByViewId(dataViewId, tenantId);
	   	Map<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
	   	List<BigInteger> reconciledIds = new ArrayList<BigInteger>();
	   	List<BigInteger> sourceUnreconciledIds = new ArrayList<BigInteger>();
	   	if(ruleIds.size()>0)
	   	{
	   		reconciledIds = reconciliationResultRepository.fetchOriginalRowIdsByTenantIdAndRuleIdsAndSourceViewId(tenantId, ruleIds, dataViewId, groupId);
	   	}
	   	if(srcTotalIds.size()>0)
	   	{
				for(BigInteger id : srcTotalIds)
				{
					if(!reconciledIds.contains(id))
					{
						sourceUnreconciledIds.add(id);
					}
				}
	   	}
	   	finalMap.put("reconciled", reconciledIds);
	   	finalMap.put("unReconciled", sourceUnreconciledIds);
	   	log.info("Source View ID: "+dataViewId+", Total Size: "+srcTotalIds.size());
	   	log.info("Source View ID: "+dataViewId+", Reconciled Size: "+reconciledIds.size());
	   	log.info("Source View ID: "+dataViewId+", UnReconciled Size: "+sourceUnreconciledIds.size());
	   	return finalMap;
   }
   
   /* Getting Reconciled Map<String, List<Long>> and UnReconciled Id's for Source*/
   public Map<String, List<BigInteger>> getSourceRecNUnRecIdsByBatches(Long dataViewId, Long tenantId, List<BigInteger> srcTotalIds, Long groupId, List<String> batches) throws ClassNotFoundException{
	   	Map<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
	   	List<BigInteger> reconciledIds = new ArrayList<BigInteger>();
	   	List<BigInteger> unReconciled = new ArrayList<BigInteger>();
	   	if(srcTotalIds.size()>0)
	   	{
		   	if(batches.size()>0)
		   	{
		   		reconciledIds = reconciliationResultRepository.fetchReconciledIdswittBatchesForSource(tenantId, groupId, srcTotalIds, batches, dataViewId);
		   	}

	   		for(BigInteger id: srcTotalIds)
	   		{
	   			if(!reconciledIds.contains(id))
	   			{
	   				unReconciled.add(id);
	   			}
	   		}
	   	}
	   	finalMap.put("reconciled", reconciledIds);
	   	finalMap.put("unReconciled", unReconciled);
	   	log.info("Source View ID: "+dataViewId+", Reconciled Size: "+reconciledIds.size());
		return finalMap;
   }
   
   /* Getting Reconciled Map<String, List<Long>> and UnReconciled Id's for Source*/
   public Map<String, List<BigInteger>> getTargetRecNUnRecIdsByBatches(Long dataViewId, Long tenantId, List<BigInteger> srcTotalIds, Long groupId, List<String> batches) throws ClassNotFoundException{
	   	Map<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
	   	List<BigInteger> reconciledIds = new ArrayList<BigInteger>();
	   	if(batches.size()>0 && srcTotalIds.size()>0)
	   	{
	   		reconciledIds = reconciliationResultRepository.fetchReconciledIdswithBatchesForTarget(tenantId, groupId, srcTotalIds, batches);
	   	}
	   	finalMap.put("reconciled", reconciledIds);
	   	log.info("Source View ID: "+dataViewId+", Reconciled Size: "+reconciledIds.size());
			return finalMap;
   }
   
	public String getQualifierColName(Long columnId) throws ClassNotFoundException{
    	DataViewsColumns dvc = dataViewsColumnsRepository.findOne(columnId);
    	String qualifier = "";
    	if(dvc != null)
    	{
			if("File Template".equalsIgnoreCase(dvc.getRefDvType()))
			{
	    		FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dvc.getRefDvColumn()));
	    		if(ftl != null)
	    		{
	    			qualifier = ftl.getColumnAlias();
	    		}
			}
			else if("Data View".equalsIgnoreCase(dvc.getRefDvType()) || dvc.getRefDvType() == null)
			{
				qualifier = dvc.getColumnName();
			}
    	}
    	else
    	{
    		log.info("There is no Qualifier column found for the column id: "+ columnId);
    	}
    	return qualifier;
	}

	
   public List<BigInteger> fetchTargetIds(Long sViewId, Long tViewId, List<Long> rowIds, FormConfig formConf) throws SQLException, ClassNotFoundException, ParseException
   {
	   log.info("Fetching custo filter target row ids...");
		String dateRange = "";
		String dateOperator = "";
		String amountOperator = "";
		
		if(formConf != null)
		{
			String jsonStr = formConf.getValue();
			JSONParser parser = new JSONParser();
			JSONArray json = (JSONArray) parser.parse(jsonStr);
			Iterator i = json.iterator();
			while (i.hasNext()) {
				JSONObject slide = (JSONObject) i.next();
				String parameter = (String)slide.get("parameter");
				if(parameter.equalsIgnoreCase("TRANSDATE"))
				{
					dateRange = dateRange + slide.get("value");
					dateOperator = dateOperator + slide.get("operator");
					//dateSId = dateSId + Long.parseLong(slide.get("sColId").toString());
					//dateTId = dateTId + Long.parseLong(slide.get("tColId").toString());
				}
				else if(parameter.equalsIgnoreCase("AMOUNT"))
				{
					//amountSId = amountSId + Long.parseLong(slide.get("sColId").toString());
					//amountTId = amountTId + Long.parseLong(slide.get("tColId").toString());
					amountOperator = amountOperator+slide.get("operator");
				}
				else if(parameter.equalsIgnoreCase("CURRENCYCODE"))
				{
					//currencySId = currencySId + Long.parseLong(slide.get("sColId").toString());
					//currencyTId = currencyTId + Long.parseLong(slide.get("tColId").toString());
				}
				/*else if(parameter.equalsIgnoreCase("KEY COMPONENT"))
				{
					kcSId = kcSId + Long.parseLong(slide.get("sColId").toString());
					kcTId = kcTId + Long.parseLong(slide.get("tColId").toString());
				}*/
		    }
		}
		log.info("Date Operator: "+dateOperator+", Date Range: "+dateRange+", Amount Operator: "+ amountOperator);
	   
	   List<BigInteger> targetRowIds = new ArrayList<BigInteger>();
	   List<BigInteger> finalTargetRowIds = new ArrayList<BigInteger>();
	   
	   String[] dateRangeArray = dateRange.split("\\,");
	   int dateBack = Integer.parseInt(dateRangeArray[0]);
	   int dateForward = Integer.parseInt(dateRangeArray[1]);
	   
	   // Converting original row ids list as string
	   String rowIdsAsString = rowIds.toString();
	   rowIdsAsString = rowIdsAsString.replace("[", "");
	   rowIdsAsString = rowIdsAsString.replace("]", "");
	   
	   Connection conn = null;
	   Statement stmt = null;
	   ResultSet currencyRS = null;
	   ResultSet providerRS = null;
	   ResultSet amountRS = null;
	   ResultSet dateRS = null;
	   ResultSet firstFilterRS = null;
	   ResultSet totalSumRS = null;
	   try{
		   DataViews sourceView = dataViewsRepository.findOne(sViewId.longValue());
		   DataViews targetView = dataViewsRepository.findOne(tViewId.longValue());
		   if(sourceView != null && targetView != null)
		   {
			   String dbUrl=env.getProperty("spring.datasource.url");
			   String[] parts=dbUrl.split("[\\s@&?$+-]+");
			   String host = parts[0].split("/")[2].split(":")[0];
			   String schemaName=parts[0].split("/")[3];
			   String userName = env.getProperty("spring.datasource.username");
			   String password = env.getProperty("spring.datasource.password");
			   String jdbcDriver = env.getProperty("spring.datasource.jdbcdriver");
	   		
			   Class.forName(jdbcDriver);
	    	   conn = DriverManager.getConnection(dbUrl, userName, password);
	    	   stmt = conn.createStatement();
	    	   
	    	   DataViewsColumns amountDVCSource = dataViewsColumnsRepository.findByDataViewIdAndQualifier(sViewId, "AMOUNT");
	    	   DataViewsColumns currencyDVCSource = dataViewsColumnsRepository.findByDataViewIdAndQualifier(sViewId, "CURRENCYCODE");
	    	   DataViewsColumns proDVCSource = dataViewsColumnsRepository.findByDataViewIdAndQualifier(sViewId, "GROUPBY_COLUMN");
	    	   DataViewsColumns trnsDtDVCSource = dataViewsColumnsRepository.findByDataViewIdAndQualifier(sViewId, "TRANSDATE");
	    	   
	    	   DataViewsColumns amountDVCTarget = dataViewsColumnsRepository.findByDataViewIdAndQualifier(tViewId, "AMOUNT");
	    	   DataViewsColumns currencyDVCTarget = dataViewsColumnsRepository.findByDataViewIdAndQualifier(tViewId, "CURRENCYCODE");
	    	   DataViewsColumns proDVCTarget = dataViewsColumnsRepository.findByDataViewIdAndQualifier(tViewId, "GROUPBY_COLUMN");
	    	   DataViewsColumns trnsDtDVCTarget = dataViewsColumnsRepository.findByDataViewIdAndQualifier(tViewId, "TRANSDATE");
	    	   
	    	   String currencyProviderDateQuery = "";
	    	   // Building query for Currenc Code
	    	   String whereString = "";
	    	   if(currencyDVCSource != null && currencyDVCTarget != null)
	    	   {
	    		   List<String> currencyCodes = new ArrayList<String>();
	    		   String sColName = getQualifierColName(currencyDVCSource.getId());
	    		   String tColName = getQualifierColName(currencyDVCTarget.getId());
	    		   if(sColName.length()>0 && tColName.length()>0)
	    		   {
	    			   String currencyCode = " AND " + tColName + " IN (";
	    			   currencyRS = stmt.executeQuery("select distinct(`" + sColName + "`) from "+schemaName+".`"+sourceView.getDataViewName().toLowerCase() + "` where scrIds in ("+rowIdsAsString+")");
	    			   while(currencyRS.next()){
	    				   currencyCodes.add(currencyRS.getString(1));
	    			   }
	    			   if(currencyCodes.size()>0)
	    			   {
	    				   for(int i=0; i<currencyCodes.size(); i++)
	    				   {
	    					   if(i == currencyCodes.size()-1)
	    					   {
	    						   currencyCode = currencyCode + "'"+currencyCodes.get(i).trim()+"')";
	    					   }
	    					   else
	    					   {
	    						   currencyCode = currencyCode + "'"+currencyCodes.get(i).trim()+"',";
	    					   }
	    				   }
	    			   }
	    			  // log.info("Currency Code Query: "+currencyCode);
	    			   whereString = whereString + currencyCode;
	    		   }
	    	   }
	    	   // Building query for provider name
	    	   if(proDVCSource != null && proDVCTarget != null)
	    	   {
	    		   List<String> providerNames = new ArrayList<String>();
	    		   String sProviderName = getQualifierColName(proDVCSource.getId());
	    		   String tProviderName = getQualifierColName(proDVCTarget.getId());
	    		   if(sProviderName.length()>0 && tProviderName.length()>0)
	    		   {
	    			   String providerName = " AND " + tProviderName + " IN (";
	    			   providerRS = stmt.executeQuery("select distinct(`" + sProviderName + "`) from "+schemaName+".`"+sourceView.getDataViewName().toLowerCase() + "` where scrIds in ("+rowIdsAsString+")");
	    			   while(providerRS.next()){
	    				   providerNames.add(providerRS.getString(1));
	    			   }
	    			   if(providerNames.size()>0)
	    			   {
	    				   for(int i=0; i<providerNames.size(); i++)
	    				   {
	    					   if(i == providerNames.size()-1)
	    					   {
	    						   providerName = providerName + "'"+providerNames.get(i).trim()+"')";
	    					   }
	    					   else
	    					   {
	    						   providerName = providerName + "'"+providerNames.get(i).trim()+"',";
	    					   }
	    				   }
	    			   }
	    			   //log.info("Provider Name Query: "+ providerName);
	    			   whereString = whereString + providerName;
	    		   }
	    	   }
	    	   // Building query for trans date
	    	   if(trnsDtDVCSource != null && trnsDtDVCTarget != null)
	    	   {
	    		   List<String> transDates = new ArrayList<String>();
	    		   String sDateName = getQualifierColName(trnsDtDVCSource.getId());
	    		   String tDateName = getQualifierColName(trnsDtDVCTarget.getId());
	    		   if(sDateName.length()>0 && tDateName.length()>0)
	    		   {
	    			   dateRS = stmt.executeQuery("select distinct(`" + sDateName + "`) from "+schemaName+".`"+sourceView.getDataViewName().toLowerCase() + "` where scrIds in ("+rowIdsAsString+")");
	    			   while(dateRS.next()){
	    				   transDates.add(dateRS.getString(1));
	    			   }
	    			   log.info("Distinct Trans Date: "+transDates);
	    			   String dateQuery = "";
	    			   if(transDates.size()>0)//dateOperator
	    			   {
	    				   for(int i=0; i<transDates.size(); i++)
	    				   {
	    					   String date = transDates.get(i).toString().trim();
	    					   LocalDate localDate = LocalDate.parse(date.trim());
	    					   LocalDate dateMinus = localDate.plusDays(dateBack);
	    					   LocalDate datePlus = localDate.plusDays(dateForward);
/*	    					   LocalDate dateMinus = localDate.plusDays(-5);
	    					   LocalDate datePlus = localDate.plusDays(10);*/
	    					   if(i == transDates.size()-1)
	    					   {
	    						   /*dateQuery = dateQuery +"("+ tDateName +" BETWEEN '"+dateMinus+"' AND '"+datePlus+"')";*/
	    						   dateQuery = dateQuery +"("+ tDateName +" "+dateOperator+" '"+dateMinus+"' AND '"+datePlus+"')";
	    					   }
	    					   else
	    					   {
	    						   /*dateQuery = dateQuery +"("+ tDateName +" BETWEEN '"+dateMinus+"' AND '"+datePlus+"') OR ";*/
	    						   dateQuery = dateQuery +"("+ tDateName +" "+dateOperator+" '"+dateMinus+"' AND '"+datePlus+"') OR ";
	    					   }
	    				   }
	    				   dateQuery = " AND ("+dateQuery+")";
	    			   }
	    			   whereString = whereString + dateQuery;
	    		   }
	    	   }
	    	   log.info("FinalWhereString: "+ whereString);
	    	   if(whereString.length()>0)
	    	   {
	    		   if(amountDVCSource != null && amountDVCTarget != null)
	    		   {
		    		   String sAmountQualifier = getQualifierColName(amountDVCSource.getId());
		    		   String tAmountQualifier = getQualifierColName(amountDVCTarget.getId());
	    			   if(sAmountQualifier.length()>0 && tAmountQualifier.length()>0)
	    			   {
	    				   Double totalAmount = 0.0;
			    		   firstFilterRS = stmt.executeQuery("select distinct(scrIds) from "+schemaName+".`"+targetView.getDataViewName().toLowerCase() + "` where 1=1 "+whereString);
		        		   while(firstFilterRS.next()){
		        			   targetRowIds.add(new BigInteger(firstFilterRS.getString(1)));
		        		   }
			    		   totalSumRS = stmt.executeQuery("select SUM(`"+ sAmountQualifier +"`) from "+schemaName+".`"+sourceView.getDataViewName().toLowerCase() + "` where scrIds in ("+rowIdsAsString+")");
		        		   while(totalSumRS.next()){
		        			   totalAmount = totalAmount + Double.parseDouble(totalSumRS.getString(1));
		        		   }
		        		  // log.info("Target Row Ids Before Amount: "+ targetRowIds);
		        		   if(targetRowIds.size()>0)
		        		   {
		        			   for(BigInteger id : targetRowIds)
		        			   {
		        				   Double amount = 0.0;
		        				   ResultSet rs = stmt.executeQuery("SELECT `"+tAmountQualifier+"` from "+schemaName+".`"+targetView.getDataViewName().toLowerCase() + "` where scrIds = "+id);
		        				   while(rs.next())
		        				   {
		        					   amount = amount + Double.parseDouble(rs.getString(1));
		        				   }
		        				   if(amount <= totalAmount)
		        				   {
		        					   finalTargetRowIds.add(id);
		        				   }
		        				   rs.close();
		        			   }
		        		   }
	    			   }
	    		   }
	    	   }
		   }
	   }
	   catch(SQLException se){
		   log.info("Error while executing query: "+se);
       }
	   finally{
	   		if(providerRS != null)
	   			providerRS.close();
	   		if(currencyRS != null)
	   			currencyRS.close();
	   		if(amountRS != null)
	   			amountRS.close();
	   		if(firstFilterRS != null)
	   			firstFilterRS.close();
	   		if(totalSumRS != null)
	   			totalSumRS.close();
	   		if(stmt != null)
	   			stmt.close();
			if(conn != null)
				conn.close();
			}
	   log.info("Final Total Target Ids: "+ finalTargetRowIds);
	   return finalTargetRowIds;
   }
   //*********************************************************************//
   //Fetching reconciled UnReconciled Ids within range for Source
   public Map<String, List<BigInteger>> getRecUnRecWithRangeSource(List<BigInteger> totalIds, String jobReference, Long tenantId, Long groupId, Long dataViewId){
	   log.info("Fetching reconciled, un-reconciled...");
	   	Map<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
	   	List<BigInteger> reconciled = new ArrayList<BigInteger>();
	   	List<BigInteger> unReconciled = new ArrayList<BigInteger>();
	   	if(totalIds.size()>0)
	   	{
	   		log.info("Without Job Reference");
	   		reconciled = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForSource(tenantId, groupId, totalIds,dataViewId);

	   		for(BigInteger id: totalIds)
	   		{
	   			if(!reconciled.contains(id))
	   			{
	   				unReconciled.add(id);
	   			}
	   		}
	   	}
	   	finalMap.put("reconciled", reconciled);
	   	finalMap.put("unReconciled", unReconciled);
	   	finalMap.put("totalIds", totalIds);
	   	log.info("Reconciled: "+ reconciled.size()+", UnReconciled: "+ unReconciled.size()+", Total: "+totalIds.size());
	   	return finalMap;
  }

   //Fetching reconciled UnReconciled Ids within range for Source
   public Map<String, List<BigInteger>> getRecUnRecGroupByColumnValuesForSource(Long viewId, Long columnId, String rangeFrom, String rangeTo, List<String> colValues, String jobReference, Long tenantId, Long groupId, String periodFactor, String typeOfRecData) throws SQLException{
	   	log.info("Fetching reconciled, un-reconciled group by column name for source...");
	   	List<BigInteger> totalIds = getTotalIdsGroupByColumnValues(columnId, viewId, rangeFrom, rangeTo, colValues, periodFactor);	   	
	   	Map<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
	   	List<BigInteger> reconciled = new ArrayList<BigInteger>();
	   	List<BigInteger> unReconciled = new ArrayList<BigInteger>();
		List<BigInteger> suggestedIds = new ArrayList<BigInteger>();
	   	if(totalIds.size()>0)
	   	{
	   		log.info("Without Job Reference");
	   		if("suggestion".equalsIgnoreCase(typeOfRecData))
	   		{
	   			reconciled = reconciliationDuplicateResultRepository.fetchReconciledIdswithStatusUnreconciledForSource(tenantId, groupId, totalIds, viewId);
	   			suggestedIds.addAll(reconciled);
	   		}
	   		else
	   		{
	   			reconciled = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForSource(tenantId, groupId, totalIds, viewId);
	   		}
	   		for(BigInteger id: totalIds)
	   		{
	   			if(!reconciled.contains(id))
	   			{
	   				unReconciled.add(id);
	   			}
	   		}
	   		unReconciled.removeAll(suggestedIds);
	   	}
	   	finalMap.put("reconciled", reconciled);
	   	finalMap.put("unReconciled", unReconciled);
	   	finalMap.put("totalIds", totalIds);
	   	log.info("Reconciled: "+ reconciled.size()+", UnReconciled: "+ unReconciled.size()+", Total: "+totalIds.size());
	   	return finalMap;
  }
   
   public Map<String, List<BigInteger>> getRecUnRecGroupByColumnValuesForTarget(Long viewId, Long columnId, String rangeFrom, String rangeTo, List<String> colValues, String jobReference, Long tenantId, Long groupId, String typeOfRecData) throws SQLException, ClassNotFoundException{
	   	log.info("Fetching reconciled, un-reconciled group by column name for source...");
	   	List<BigInteger> totalIds = new ArrayList<BigInteger>();
	    HashMap stotalIdsMap = getTotalByPeriodFactor(viewId, "fileDate", rangeFrom, rangeTo);
	   	Map<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
	   	List<BigInteger> reconciled = new ArrayList<BigInteger>();
	   	List<BigInteger> unReconciled = new ArrayList<BigInteger>();
	   	List<BigInteger> suggestedIds = new ArrayList<BigInteger>();
	    if("Success".equalsIgnoreCase(stotalIdsMap.get("status").toString()))
		{
	    	totalIds = (List<BigInteger>) stotalIdsMap.get("totalIds");
		}
	   	if(totalIds.size()>0)
	   	{
		   	log.info("Without Job Reference");
		   	if("suggestion".equalsIgnoreCase(typeOfRecData))
		   	{
		   		reconciled = reconciliationDuplicateResultRepository.fetchReconciledIdswithStatusUnreconciledForTarget(tenantId, groupId, totalIds, viewId);
		   		suggestedIds.addAll(reconciled);
		   	}
		   	else
		   	{
		   		reconciled = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForTarget(tenantId, groupId, totalIds, viewId);	
		   	}
		   	
	   		for(BigInteger id: totalIds)
	   		{
	   			if(!reconciled.contains(id))
	   			{
	   				unReconciled.add(id);
	   			}
	   		}
	   		unReconciled.removeAll(suggestedIds);
	   	}
	   	finalMap.put("reconciled", reconciled);
	   	finalMap.put("unReconciled", unReconciled);
	   	finalMap.put("totalIds", totalIds);
	   	log.info("Reconciled: "+ reconciled.size()+", UnReconciled: "+ unReconciled.size()+", Total: "+totalIds.size());
	   	return finalMap;
 }
 
   //Fetching reconciled UnReconciled Ids within range for Target
   public Map<String, List<BigInteger>> getRecUnRecWithRangeTarget(List<BigInteger> totalIds, String jobReference, Long tenantId, Long groupId, Long viewId){
	   log.info("Fetching reconciled, un-reconciled for the view id...");
	   	Map<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
	   	List<BigInteger> reconciled = new ArrayList<BigInteger>();
	   	List<BigInteger> unReconciled = new ArrayList<BigInteger>();
	   	if(totalIds.size()>0)
	   	{
		   /*	if(jobReference.length()>0)
		   	{
		   		log.info("With Job Reference");
		   		reconciled = reconciliationResultRepository.fetchReconciledIdswithJobReferenceForTarget(tenantId, groupId, totalIds, jobReference);
		   	}
		   	else
		   	{*/
		   		log.info("Without Job Reference");
		   		reconciled = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForTarget(tenantId, groupId, totalIds,viewId);
		   	/*}*/
	   		for(BigInteger id: totalIds)
	   		{
	   			if(!reconciled.contains(id))
	   			{
	   				unReconciled.add(id);
	   			}
	   		}
	   	}
	   	finalMap.put("reconciled", reconciled);
	   	finalMap.put("unReconciled", unReconciled);
	   	finalMap.put("totalIds", totalIds);
	   	log.info("Reconciled: "+ reconciled.size()+", UnReconciled: "+ unReconciled.size()+", Total: "+totalIds.size());
	   	return finalMap;
  }
   
   //Fetching reconciled UnReconciled Ids within range for Target
   public Map<String, List<BigInteger>> getRecUnRecWithRangeTargetData(List<BigInteger> totalIds, List<String> jobReference, Long tenantId, Long groupId, Long dataViewId){
	   log.info("Fetching reconciled, un-reconciled for the view id...");
	   	Map<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
	   	List<BigInteger> reconciled = new ArrayList<BigInteger>();
	   	List<BigInteger> unReconciled = new ArrayList<BigInteger>();
	   	if(totalIds.size()>0)
	   	{
		   	/*if(jobReference.size()>0)
		   	{
		   		reconciled =reconciliationResultRepository.fetchReconciledIdswithBatchesForTarget(tenantId,groupId,totalIds,jobReference);
		   	}
		   	else
		   	{*/
		   		reconciled =reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForTarget(tenantId,groupId,totalIds,dataViewId);
		   	/*}*/
	   		for(BigInteger id: totalIds)
	   		{
	   			if(!reconciled.contains(id))
	   			{
	   				unReconciled.add(id);
	   			}
	   		}
	   	}
	   	finalMap.put("reconciled", reconciled);
	   	finalMap.put("unReconciled", unReconciled);
	   	finalMap.put("totalIds", totalIds);
	   	log.info("Reconciled: "+ reconciled.size()+", UnReconciled: "+ unReconciled.size()+", Total: "+totalIds.size());
	   	return finalMap;
  }

   /* Getting Reconciled Map<String, List<Long>> and UnReconciled Id's for Source*/
   public Map<String, List<BigInteger>> getSourceRecNUnRecIdsByRules(Long dataViewId, Long tenantId, List<BigInteger> srcTotalIds, Long groupId, List<Long> ruleIds) throws ClassNotFoundException{
   	Map<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
	List<BigInteger> reconciledIds = new ArrayList<BigInteger>();
	List<BigInteger> unReconciledIds = new ArrayList<BigInteger>();
   	if(srcTotalIds.size()>0)
   	{
   	   	if(ruleIds.size()>0)
   	   	{
   	   	  	reconciledIds = reconciliationResultRepository.fetchReconciledIdsWithOutJobRefWithStatusReconciledForSource(tenantId,ruleIds,groupId, srcTotalIds, dataViewId);
   	   	}
   	   	for(BigInteger id : srcTotalIds)
   	   	{
   	   		if(!reconciledIds.contains(id))
   	   		{
   	   			unReconciledIds.add(id);
   	   		}
   	   	}
   	}
	finalMap.put("reconciled", reconciledIds);
	finalMap.put("unReconciled", unReconciledIds);
	log.info("Source View ID: "+dataViewId+", Reconciled Size: "+reconciledIds.size());
   	return finalMap;
   }
   
   
   public Map<String, List<BigInteger>> getTargetRecNUnRecIdsByRules(Long dataViewId, Long tenantId, List<BigInteger> srcTotalIds, Long groupId, List<Long> ruleIds, String jobReference) throws ClassNotFoundException{
	   	Map<String, List<BigInteger>> finalMap = new HashMap<String, List<BigInteger>>();
	   	List<BigInteger> reconciledIds = new ArrayList<BigInteger>();
	   	List<BigInteger> unReconIds = new ArrayList<BigInteger>();
	   	if(srcTotalIds.size()>0)
	   	{
		   	if(ruleIds.size()>0)
		   	{
			   reconciledIds = reconciliationResultRepository.fetchReconciledIdsWithOutJobRefWithStatusReconciledForTarget(tenantId, ruleIds, groupId, srcTotalIds,dataViewId);
		   	}

		   	for(BigInteger id : srcTotalIds)
		   	{
		   		if(!reconciledIds.contains(id))
		   		{
		   			unReconIds.add(id);
		   		}
		   	}
	   	}
	   	finalMap.put("reconciled", reconciledIds);
	   	finalMap.put("unReconciled", unReconIds);
		finalMap.put("totalIds", srcTotalIds);
	   	log.info("Target View ID: "+dataViewId+", Reconciled Size: "+reconciledIds.size());
	   	return finalMap;
	   }
   
   public HashMap getCountAndAmountRecordWise(Long viewId, List<Long> rowIds, String amountQualifier) throws SQLException
   {
	   log.info("Fetching count and amounts based on view and rowids...");
	   HashMap finalMap = new HashMap();
		   	String idsString = rowIds.toString();
		   	idsString=idsString.replace("[", "");
		   	idsString=idsString.replace("]", "");
		   Connection conn = null;
		   Statement stmt = null;
		   ResultSet result = null; 
		   
	    	Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	    	String currencyFormat = props.getProperty("currencyFormat");
		   
		   try{
			   String dbUrl=env.getProperty("spring.datasource.url");
			   String[] parts=dbUrl.split("[\\s@&?$+-]+");
			   String host = parts[0].split("/")[2].split(":")[0];
			   String schemaName=parts[0].split("/")[3];
			   String userName = env.getProperty("spring.datasource.username");
			   String password = env.getProperty("spring.datasource.password");
			   String jdbcDriver = env.getProperty("spring.datasource.jdbcdriver");  
	   		
			   Class.forName(jdbcDriver);
	    	   conn = DriverManager.getConnection(dbUrl, userName, password);
	    	   stmt = conn.createStatement();
	     	   DataViews dv=dataViewsRepository.findOne(viewId.longValue());
	     	   String amount = "";
	     	   if(dv!= null)
	     	   {
	     		   String viewName = dv.getDataViewName();
	     		   log.info("Query: select sum(`"+amountQualifier+"`) from "+schemaName+".`"+viewName.toLowerCase()+"` where scrIds in ("+idsString+")");
	        	   result=stmt.executeQuery("select sum(`"+amountQualifier+"`) from "+schemaName+".`"+viewName.toLowerCase()+"` where scrIds in ("+idsString+")");
	        	   while(result.next()){
	        		   amount = amount+result.getString(1);
	        	   }  
	     	   }
	     	   else
	     	   {
	     		   log.info("View doen't not exist for the view id: "+viewId);
	     	   }
	     	 // String amountInCurrency = reconciliationResultService.getAmountInFormat(amount.replace(",", ""),currencyFormat);
	     	  Double amountDouble = Double.parseDouble(amount);
	     	  finalMap.put("amount", amountDouble);
	     	  finalMap.put("amountQualifier", amountQualifier);
	     	  finalMap.put("count", rowIds.size());
		   }
		   catch(SQLException se){
			   log.info("Error while executing query: "+se);
	       }
		   catch(Exception e)
		   {
			   log.info("Exception while getting databse properties");
		   }
		   finally{
		   		if(result != null)
		   			result.close();	
		   		if(stmt != null)
		   			stmt.close();
				if(conn != null)
					conn.close();
				}

	   return finalMap;
   }
   
   public String getDataViewColumnName(Long columnId)
   {
	   log.info("Fetching columnName based on column id: "+ columnId);
	   String columnName = "";
	   DataViewsColumns dvc = dataViewsColumnsRepository.findOne(columnId);
	   if(dvc != null)
	   {
			if("File Template".equalsIgnoreCase(dvc.getRefDvType()))
			{
				FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dvc.getRefDvColumn().toString()));
				if(ftl != null)
				{
					columnName = columnName+ftl.getColumnAlias();
				}
			}
			else if("Data View".equalsIgnoreCase(dvc.getRefDvType()) || dvc.getRefDvType() == null)
			{
				columnName = columnName+dvc.getColumnName();
			}
	   }
	   return columnName;
   }

  public List<BigInteger> fetchTotalIdsByColmnNameNColValues(Long viewId, String dataViewColName, String rangeFrom, String rangeTo, List<String> colValues, Long colId) throws SQLException
  {
	 log.info("Fetching total ids based on column name and column values within range...");
	 List<BigInteger> totalIds = new ArrayList<BigInteger>();
	 HashMap columnMap = accountingDataService.getDataViewColumnNameByColumnId(colId);
	 String dataType = "";
	 if(columnMap.get("columnName").toString().length()>0 && columnMap.get("dataType") != null)
	 {
		 dataType = dataType + columnMap.get("dataType");
	 }
 	   String dateString = colValues.toString();
 	   String inValues = "";
	 if("DATE".equalsIgnoreCase(dataType))
	 {
   	   dateString = dateString.replace("[", "");
   	   dateString = dateString.replace("]", "");
   	   dateString = dateString.replace(",","|");
   	   dateString = dateString.replace(" ", "");
	 }
	 else if("STRING".equalsIgnoreCase(dataType) || "VARCHAR".equalsIgnoreCase(dataType))
	 {
		  for(int i=0; i<colValues.size(); i++)
		  {
			  if(i==colValues.size()-1)
			  {
				  inValues = inValues + "'"+colValues.get(i).trim()+"'";
			  }
			  else
			  {
				  inValues = inValues + "'"+colValues.get(i).trim()+"',";
			  }
		  }
	 }
	 else if("INTEGER".equalsIgnoreCase(dataType) || "DECIMAL".equalsIgnoreCase(dataType))
	 {
		  for(int i=0; i<colValues.size(); i++)
		  {
			  if(i==colValues.size()-1)
			  {
				  inValues = inValues +colValues.get(i).trim();
			  }
			  else
			  {
				  inValues = inValues +colValues.get(i).trim()+",";
			  }
		  }
	 }

	 Connection conn = null;
	 Statement stmt = null;
	 ResultSet result = null; 
	 try{
		   String dbUrl=env.getProperty("spring.datasource.url");
		   String[] parts=dbUrl.split("[\\s@&?$+-]+");
		   String host = parts[0].split("/")[2].split(":")[0];
		   String schemaName=parts[0].split("/")[3];
		   String userName = env.getProperty("spring.datasource.username");
		   String password = env.getProperty("spring.datasource.password");
		   String jdbcDriver = env.getProperty("spring.datasource.jdbcdriver");  
		   Class.forName(jdbcDriver);
		   conn = DriverManager.getConnection(dbUrl, userName, password);
		   stmt = conn.createStatement();
    	   DataViews dv=dataViewsRepository.findOne(viewId.longValue());
    	   String amount = "";
    	   if(dv!= null)
    	   {
    		   String viewName = dv.getDataViewName();
    		   if("DATE".equalsIgnoreCase(dataType))
    		   {
    			   log.info("SELECT scrIds FROM "+schemaName+".`"+viewName.toLowerCase()+"` where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' AND `"+dataViewColName+"` REGEXP '"+dateString+"'");
    			   result=stmt.executeQuery("SELECT scrIds FROM "+schemaName+"."+viewName.toLowerCase()+" where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' AND `"+dataViewColName+"` REGEXP '"+dateString+"'");
    		   }
    		   else{
    			   log.info("select scrIds from "+schemaName+".`"+viewName.toLowerCase()+"` where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' AND `"+dataViewColName+"` IN ("+inValues+")");
    	       	   result=stmt.executeQuery("select scrIds from "+schemaName+"."+viewName.toLowerCase()+" where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' AND `"+dataViewColName+"` IN ("+inValues+")");
    		   }
 	       	   while(result.next()){
	       		   totalIds.add(new BigInteger(result.getString(1)));
	       	   }  
    	   }
    	   else
    	   {
    		   log.info("View doen't not exist for the view id: "+viewId);
    	   }
	   }
	   catch(SQLException se){
		   log.info("Error while executing query: "+se);
      }
	   catch(Exception e)
	   {
		   log.info("Exception while getting databse properties");
	   }
	   finally{
	   		if(result != null)
	   			result.close();	
	   		if(stmt != null)
	   			stmt.close();
			if(conn != null)
				conn.close();
			}
	 
	 return totalIds;
  }
  
  public List<BigInteger> getTargetIdsGroupByColumnValues(Long columnId, Long viewId, List<String> colValues) throws SQLException
  {
	  log.info("Fetching recon unreconciled ids for source group by columna name...");
	  List<BigInteger> totalIds = new ArrayList<BigInteger>();
	  
	  DataViewsColumns dvc = dataViewsColumnsRepository.findOne(columnId);
	  String columnName = "";
	  String dataType = "";
	  if(dvc != null)
	  {
		  if("VARCHAR".equals(dvc.getColDataType()) || "string".equals(dvc.getColDataType()))
		  {
			  dataType = dataType+"string";
		  }
		  else if("INTEGER".equalsIgnoreCase(dvc.getColDataType()) || "DECIMAL".equalsIgnoreCase(dvc.getColDataType()))
		  {
			  dataType = dataType+"integer";
		  }
		  else if("DATE".equalsIgnoreCase(dvc.getColDataType()))
		  {
			  dataType = dataType+"date";
		  }
		  if("File Template".equalsIgnoreCase(dvc.getRefDvType()))
		  {
				FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dvc.getRefDvColumn().toString()));
				if(ftl != null)
				{
					columnName = columnName + ftl.getColumnAlias();
				}
		  }
		  else if("Data View".equalsIgnoreCase(dvc.getRefDvType()) || dvc.getRefDvType() == null)
		  {
			columnName = columnName + dvc.getColumnName();
		  }
		  String colValStr = "";
		  if("string".equalsIgnoreCase(dataType))
		  {
			  if(colValues.size()>0)
			  {
				  for(int i=0; i<colValues.size(); i++)
				  {
					  if(i==colValues.size()-1)
					  {
						  colValStr = colValStr + "'"+colValues.get(i).trim()+"'";
					  }
					  else
					  {
						  colValStr = colValStr + "'"+colValues.get(i).trim()+"',";
					  }
				  }
			  }
		  }
		  else if("integer".equalsIgnoreCase(dataType))
		  {
			  if(colValues.size()>0)
			  {
				  for(int i=0; i<colValues.size(); i++)
				  {
					  if(i==colValues.size()-1)
					  {
						  colValStr = colValStr +colValues.get(i).trim();
					  }
					  else
					  {
						  colValStr = colValStr +colValues.get(i).trim()+",";
					  }
				  }
			  }
		  }
		  else if("DATE".equalsIgnoreCase(dataType))
		  {
			  	colValStr = colValues.toString();
			  	colValStr = colValStr.replace("[", "");
			  	colValStr = colValStr.replace("]", "");
			  	colValStr = colValStr.replace(",","|");
			  	colValStr = colValStr.replace(" ", "");
		  }
		  Connection conn = null;
		  Statement stmt = null;
		  ResultSet result = null; 
		  try{
			   String dbUrl=env.getProperty("spring.datasource.url");
			   String[] parts=dbUrl.split("[\\s@&?$+-]+");
			   String host = parts[0].split("/")[2].split(":")[0];
			   String schemaName=parts[0].split("/")[3];
			   String userName = env.getProperty("spring.datasource.username");
			   String password = env.getProperty("spring.datasource.password");
			   String jdbcDriver = env.getProperty("spring.datasource.jdbcdriver");  	  		
			   Class.forName(jdbcDriver);
			   conn = DriverManager.getConnection(dbUrl, userName, password);
			   stmt = conn.createStatement();
			   DataViews dv=dataViewsRepository.findOne(viewId.longValue());
			   if(dv!= null)
			   {
				   String viewName = dv.getDataViewName();
				   if("DATE".equalsIgnoreCase(dataType))
				   {
					   log.info("SELECT scrIds FROM "+schemaName+".`"+viewName.toLowerCase()+"` where `"+columnName+"` REGEXP '"+colValStr+"'");
					   result=stmt.executeQuery("SELECT scrIds FROM "+schemaName+".`"+viewName.toLowerCase()+"` where `"+columnName+"` REGEXP '"+colValStr+"'");
				   }
				   else
				   {
					   log.info("SELECT scrIds from "+schemaName+".`"+viewName.toLowerCase()+"` WHERE `"+columnName+"` IN ("+colValStr+")");
				       result=stmt.executeQuery("SELECT scrIds from "+schemaName+".`"+viewName.toLowerCase()+"` WHERE `"+columnName+"` IN ("+colValStr+")");					   
				   }
				   stmt.setFetchSize(500);
			       while(result.next()){
			    	   totalIds.add(new BigInteger(result.getString(1)));
			       }  
			   }
			   else
			   {
				   log.info("View doen't not exist for the view id: "+viewId);
			   }
		  }
		  catch(SQLException se){
			   log.info("Error while executing query: "+se);
		  }
		  catch(Exception e)
		  {
			  log.info("Exception while getting databse properties");
		  }
		  finally{	
			  if(result != null)
				  result.close();	
			  if(stmt != null)
				  stmt.close();
			  if(conn != null)
				  conn.close();
		  }
	  }
	  log.info("TotalIds Size: "+ totalIds.size());
	  return totalIds;
  }
  
  public List<BigInteger> getTotalIdsGroupByColumnValues(Long columnId, Long viewId, String rangeFrom, String rangeTo, List<String> colValues, String periodFactor) throws SQLException
  {
	  log.info("Fetching recon unreconciled ids for source group by columna name...");
	  List<BigInteger> totalIds = new ArrayList<BigInteger>();
	  
	  DataViewsColumns dvc = dataViewsColumnsRepository.findOne(columnId);
	  String columnName = "";
	  String dataType = "";
	  if(dvc != null)
	  {
		  if("VARCHAR".equals(dvc.getColDataType()) || "string".equals(dvc.getColDataType()))
		  {
			  dataType = dataType+"string";
		  }
		  else if("INTEGER".equalsIgnoreCase(dvc.getColDataType()) || "DECIMAL".equalsIgnoreCase(dvc.getColDataType()))
		  {
			  dataType = dataType+"integer";
		  }
		  else if("DATE".equalsIgnoreCase(dvc.getColDataType()))
		  {
			  dataType = dataType+"date";
		  }
		  if("File Template".equalsIgnoreCase(dvc.getRefDvType()))
		  {
				FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dvc.getRefDvColumn().toString()));
				if(ftl != null)
				{
					columnName = columnName + ftl.getColumnAlias();
				}
		  }
		  else if("Data View".equalsIgnoreCase(dvc.getRefDvType()) || dvc.getRefDvType() == null)
		  {
			columnName = columnName + dvc.getColumnName();
		  }
		  String colValStr = "";
		  if("string".equalsIgnoreCase(dataType))
		  {
			  if(colValues.size()>0)
			  {
				  for(int i=0; i<colValues.size(); i++)
				  {
					  if(i==colValues.size()-1)
					  {
						  colValStr = colValStr + "'"+colValues.get(i).trim()+"'";
					  }
					  else
					  {
						  colValStr = colValStr + "'"+colValues.get(i).trim()+"',";
					  }
				  }
			  }
		  }
		  else if("integer".equalsIgnoreCase(dataType))
		  {
			  if(colValues.size()>0)
			  {
				  for(int i=0; i<colValues.size(); i++)
				  {
					  if(i==colValues.size()-1)
					  {
						  colValStr = colValStr +colValues.get(i).trim();
					  }
					  else
					  {
						  colValStr = colValStr +colValues.get(i).trim()+",";
					  }
				  }
			  }
		  }
		  else if("DATE".equalsIgnoreCase(dataType))
		  {
			  	colValStr = colValues.toString();
			  	colValStr = colValStr.replace("[", "");
			  	colValStr = colValStr.replace("]", "");
			  	colValStr = colValStr.replace(",","|");
			  	colValStr = colValStr.replace(" ", "");
		  }
		  Connection conn = null;
		  Statement stmt = null;
		  ResultSet result = null; 
		  try{
			   String dbUrl=env.getProperty("spring.datasource.url");
			   String[] parts=dbUrl.split("[\\s@&?$+-]+");
			   String host = parts[0].split("/")[2].split(":")[0];
			   String schemaName=parts[0].split("/")[3];
			   String userName = env.getProperty("spring.datasource.username");
			   String password = env.getProperty("spring.datasource.password");
			   String jdbcDriver = env.getProperty("spring.datasource.jdbcdriver");  	  		
			   Class.forName(jdbcDriver);
			   conn = DriverManager.getConnection(dbUrl, userName, password);
			   stmt = conn.createStatement();
			   DataViews dv=dataViewsRepository.findOne(viewId.longValue());
			   if(dv!= null)
			   {
				   String viewName = dv.getDataViewName();
				   if("fileDate".equalsIgnoreCase(periodFactor))
				   {
					   if("DATE".equalsIgnoreCase(dataType))
					   {
						   log.info("SELECT scrIds FROM "+schemaName+".`"+viewName.toLowerCase()+"` where Date(fileDate) between '"+rangeFrom+"' AND '"+rangeTo+"' AND Date(`"+columnName+"`) REGEXP '"+colValStr+"'");
						   result=stmt.executeQuery("SELECT scrIds FROM "+schemaName+".`"+viewName.toLowerCase()+"` where Date(fileDate) between '"+rangeFrom+"' AND '"+rangeTo+"' AND Date(`"+columnName+"`) REGEXP '"+colValStr+"'");
					   }
					   else
					   {
						   log.info("SELECT scrIds from "+schemaName+".`"+viewName.toLowerCase()+"` WHERE Date(fileDate) between '"+rangeFrom+"' AND '"+rangeTo+"' AND `"+columnName+"` IN ("+colValStr+")");
					       result=stmt.executeQuery("SELECT scrIds from "+schemaName+".`"+viewName.toLowerCase()+"` WHERE Date(fileDate) between '"+rangeFrom+"' AND '"+rangeTo+"' AND `"+columnName+"` IN ("+colValStr+")");					   
					   }
				   }
				   else if("dateQualifier".equalsIgnoreCase(periodFactor))
				   {
					   String dateQualifier = reconciliationResultService.getTransDateQualifier(BigInteger.valueOf(viewId), "TRANSDATE");
					   if("DATE".equalsIgnoreCase(dataType))
					   {
						   log.info("SELECT scrIds FROM "+schemaName+".`"+viewName.toLowerCase()+"` where Date(`"+dateQualifier+"`) between '"+rangeFrom+"' AND '"+rangeTo+"' AND Date(`"+columnName+"`) REGEXP '"+colValStr+"'");
						   result=stmt.executeQuery("SELECT scrIds FROM "+schemaName+".`"+viewName.toLowerCase()+"` where Date(`"+dateQualifier+"`) between '"+rangeFrom+"' AND '"+rangeTo+"' AND `"+columnName+"` REGEXP '"+colValStr+"'");
					   }
					   else
					   {
						   log.info("SELECT scrIds from "+schemaName+".`"+viewName.toLowerCase()+"` WHERE Date(`"+dateQualifier+"`) between '"+rangeFrom+"' AND '"+rangeTo+"' AND `"+columnName+"` IN ("+colValStr+")");
					       result=stmt.executeQuery("SELECT scrIds from "+schemaName+".`"+viewName.toLowerCase()+"` WHERE Date(`"+dateQualifier+"`) between '"+rangeFrom+"' AND '"+rangeTo+"' AND `"+columnName+"` IN ("+colValStr+")");					   
					   }
				   }

				   stmt.setFetchSize(500);
			       while(result.next()){
			    	   totalIds.add(new BigInteger(result.getString(1)));
			       }  
			   }
			   else
			   {
				   log.info("View doen't not exist for the view id: "+viewId);
			   }
		  }
		  catch(SQLException se){
			   log.info("Error while executing query: "+se);
		  }
		  catch(Exception e)
		  {
			  log.info("Exception while getting databse properties");
		  }
		  finally{	
			  if(result != null)
				  result.close();	
			  if(stmt != null)
				  stmt.close();
			  if(conn != null)
				  conn.close();
		  }
	  }
	  log.info("TotalIds Size: "+ totalIds.size());
	  return totalIds;
  }
  
  public List<String> getDistinctColValuesWithFilteredGroupBy(Long viewId, String rangeFrom, String rangeTo, Long columnId, String transDateQualifier, String transDate) throws SQLException
  {
	  log.info("Fetching distinct column values for the view id: "+ viewId + ", column id: "+ columnId);
	  List<String> distColValues = new ArrayList<String>();
	  
	  Connection conn = null;
	  Statement stmt = null;
	  ResultSet result = null; 
	  try{
		   String dbUrl=env.getProperty("spring.datasource.url");
		   String[] parts=dbUrl.split("[\\s@&?$+-]+");
		   String host = parts[0].split("/")[2].split(":")[0];
		   String schemaName=parts[0].split("/")[3];
		   String userName = env.getProperty("spring.datasource.username");
		   String password = env.getProperty("spring.datasource.password");
		   String jdbcDriver = env.getProperty("spring.datasource.jdbcdriver");  	  		
		   Class.forName(jdbcDriver);
		   conn = DriverManager.getConnection(dbUrl, userName, password);
		   stmt = conn.createStatement();
		   DataViews dv=dataViewsRepository.findOne(viewId.longValue());
		   DataViewsColumns dvc = dataViewsColumnsRepository.findOne(columnId);
		   String dataType = "";
		   if(dv!= null && dvc != null)
		   {
			   String columnName = "";
			   if("File Template".equalsIgnoreCase(dvc.getRefDvType()))
			   {
				   FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dvc.getRefDvColumn().toString()));
				   if(ftl != null)
				   {
					   columnName = columnName + ftl.getColumnAlias();
				   }
			   }
			   else if("Data View".equalsIgnoreCase(dvc.getRefDvType()) || dvc.getRefDvType() == null)
			   {
				   columnName = columnName + dvc.getColumnName();
			   }
			   dataType = dvc.getColDataType();
			   if(columnName.length()>0)
			   {		
				   String viewName = dv.getDataViewName();
				   if("DATE".equalsIgnoreCase(dataType))
				   {
					   //"SELECT DATE("+transDateQualifier+") FROM "+schemaName+"."+viewName.toLowerCase()+" where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' group by DATE("+transDateQualifier+") ORDER BY DATE("+transDateQualifier+") DESC"
					   result=stmt.executeQuery("SELECT DATE(`"+columnName+"`) FROM "+schemaName+".`"+viewName.toLowerCase()+"` where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' AND `"+transDateQualifier +"` LIKE '%"+transDate+"%' group by DATE(`"+columnName+"`) ORDER BY DATE(`"+columnName+"`) DESC");
					   //result=stmt.executeQuery("SELECT distinct("+ columnName+") from "+schemaName+"."+viewName.toLowerCase()+" WHERE fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' ORDER BY "+columnName+" desc");   
				   }
				   else if("VARCHAR".equalsIgnoreCase(dataType) || "STRING".equalsIgnoreCase(dataType) || "INTEGER".equalsIgnoreCase(dataType) || "DECIMAL".equalsIgnoreCase(dataType))
				   {
					   result=stmt.executeQuery("SELECT distinct(`"+ columnName+"`) from "+schemaName+".`"+viewName.toLowerCase()+"` WHERE fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' AND `"+transDateQualifier +"` LIKE '%"+transDate+"%' ORDER BY `"+columnName+"` asc");
				   }
			       while(result.next()){
			    	   distColValues.add(result.getString(1));
			       }  
			   }
		   }
		   else
		   {
			   log.info("View doen't not exist for the view id: "+viewId);
		   }
	  }
	  catch(SQLException se){
		   log.info("Error while executing query: "+se);
	  }
	  catch(Exception e)
	  {
		  log.info("Exception while getting databse properties");
	  }
	  finally{	
		  if(result != null)
			  result.close();	
		  if(stmt != null)
			  stmt.close();
		  if(conn != null)
			  conn.close();
	  }

	  log.info("Distinct column values: "+ distColValues);
	  return distColValues;
  }

  public List<String> getDistinctDaysWithFilteredGroupByColumnValue(Long viewId, String rangeFrom, String rangeTo, String transDateQualifier, Long columnId, String columnValue) throws SQLException
  {
	  log.info("Fetching distinct column values for the view id: "+ viewId + ", column id: "+ columnId);
	  List<String> distColValues = new ArrayList<String>();
	  Connection conn = null;
	  Statement stmt = null;
	  ResultSet result = null; 
	  try{
		   String dbUrl=env.getProperty("spring.datasource.url");
		   String[] parts=dbUrl.split("[\\s@&?$+-]+");
		   String host = parts[0].split("/")[2].split(":")[0];
		   String schemaName=parts[0].split("/")[3];
		   String userName = env.getProperty("spring.datasource.username");
		   String password = env.getProperty("spring.datasource.password");
		   String jdbcDriver = env.getProperty("spring.datasource.jdbcdriver");  	  		
		   Class.forName(jdbcDriver);
		   conn = DriverManager.getConnection(dbUrl, userName, password);
		   stmt = conn.createStatement();
		   DataViews dv=dataViewsRepository.findOne(viewId.longValue());
		   DataViewsColumns dvc = dataViewsColumnsRepository.findOne(columnId);
		   String dataType = "";
		   if(dv!= null && dvc != null)
		   {
			   String columnName = "";
			   if("File Template".equalsIgnoreCase(dvc.getRefDvType()))
			   {
				   FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dvc.getRefDvColumn().toString()));
				   if(ftl != null)
				   {
					   columnName = columnName + ftl.getColumnAlias();
				   }
			   }
			   else if("Data View".equalsIgnoreCase(dvc.getRefDvType()) || dvc.getRefDvType() == null)
			   {
				   columnName = columnName + dvc.getColumnName();
			   }
			   dataType = dvc.getColDataType();
			   if(columnName.length()>0)
			   {		
				   String viewName = dv.getDataViewName();
				   if("DATE".equalsIgnoreCase(dataType))
				   {
					   //"SELECT DATE("+transDateQualifier+") FROM "+schemaName+"."+viewName.toLowerCase()+" where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' group by DATE("+transDateQualifier+") ORDER BY DATE("+transDateQualifier+") DESC"
					   result=stmt.executeQuery("SELECT DATE(`"+transDateQualifier+"`) FROM "+schemaName+".`"+viewName.toLowerCase()+"` where fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' AND `"+columnName +"` LIKE '%"+columnValue+"%' group by DATE(`"+transDateQualifier+"`) ORDER BY DATE(`"+transDateQualifier+"`) DESC");
					   //result=stmt.executeQuery("SELECT distinct("+ columnName+") from "+schemaName+"."+viewName.toLowerCase()+" WHERE fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' ORDER BY "+columnName+" desc");   
				   }
				   else if("VARCHAR".equalsIgnoreCase(dataType) || "STRING".equalsIgnoreCase(dataType))
				   {
					   result=stmt.executeQuery("SELECT distinct(`"+ transDateQualifier+"`) from "+schemaName+".`"+viewName.toLowerCase()+"` WHERE fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' AND `"+columnName +"` = '"+columnValue+"' ORDER BY `"+transDateQualifier+"` DESC");
				   }
				   else if("INTEGER".equalsIgnoreCase(dataType) || "DECIMAL".equalsIgnoreCase(dataType))
				   {
					   result=stmt.executeQuery("SELECT distinct(`"+ transDateQualifier+"`) from "+schemaName+".`"+viewName.toLowerCase()+"` WHERE fileDate between '"+rangeFrom+"' AND '"+rangeTo+"' AND `"+columnName +"` = "+columnValue+" ORDER BY `"+transDateQualifier+"` DESC");
				   }
			       while(result.next()){
			    	   distColValues.add(result.getString(1));
			       }  
			   }
		   }
		   else
		   {
			   log.info("View doen't not exist for the view id: "+viewId);
		   }
	  }
	  catch(SQLException se){
		   log.info("Error while executing query: "+se);
	  }
	  catch(Exception e)
	  {
		  log.info("Exception while getting databse properties");
	  }
	  finally{	
		  if(result != null)
			  result.close();	
		  if(stmt != null)
			  stmt.close();
		  if(conn != null)
			  conn.close();
	  }

	  log.info("Distinct column values: "+ distColValues);
	  return distColValues;
  }

  
  public List<String> getDistinctColValues(Long viewId, String rangeFrom, String rangeTo, Long columnId, String periodFactor) throws SQLException
  {
	  log.info("Fetching distinct column values for the view id: "+ viewId + ", column id: "+ columnId);
	  List<String> distColValues = new ArrayList<String>();
	  
	  Connection conn = null;
	  Statement stmt = null;
	  ResultSet result = null; 
	  try{
		   String dbUrl=env.getProperty("spring.datasource.url");
		   String[] parts=dbUrl.split("[\\s@&?$+-]+");
		   String host = parts[0].split("/")[2].split(":")[0];
		   String schemaName=parts[0].split("/")[3];
		   String userName = env.getProperty("spring.datasource.username");
		   String password = env.getProperty("spring.datasource.password");
		   String jdbcDriver = env.getProperty("spring.datasource.jdbcdriver");  	  		
		   Class.forName(jdbcDriver);
		   conn = DriverManager.getConnection(dbUrl, userName, password);
		   stmt = conn.createStatement();
		   DataViews dv=dataViewsRepository.findOne(viewId.longValue());
		   DataViewsColumns dvc = dataViewsColumnsRepository.findOne(columnId);
		   String dataType = "";
		   if(dv!= null && dvc != null)
		   {
			   String columnName = "";
			   if("File Template".equalsIgnoreCase(dvc.getRefDvType()))
			   {
				   FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dvc.getRefDvColumn().toString()));
				   if(ftl != null)
				   {
					   columnName = columnName + ftl.getColumnAlias();
				   }
			   }
			   else if("Data View".equalsIgnoreCase(dvc.getRefDvType()) || dvc.getRefDvType() == null)
			   {
				   columnName = columnName + dvc.getColumnName();
			   }
			   dataType = dvc.getColDataType();
			   if(columnName.length()>0)
			   {		
				   String viewName = dv.getDataViewName();
				   if("fileDate".equalsIgnoreCase(periodFactor))
				   {
					   if("DATE".equalsIgnoreCase(dataType))
					   {
						   log.info("DistinctColumnsQuery: SELECT DATE(`"+columnName+"`) FROM "+schemaName+".`"+viewName.toLowerCase()+"` where Date(fileDate) between '"+rangeFrom+"' AND '"+rangeTo+"' group by DATE(`"+columnName+"`) ORDER BY DATE(`"+columnName+"`) DESC");
						   result=stmt.executeQuery("SELECT DATE(`"+columnName+"`) FROM "+schemaName+".`"+viewName.toLowerCase()+"` where Date(fileDate) between '"+rangeFrom+"' AND '"+rangeTo+"' group by DATE(`"+columnName+"`) ORDER BY DATE(`"+columnName+"`) DESC");
					   }
					   else if("VARCHAR".equalsIgnoreCase(dataType) || "STRING".equalsIgnoreCase(dataType) || "INTEGER".equalsIgnoreCase(dataType) || "DECIMAL".equalsIgnoreCase(dataType))
					   {
						   log.info("DistinctColumnsQuery: SELECT distinct(`"+ columnName+"`) from "+schemaName+".`"+viewName.toLowerCase()+"` WHERE Date(fileDate) between '"+rangeFrom+"' AND '"+rangeTo+"' ORDER BY `"+columnName+"` asc");
						   result=stmt.executeQuery("SELECT distinct(`"+ columnName+"`) from "+schemaName+".`"+viewName.toLowerCase()+"` WHERE Date(fileDate) between '"+rangeFrom+"' AND '"+rangeTo+"' ORDER BY `"+columnName+"` asc");
					   }
					   
				   }
				   else if("dateQualifier".equalsIgnoreCase(periodFactor))
				   {
					   String transDateColumn = reconciliationResultService.getTransDateQualifier(new BigInteger(viewId.toString()), "TRANSDATE");
					   if(transDateColumn.length()>0)
					   {
						   if("DATE".equalsIgnoreCase(dataType))
						   {
							   log.info("DistinctColumnsQuery: SELECT DATE(`"+columnName+"`) FROM "+schemaName+".`"+viewName.toLowerCase()+"` where Date(`"+transDateColumn+"`) between '"+rangeFrom+"' AND '"+rangeTo+"' group by DATE(`"+columnName+"`) ORDER BY DATE(`"+columnName+"`) DESC");
							   result=stmt.executeQuery("SELECT DATE(`"+columnName+"`) FROM "+schemaName+".`"+viewName.toLowerCase()+"` where Date(`"+transDateColumn+"`) between '"+rangeFrom+"' AND '"+rangeTo+"' group by DATE(`"+columnName+"`) ORDER BY DATE(`"+columnName+"`) DESC");
						   }
						   else if("VARCHAR".equalsIgnoreCase(dataType) || "STRING".equalsIgnoreCase(dataType) || "INTEGER".equalsIgnoreCase(dataType) || "DECIMAL".equalsIgnoreCase(dataType))
						   {
							   log.info("DistinctColumnsQuery: SELECT distinct(`"+ columnName+"`) from "+schemaName+".`"+viewName.toLowerCase()+"` WHERE Date(`"+transDateColumn+"`) between '"+rangeFrom+"' AND '"+rangeTo+"' ORDER BY `"+columnName+"` asc");
							   result=stmt.executeQuery("SELECT distinct(`"+ columnName+"`) from "+schemaName+".`"+viewName.toLowerCase()+"` WHERE Date(`"+transDateColumn+"`) between '"+rangeFrom+"' AND '"+rangeTo+"' ORDER BY `"+columnName+"` asc");
						   }  
					   }
				   }
			       while(result.next()){
			    	   distColValues.add(result.getString(1));
			       }  
			   }
		   }
		   else
		   {
			   log.info("View doen't not exist for the view id: "+viewId);
		   }
	  }
	  catch(SQLException se){
		   log.info("Error while executing query: "+se);
	  }
	  catch(Exception e)
	  {
		  log.info("Exception while getting databse properties");
	  }
	  finally{	
		  if(result != null)
			  result.close();	
		  if(stmt != null)
			  stmt.close();
		  if(conn != null)
			  conn.close();
	  }
	  return distColValues;
  }
  
  
  /**
   * Author: Shiva
   * Purpose: Fetching trans date's grouped list
   * @throws ClassNotFoundException 
   * @throws SQLException 
   * **/
  public List<HashMap> getGroupedTransDatesListWithMultipleCurrency(List<String> transDates, String rangeFrom, String rangeTo, Long viewId, Long tenantId, Long groupId, String qualifier, String amountQualifier, String jobReference, List<String> currencyCodes, String currencyQualifier) throws ClassNotFoundException, SQLException
  {
	   List<HashMap> transDatesList = new ArrayList<HashMap>();
	   Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	   String currencyFormat = props.getProperty("currencyFormat");
	   if(currencyCodes.size()>0)
	   {
		   for(String transDate: transDates)
		   {
			   HashMap  transDateMp = new HashMap();
			   transDateMp.put("name", transDate);
			   List<HashMap> currencyGroupedList = new ArrayList<HashMap>();
			   for(String currency : currencyCodes)
			   {
				   HashMap currencyMp = new HashMap();
				   currencyMp.put("name", currency);
				   List<BigInteger> totalOriginalIds = getOriginalIdsByTransDateWithCurrency(viewId, rangeFrom, rangeTo, qualifier, transDate, "string", currencyQualifier, currency);
				   List<BigInteger> unRecIds = new ArrayList<BigInteger>();
				   if(totalOriginalIds.size()>0)
				   {
					   List<BigInteger> recIds = new ArrayList<BigInteger>();
					   if(jobReference.length()>0)
					   {
						   recIds = reconciliationResultRepository.fetchReconciledIdswithJobReferenceForSource(tenantId, groupId, totalOriginalIds, jobReference, viewId);
					   }
					   else
					   {
						   recIds = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForSource(tenantId, groupId, totalOriginalIds, viewId);
					   }
	
					   for(BigInteger id: totalOriginalIds)
					   {
						   if(!recIds.contains(id))
						   {
							   unRecIds.add(id);
						   }
					   }
					   
					   HashMap total = new HashMap();
					   HashMap recon = new HashMap();
					   HashMap unRecon = new HashMap();
					   
					   HashMap totalAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, amountQualifier,totalOriginalIds);
					   total.put("amount", reconciliationResultService.getAmountInFormat(totalAmountCount.get("totalAmount").toString(),currencyFormat));
					   total.put("count", totalAmountCount.get("totalCount"));
					   currencyMp.put("total", total);
					   
					   HashMap recAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, amountQualifier,recIds);
					   recon.put("amount", reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
					   recon.put("count", recAmountCount.get("totalCount"));
					   currencyMp.put("reconciled", recon);
					   
					   HashMap unRecAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, amountQualifier,unRecIds);
					   unRecon.put("amount", reconciliationResultService.getAmountInFormat(unRecAmountCount.get("totalAmount").toString(),currencyFormat));
					   unRecon.put("count", unRecAmountCount.get("totalCount"));
					   currencyMp.put("unReconciled", unRecon);
					   currencyGroupedList.add(currencyMp);
				   }
			   }
			   transDateMp.put("currencyGroupedList", currencyGroupedList);
			   //log.info("CurrencyCodeGroupedList: "+currencyGroupedList.size());
			   transDatesList.add(transDateMp);
		   }
	   }

	   log.info("Grouped by trans date size: "+transDatesList.size());
	   return transDatesList;
  }
  
  
  /**
   * Author: Shiva
   * Purpose: Fetching trans date's grouped list
   * @throws ClassNotFoundException 
   * @throws SQLException 
   * **/
  public List<HashMap> getGroupedTransDatesListWithMultipleCurrencyTree(List<String> transDates, String rangeFrom, String rangeTo, Long viewId, Long tenantId, Long groupId, String qualifier, String amountQualifier, String jobReference, List<String> currencyCodes, String currencyQualifier) throws ClassNotFoundException, SQLException
  {
	   List<HashMap> transDatesList = new ArrayList<HashMap>();
	   Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	   String currencyFormat = props.getProperty("currencyFormat");
	   if(currencyCodes.size()>0)
	   {
		   for(String transDate: transDates)
		   {
			   List<HashMap> currencyGroupedList = new ArrayList<HashMap>();
			   for(String currency : currencyCodes)
			   {
				   HashMap  transDateMp = new HashMap();
				   transDateMp.put("name", transDate);
				   transDateMp.put("currency", currency);

				   List<BigInteger> totalOriginalIds = getOriginalIdsByTransDateWithCurrency(viewId, rangeFrom, rangeTo, qualifier, transDate, "string", currencyQualifier, currency);
				   List<BigInteger> unRecIds = new ArrayList<BigInteger>();
				   if(totalOriginalIds.size()>0)
				   {
					   List<BigInteger> recIds = new ArrayList<BigInteger>();
					   if(jobReference.length()>0)
					   {
						   recIds = reconciliationResultRepository.fetchReconciledIdswithJobReferenceForSource(tenantId, groupId, totalOriginalIds, jobReference, viewId);
					   }
					   else
					   {
						   recIds = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForSource(tenantId, groupId, totalOriginalIds, viewId);
					   }
	
					   for(BigInteger id: totalOriginalIds)
					   {
						   if(!recIds.contains(id))
						   {
							   unRecIds.add(id);
						   }
					   }
					   
					   HashMap total = new HashMap();
					   HashMap recon = new HashMap();
					   HashMap unRecon = new HashMap();
					   
					   HashMap totalAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, amountQualifier,totalOriginalIds);
					   total.put("amount", reconciliationResultService.getAmountInFormat(totalAmountCount.get("totalAmount").toString(),currencyFormat));
					   total.put("count", totalAmountCount.get("totalCount"));
					   transDateMp.put("total", total);
					   
					   HashMap recAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, amountQualifier,recIds);
					   recon.put("amount", reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
					   recon.put("count", recAmountCount.get("totalCount"));
					   transDateMp.put("reconciled", recon);
					   
					   HashMap unRecAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, amountQualifier,unRecIds);
					   unRecon.put("amount", reconciliationResultService.getAmountInFormat(unRecAmountCount.get("totalAmount").toString(),currencyFormat));
					   unRecon.put("count", unRecAmountCount.get("totalCount"));
					   transDateMp.put("unReconciled", unRecon);
					   
					   transDatesList.add(transDateMp);
				   }
			   }
			   
		   }
	   }

	   log.info("Grouped by trans date size: "+transDatesList.size());
	   return transDatesList;
  }
  
  public String getCurrencySymbol(String currencyCode) throws ParseException
  {
	  String symbol = "";
		String jsonString = "[ {"
				   +"   \"symbol\":\"$\","
				   +  " \"currency\":\"USD\" "
				   +" },"
				   + " { "
				   +"   \"symbol\":\"$\","
				   +  " \"currency\":\"US\" "
				   +" },"
				   + "{"
				   +  " \"symbol\":\"CA$\","
				   + " \"currency\":\"CAD\" "
				   + " },"
				   + " { "
				   + "   \"symbol\":\"\u20AC\", "
				   + "   \"currency\":\"EUR\" "
				   + "},"
				   + " { "
				   + "   \"symbol\":\"AED\", "
				   + "   \"currency\":\"AED\" "
				   + "  },"
				   + "  { "
				   + "   \"symbol\":\"Af\", "
				   + "    \"currency\":\"AFN\""
				   + "  },"
				   + "  {"
				   + "    \"symbol\":\"ALL\","
				   + "   \"currency\":\"ALL\""
				   + "  },"
				   + "  {"
				   + "    \"symbol\":\"AMD\","
				   + "    \"currency\":\"AMD\""
				   + "  },"
				   + "  {"
				   + "     \"symbol\":\"AR$\","
				   +  " \"currency\":\"ARS\""
				   + " },"
				   + " {"
				   + "  \"symbol\":\"AU$\","
				   + "  \"currency\":\"AUD\""
				   + " },"
				   + " { "
				   + "  \"symbol\":\"man.\", "
				   + "   \"currency\":\"AZN\""
				   + "},"
				   + "{"
				   + "   \"symbol\":\"KM\","
				    + "   \"currency\":\"BAM\""
				    + " },"
				    + "{"
				      + " \"symbol\":\"Tk\","
				       + "\"currency\":\"BDT\""
				       + " },"
				       + " {"
				       + "\"symbol\":\"BGN\","
				       + "\"currency\":\"BGN\""
				       + " },"
				       + "{"
				     + "  \"symbol\":\"BD\","
				    + "   \"currency\":\"BHD\""
				    + "  },"
				    + "  {"
				   + "    \"symbol\":\"FBu\","
				   + "    \"currency\":\"BIF\""
				   + " },"
				   + " {"
				   + "    \"symbol\":\"BN$\","
				    + "   \"currency\":\"BND\""
				    + " },"
				    + " {"
							 + "     \"symbol\":\"Bs\","
				     + "  \"currency\":\"BOB\""
				     + " },"
				     + "  {"
				    + "   \"symbol\":\"R$\","
				      + "    \"currency\":\"BRL\""
				      + "   },"
				      + "  {"
				   + "    \"symbol\":\"BWP\","
				   + "    \"currency\":\"BWP\""
				   + "  },"
				   + "  {"
				  + "     \"symbol\":\"BYR\","
				   + "    \"currency\":\"BYR\""
				   + " },"
				   + " {"
				  + "     \"symbol\":\"BZ$\","
				   + "    \"currency\":\"BZD\""
				   + " },"
				   + "  {"
				  + "     \"symbol\":\"CDF\","
				      + "     \"currency\":\"CDF\""
				      + " },"
				      + "  {"
				  + "     \"symbol\":\"CHF\","
				  + "     \"currency\":\"CHF\""
				  + "  },"
				  + "  {"
				   + "    \"symbol\":\"CL$\","
				  + "    \"currency\":\"CLP\""
				  + "  },"
				  + "  {"
				   + "    \"symbol\":\"CN\","
				   + "    \"currency\":\"CNY\""
				   + "  },"
				   + " {"
				    + "   \"symbol\":\"CO$\","
				    + "   \"currency\":\"COP\""
				    + " },"
				    + " {"
				   + "    \"symbol\":\"\u20A1\","
				      + "     \"currency\":\"CRC\""
				      + "  },"
				      + "  {"
							 + "     \"symbol\":\"CV$\","
				   + "    \"currency\":\"CVE\""
				   + " },"
				   + "  {"
				   + "    \"symbol\":\"K\","
				   + "    \"currency\":\"CZK\""
				   + "  },"
				   + "  {"
				  + "     \"symbol\":\"Fdj\","
				   + "    \"currency\":\"DJF\""
				   + "  },"
				   + "  {"
				    + "   \"symbol\":\"Dkr\","
				    + "   \"currency\":\"DKK\""
				    + "  },"
				    + "  {"
				   + "    \"symbol\":\"RD$\","
				   + "    \"currency\":\"DOP\""
				   + " },"
				   + "  {"
				   + "    \"symbol\":\"DA\","
				   + "    \"currency\":\"DZD\""
				   + " },"
				   + " {"
				   + "    \"symbol\":\"Ekr\","
				   + "   \"currency\":\"EEK\""
				   + " },"
				   + "  {"
					   + "     \"symbol\":\"EGP\","
				   + "    \"currency\":\"EGP\""
				   + "  },"
				   + "  {"
				   + "    \"symbol\":\"Nfk\","
				   + "    \"currency\":\"ERN\""
				   + "  },"
				   + "  {"
				   + "    \"symbol\":\"Br\","
				      + "    \"currency\":\"ETB\""
				      + "  },"
				      + " {"
				   + "    \"symbol\":\"\","
				   + "    \"currency\":\"GBP\""
				   + " },"
				   + " {"
				   + "    \"symbol\":\"GEL\","
				   + "    \"currency\":\"GEL\""
				      + " },"
				      + " {"
				    + "   \"symbol\":\"GH\u20B5\","
				    + "   \"currency\":\"GHS\""
				    + "},"
				   + "  {"
				   + "    \"symbol\":\"FG\","
				      + "    \"currency\":\"GNF\""
				  + "  },"
				  + "  {"
				  + "     \"symbol\":\"GTQ\","
				  + "     \"currency\":\"GTQ\""
				 + "   },"
				 + "  {"
				   + "    \"symbol\":\"HK$\","
				   + "    \"currency\":\"HKD\""
				  + "  },"
				  + "  {"
				   + "    \"symbol\":\"HNL\","
				   + "    \"currency\":\"HNL\""
				  + "  },"
				  + "   {"
				   + "    \"symbol\":\"kn\","
				   + "    \"currency\":\"HRK\""
				   + " },"
				   + "  {"
				   + "    \"symbol\":\"Ft\","
				  + "     \"currency\":\"HUF\""
				 + "   },"
				 + "  {"
				   + "    \"symbol\":\"Rp\","
				      + "     \"currency\":\"IDR\""
				  + "  },"
				  + "  {"
					   + "     \"symbol\":\"\u20AA\","
				   + "    \"currency\":\"ILS\""
				  + "  },"
				   + "  {"
				  + "     \"symbol\":\"\","
				  + "     \"currency\":\"INR\""
				 + "   },"
				 + "  {"
				 + "  \"symbol\":\"IQD\","
				 + "     \"currency\":\"IQD\""
				    		  + " },"
				    		  + "   {"
				   + "    \"symbol\":\"IRR\","
				   + "    \"currency\":\"IRR\""
				  + "  },"
				  + "  {"
				   + "    \"symbol\":\"Ikr\","
				      + "     \"currency\":\"ISK\""
				  + "  },"
				  + " {"
				   + "    \"symbol\":\"J$\","
				   + "    \"currency\":\"JMD\""
				  + "  },"
				  + "  {"
				  + "     \"symbol\":\"JD\","
				  + "     \"currency\":\"JOD\""
				  + "  },"
				  + "  {"
					   + "     \"symbol\":\"\","
				   + "    \"currency\":\"JPY\""
				 + "   },"
				 + " {"
				  + "     \"symbol\":\"Ksh\","
				  + "     \"currency\":\"KES\""
				  + "  },"
				  + "  {"
					   + "     \"symbol\":\"KHR\","
				    + "   \"currency\":\"KHR\""
				   + " },"
				   + "  {"
				   + "    \"symbol\":\"CF\","
				   + "    \"currency\":\"KMF\""
				  + "  },"
				  + "  {"
				  + "     \"symbol\":\"\u20A9\","
				      + "     \"currency\":\"KRW\""
				  + "  },"
				  + "  {"
				  + "     \"symbol\":\"KD\","
				  + "     \"currency\":\"KWD\""
				  + "  },"
				  + "   {"
				   + "    \"symbol\":\"KZT\","
				   + "    \"currency\":\"KZT\""
				  + "  },"
				  + " {"
				   + "    \"symbol\":\"LB\","
				   + "    \"currency\":\"LBP\""
				  + "  },"
				  + " {"
					 + "  \"symbol\":\"SLRs\","
					 + "    \"currency\":\"LKR\""
				  + "  },"
				  + "   {"
				 + "   \"symbol\":\"Lt\","
				 + "      \"currency\":\"LTL\""
				  + "  },"
				  + "  {"
				   + "    \"symbol\":\"Ls\","
				   + "    \"currency\":\"LVL\""
				   + " },"
				   + " {"
				   + "    \"symbol\":\"LD\","
				  + "     \"currency\":\"LYD\""
				    		  + "  },"
				    		  + "  {"
				  + "     \"symbol\":\"MAD\","
				    + "   \"currency\":\"MAD\""
				    		  + "  },"
				    		  + "  {"
					   + "     \"symbol\":\"MDL\","
				   + "    \"currency\":\"MDL\""
				  + "  },"
				  + "  {"
				    + "   \"symbol\":\"MGA\","
				   + "    \"currency\":\"MGA\""
				   + " },"
				   + "  {"
				   + "    \"symbol\":\"MKD\","
				   + "    \"currency\":\"MKD\""
				   + " },"
				   + " {"
				    + "   \"symbol\":\"MMK\","
				    + "   \"currency\":\"MMK\""
				 + "   },"
				 + "  {"
				  + "     \"symbol\":\"MOP$\","
				      + "     \"currency\":\"MOP\""
				  + "  },"
				  + " {"
				   + "    \"symbol\":\"MURs\","
				   + "    \"currency\":\"MUR\""
				   + " },"
				   + "  {"
				   + "    \"symbol\":\"MX$\","
				   + "    \"currency\":\"MXN\""
				    		  + " },"
				    		  + " {"
				  + "     \"symbol\":\"RM\","
				  + "   \"currency\":\"MYR\""
				    		  + "  },"
				    		  + " {"
				    + "   \"symbol\":\"MTn\","
				  + "     \"currency\":\"MZN\""
				  + "  },"
				  + " {"
				   + "    \"symbol\":\"N$\","
				   + "    \"currency\":\"NAD\""
				   + " },"
				   + " {"
				  + "     \"symbol\":\"\u20A6\","
				  + "     \"currency\":\"NGN\""
				  + "  },"
				  + "   {"
				   + "    \"symbol\":\"C$\","
				  + "     \"currency\":\"NIO\""
				  + "  },"
				  + "  {"
				  + "     \"symbol\":\"Nkr\","
				      + "     \"currency\":\"NOK\""
				  + "  },"
				  + "  {"
				  + "     \"symbol\":\"NPRs\","
				  + "     \"currency\":\"NPR\""
				  + "  },"
				  + " {"
				   + "    \"symbol\":\"NZ$\","
				      + "   \"currency\":\"NZD\""
				   + " },"
				   + "  {"
				  + "     \"symbol\":\"OMR\","
				   + "    \"currency\":\"OMR\""
				  + "  },"
				  + "  {"
					   + " \"symbol\":\"B/.\","
				  + "     \"currency\":\"PAB\""
				  + "  },"
				  + "  {"
				  + "     \"symbol\":\"S/.\","
				  + "     \"currency\":\"PEN\""
				  + "  },"
				  + "  {"
				  + "     \"symbol\":\"\u20B1\","
				    + "   \"currency\":\"PHP\""
				 + "   },"
				 + "  {"
				  + "     \"symbol\":\"PKRs\","
				  + "     \"currency\":\"PKR\""
				    		  + " },"
				    		  + "  {"
				  + "     \"symbol\":\"z\","
				      + "     \"currency\":\"PLN\""
				  + "  },"
				  + "  {"
				   + "    \"symbol\":\"\u20B2\","
				  + "     \"currency\":\"PYG\""
				    		  + " },"
				    		  + "  {"
				  + "     \"symbol\":\"QR\","
				      + "    \"currency\":\"QAR\""
				    		  + "},"
				    		  + " {"
				   + "    \"symbol\":\"RON\","
				   + "    \"currency\":\"RON\""
				  + "  },"
				  + "  {"
				  + "     \"symbol\":\"din.\","
				  + "     \"currency\":\"RSD\""
				  + "  },"
				  + "  {"
					   + "     \"symbol\":\"RUB\","
				  + "     \"currency\":\"RUB\""
				  + "  },"
				  + " {"
				   + "    \"symbol\":\"RWF\","
				      + "    \"currency\":\"RWF\""
				   + " },"
				   + "  {"
				    + "   \"symbol\":\"SR\","
				  + "     \"currency\":\"SAR\""
				  + "  },"
				  + "  {"
				   + "    \"symbol\":\"SDG\","
				      + "    \"currency\":\"SDG\""
				  + "  },"
				  + "  {"
					   + "    \"symbol\":\"Skr\","
				  + "     \"currency\":\"SEK\""
				  + "  },"
				  + "   {"
				   + "    \"symbol\":\"S$\","
				      + "    \"currency\":\"SGD\""
				   + " },"
				   + " {"
				   + "    \"symbol\":\"Ssh\","
				   + "    \"currency\":\"SOS\""
				   + " },"
				   + " {"
				   + "    \"symbol\":\"SY\","
				   + "    \"currency\":\"SYP\""
				  + "  },"
				  + "  {"
				  + "     \"symbol\":\"\","
				  + "     \"currency\":\"THB\""
				  + "  },"
				  + "  {"
				   + "    \"symbol\":\"DT\","
				      + "    \"currency\":\"TND\""
				  + "  },"
				  + " {"
				   + "    \"symbol\":\"T$\","
				   + "    \"currency\":\"TOP\""
				  + "  },"
				  + "  {"
				  + "     \"symbol\":\"TL\","
				      + "     \"currency\":\"TRY\""
				  + "  },"
				  + "   {"
				  + "     \"symbol\":\"TT$\","
				   + "    \"currency\":\"TTD\""
				    		  + "  },"
				    		  + " {"
				   + "    \"symbol\":\"NT$\","
				   + "    \"currency\":\"TWD\""
				  + "  },"
				  + " {"
				  + "     \"symbol\":\"TSh\","
				   + "    \"currency\":\"TZS\""
				  + "  },"
				  + " {"
				   + "    \"symbol\":\"\u20B4\","
				   + "    \"currency\":\"UAH\""
				    		  + " },"
				    		  + " {"
				   + "    \"symbol\":\"USh\","
				  + "     \"currency\":\"UGX\""
				  + "  },"
				  + "  {"
				   + "    \"symbol\":\"$U\","
				  + "     \"currency\":\"UYU\""
				  + "  },"
				  + "  {"
				   + "    \"symbol\":\"UZS\","
				   + "    \"currency\":\"UZS\""
				  + "  },"
				  + "  {"
				  + "     \"symbol\":\"Bs.F.\","
				    + "   \"currency\":\"VEF\""
				   + " },"
				   + " {"
				  + "     \"symbol\":\"\u20AB\","
				  + "     \"currency\":\"VND\""
				  + "  },"
				   + "   {"
				 + "      \"symbol\":\"FCFA\","
				      + "     \"currency\":\"XAF\""
				  + "  },"
				  + "   {"
				  + "     \"symbol\":\"CFA\","
				  + "     \"currency\":\"XOF\""
				  + "  },"
				  + "   {"
				  + "     \"symbol\":\"YR\","
				      + "   \"currency\":\"YER\""
				 + "   },"
				 + "   {"
				  + "     \"symbol\":\"R\","
				   + "    \"currency\":\"ZAR\""
				 + "   },"
				 + "   {"
				  + "     \"symbol\":\"ZK\","
				      + "     \"currency\":\"ZMK\""
				  + "  }"
				  + "]";
						
						 JSONArray c = (JSONArray) new JSONParser().parse(jsonString);
						 for(int i = 0; i < c.size(); i++) {
					            JSONObject obj = (JSONObject) c.get(i);
					            if(currencyCode.equalsIgnoreCase(obj.get("currency").toString()))
					            {
					            	symbol = obj.get("symbol").toString();
					            }
					            //System.out.println("["+obj.get("currency")+", "+obj.get("symbol")+"]"); 
						 }
						 
						 return symbol; 
  }
  
  public HashMap getColNameNType(Long columnId)
  {
	  //log.info("ColumnId: "+ columnId);
	  HashMap finalMap = new HashMap();
	  DataViewsColumns dvc = dataViewsColumnsRepository.findOne(columnId);
	  if(dvc != null)
	  {
		  if("File Template".equalsIgnoreCase(dvc.getRefDvType()))
		  {
			  FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dvc.getRefDvColumn()));
			  if(ftl != null)
			  {
				  finalMap.put("columnName",ftl.getColumnAlias());
				  finalMap.put("dataType", dvc.getColDataType());
			  }
		  }
		  else if("Data View".equalsIgnoreCase(dvc.getRefDvType()) || dvc.getRefDvType() == null)
		  {
			  finalMap.put("columnName",dvc.getColumnName());
			  finalMap.put("dataType", dvc.getColDataType());
		  }
	  }
	  return finalMap;
  }
  
  
  
  // Reconciled, Un-Reconciled Total Amounts
  public HashMap getTotalRecUnRecAmounts(Long viewId, Long tenantId, Long groupId, String sourceOrTarget) throws SQLException, ClassNotFoundException, ParseException
  {
	  HashMap finalMap = new HashMap();
	  String amoutQualifier = reconciliationResultService.getQualifier(BigInteger.valueOf(viewId));
	  List<BigInteger> allOriginalIds = getTargetIds(viewId);
	  List<BigInteger> recIds = new ArrayList<BigInteger>();
	  List<BigInteger> unRecIds = new ArrayList<BigInteger>();
	  String currencyCodeColName = getTransDateQualifier(BigInteger.valueOf(viewId), "CURRENCYCODE");
	  DataViews dv = dataViewsRepository.findOne(viewId.longValue());

	  Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	  String currencyFormat = props.getProperty("currencyFormat");
  	
	  if(dv != null && amoutQualifier.length()>0 && allOriginalIds.size()>0)
	  {
		  if(allOriginalIds.size()>0)
		  {
			  if("source".equalsIgnoreCase(sourceOrTarget))
			  {
				  recIds = reconciliationResultRepository.fetchReconciledSourceIds(tenantId, groupId, viewId);
			  }
			  else if("target".equalsIgnoreCase(sourceOrTarget))
			  {
				  recIds = reconciliationResultRepository.fetchReconciledTargetIds(tenantId, groupId, viewId);
			  }

			  for(BigInteger id : allOriginalIds)
			  {
				  if(!recIds.contains(id))
				  {
					  unRecIds.add(id);
				  }
			  }
		  }
		   List<String> currenciesRec = getDistColumnValues(recIds,currencyCodeColName,dv.getDataViewName());
		   String currencySymbol = "";
		   if(currenciesRec.size()==1)
		   {
			   currencySymbol = currencySymbol+getCurrencySymbol(currenciesRec.get(0));
		   }
		   else if(currenciesRec.size()>1)
		   {
			   currencySymbol = currencySymbol+"*";
		   }
		  HashMap recAmountCount = reconciliationResultService.getCountNAmountForDVId(BigInteger.valueOf(viewId), tenantId, amoutQualifier,recIds);
		  
		   List<String> currenciesUnRec = getDistColumnValues(unRecIds,currencyCodeColName,dv.getDataViewName());
		   String currencyUnSymbol = "";
		   if(currenciesUnRec.size()==1)
		   {
			   currencyUnSymbol = currencyUnSymbol+getCurrencySymbol(currenciesUnRec.get(0));
		   }
		   else if(currenciesUnRec.size()>1)
		   {
			   currencyUnSymbol = currencyUnSymbol+"*";
		   }
		  
		  HashMap unRecAmountCount = reconciliationResultService.getCountNAmountForDVId(BigInteger.valueOf(viewId), tenantId, amoutQualifier,unRecIds);
		  
		  finalMap.put("recAmount", currencySymbol+" "+reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
		  finalMap.put("unRecAmount", currencyUnSymbol+" "+reconciliationResultService.getAmountInFormat(unRecAmountCount.get("totalAmount").toString(),currencyFormat));
	  }
	  else
	  {
		  log.info("Invalid Amount Qualifier: "+ amoutQualifier + ", Total Ids Size: "+ allOriginalIds.size() +", dv"+dv);
	  }
	  return finalMap;
  }
  
  public void unReconcileBasedOnReconRefs(List<String> reconRefs,RuleGroup accountingGroupIdTagged, Long tenantId, Long userId, String jobReference)
  {
 	 List<BigInteger> accountingViewIds = new ArrayList<BigInteger>();
 	 if(accountingGroupIdTagged!=null && reconRefs.size()>0)
 	 {
 	 		List<Long> accountingRuleIds = ruleGroupDetailsRepository.fetchRuleIdsByGroupIdAndTenantId(accountingGroupIdTagged.getId(),tenantId);
 	 		log.info("accountingRuleIds "+accountingRuleIds);
 			accountingViewIds = rulesRepository.fetchDistictSrcViewIdsByRuleId(accountingRuleIds);
 			log.info("accountingViewIds "+accountingViewIds);
 	 }
 	log.info("Time2: "+ new Date());
 	 Map<Long,Long> rowAndViewIds = new HashMap<Long,Long>();
 	 List<ReconciliationResult> reconResult = reconciliationResultRepository.fetchByReconReferenceIds(reconRefs);
 	 List<ReconciliationResult> unreconciledRecords = new ArrayList<ReconciliationResult>();
  	log.info("Time3: "+ new Date()); 	 
 	// log.info("reconResult "+reconResult);
 	 ZonedDateTime reconciledDate = ZonedDateTime.now();

 	 List<Long> originalIds = new ArrayList<Long>();
 	 List<Long> targetIds = new ArrayList<Long>();
 	 
 	 if(reconResult.size()>0)
 	 	{
 	 		for(ReconciliationResult row: reconResult)
 	 		{
 	 			row.setReconStatus("UNRECONCILED");
				row.setReconciledDate(reconciledDate);
				row.setReconJobReference(jobReference);
 				//log.info("row "+row.toString());
 				if(row.getOriginalViewId()!=null && accountingViewIds.contains(BigInteger.valueOf(row.getOriginalViewId())) )
 				{
 					log.info("in original ");
 					rowAndViewIds.put(row.getOriginalRowId(),row.getOriginalViewId());
 				}
 				else if(row.getTargetViewId()!=null && accountingViewIds.contains(BigInteger.valueOf(row.getTargetViewId())) )
 				{
 					log.info("in target ");
 					targetIds.add(row.getTargetRowId());
 				}
 				
 				if(row.getOriginalViewId()!=null)
 				{
 					originalIds.add(row.getOriginalRowId());
 				}
 				else if(row.getTargetViewId()!=null)
 				{
 					targetIds.add(row.getTargetRowId());
 				}
 				ReconciliationResult savedRecord = reconciliationResultRepository.saveAndFlush(row);
 				//unreconciledRecords.add(savedRecord);
 	 		}
 	 	}
  		log.info("Time4: "+ new Date());
 		log.info("rowAndViewIds "+rowAndViewIds);
 		Iterator<Long> iter = rowAndViewIds.keySet().iterator();
 		if(accountingGroupIdTagged != null)
 		{
 			while(iter.hasNext())
 	 		{
 	 			Long rowId = iter.next();
 	 			Long viewId = rowAndViewIds.get(rowId);
 	 			AccountingEvents existingRecord = accountingEventsRepository.findOneByAcctRuleGroupIdAndDataViewIdAndRowId(accountingGroupIdTagged.getId(),viewId,rowId);
 	 			if(existingRecord != null)
	 	 		{
	 	 				
	 	 			log.info("existingRecord"+existingRecord.toString());
	 	 			if(existingRecord.getAcctStatus().equalsIgnoreCase("PENDING"))
	 	 			{
	 	 				existingRecord.setEventType("UNRECONCILED");
	 	 				existingRecord.setEventTime(ZonedDateTime.now());
	 	 				accountingEventsRepository.save(existingRecord);
	 	 			}
	 	 			else if(existingRecord.getAcctStatus().equalsIgnoreCase("ACCOUNTED"))
	 	 			{
	 	 				existingRecord.setEventType("UNRECONCILED");
	 	 				existingRecord.setAcctStatus("NEED_REACCOUNTING");
	 					existingRecord.setEventTime(ZonedDateTime.now());
	 					existingRecord.setLastUpdatedDate(ZonedDateTime.now());
	// 					existingRecord.setLastUpdatedBy(userId);
	 	 				accountingEventsRepository.save(existingRecord);
	 	 			}
	 	 		}
 	 		}
 		}
 	 	log.info("Time5: "+ new Date());
/* 		if(unreconciledRecords.size()>0)
 		{
 			List<ReconciliationResult> unReconciledDataForBalaceTypeSource = new ArrayList<ReconciliationResult>();
 			List<ReconciliationResult> unReconciledDataForBalaceTypeTarget = new ArrayList<ReconciliationResult>(); 

 			Set<ReconciliationResult> unReconciledIdsSource = new HashSet<ReconciliationResult>();
 			Set<ReconciliationResult> unReconciledIdsTarget = new HashSet<ReconciliationResult>(); 
 			
 			for(ReconciliationResult record:unreconciledRecords)
 			{
 				if(record.getTargetViewId()==null || record.getTargetRowId()==null)
 				{
 					unReconciledDataForBalaceTypeSource.add(record);
 					
 					ReconciliationResult srcIdRec = new ReconciliationResult();
 					srcIdRec.setOriginalViewId(record.getOriginalViewId());
 					srcIdRec.setReconciliationRuleGroupId(record.getReconciliationRuleGroupId());
 					srcIdRec.setReconciliationRuleId(record.getReconciliationRuleId());
 					
 					unReconciledIdsSource.add(srcIdRec);
 				}
 				
 				if(record.getOriginalViewId()==null || record.getOriginalRowId()==null)
 				{
 					unReconciledDataForBalaceTypeTarget.add(record);
 					
 					ReconciliationResult tarIdRec = new ReconciliationResult();
 					tarIdRec.setTargetViewId(record.getTargetViewId());
 					tarIdRec.setReconciliationRuleGroupId(record.getReconciliationRuleGroupId());
 					tarIdRec.setReconciliationRuleId(record.getReconciliationRuleId());
 					
 					unReconciledIdsTarget.add(tarIdRec);
 				}
 			}
 		 	log.info("Time6: "+ new Date());
 			String dbUrl=env.getProperty("spring.datasource.url");
    		String[] parts=dbUrl.split("[\\s@&?$+-]+");
    		String schemaName=parts[0].split("/")[3];
    		
 			Map<Long,List<String>> viewColsMap = new HashMap<Long, List<String>>();
 			log.info("UnReconcileIds For Source: "+unReconciledIdsSource.size()+", unReconciledIdsSource: "+unReconciledIdsSource);
 			log.info("UnReconcileIds For Target: "+unReconciledIdsTarget.size()+", unReconciledIdsTarget: "+unReconciledIdsTarget);
 			for(ReconciliationResult viewId:unReconciledIdsSource)
			{
				Long id = viewId.getOriginalViewId();
				Long reconGroupId = viewId.getReconciliationRuleGroupId();
				Long reconRuleId = viewId.getReconciliationRuleId();
				
				HashMap<String, List<String>> groupBycolsAndQualifier = balanceTypeService.findGrpByColNamesAndQualifiersForDataView(id);
				String dataViewName = dataViewsRepository.findById(id).getDataViewName();
				List<String> groupBycols = groupBycolsAndQualifier.get("groupByCol");
				String amtQualifierCol = null;
				if(groupBycolsAndQualifier.get("AMOUNT")!=null)
				{
					amtQualifierCol = groupBycolsAndQualifier.get("AMOUNT").get(0);
				}
				else
				{
					continue;
				}
				if(groupBycols.size()==0)
				{
					continue;
				}
				viewColsMap.put(id, groupBycols );
				
				String subQuery = "SELECT original_row_id FROM "+schemaName+".t_reconciliation_result WHERE recon_job_reference = '"+jobReference+"' and "
						+ "reconciliation_rule_group_id = "+reconGroupId+" and reconciliation_rule_id = "+reconRuleId+" and original_view_id = "+id+
						" and recon_status = 'UNRECONCILED' and current_record_flag = true and original_row_id is not null";
				String inIds = "";
				for(Long unreconId:originalIds)
				{
					if(inIds.length()==0)
					{
						inIds = ""+unreconId;
					}
					else
					{
						inIds += ", "+unreconId;
					}
				}
				String groupBySQL = "SELECT SUM("+amtQualifierCol+") as type_amt";
				for(String col: groupBycols)
				{
					groupBySQL += ", "+col.toLowerCase(); 
				}
				
				groupBySQL += " FROM "+schemaName+".`"+dataViewName.toLowerCase()+ "` WHERE scrIds in ( "+inIds+" ) ";
				groupBySQL += " GROUP BY ";
				
				for(String col: groupBycols)
				{
					groupBySQL += col.toLowerCase()+", "; 
				}
				
				groupBySQL = groupBySQL.trim();
				if(groupBySQL.endsWith(","))
				{
					groupBySQL = groupBySQL.substring(0,groupBySQL.length()-1);
				}
				
				List<BalanceType> balanceTypeForProcessedRecords = new ArrayList<BalanceType>();
				if(inIds.length()>0)
				{
					balanceTypeForProcessedRecords = balanceTypeService.fetchProcessedRecords(groupBySQL,groupBycols,id, tenantId, userId, "RECONCILIATION", reconGroupId, reconRuleId,"SOURCE");
				}
				
				List<BalanceType> existingBalanceTypeRecords = balanceTypeService.fetchExistingBalanceTypeRecords("RECONCILIATION", groupBycols, id, tenantId, reconGroupId, reconRuleId);
				List<BalanceType> derivedBalanceTypeRecords = balanceTypeService.deriveOpeningAndClosingBalance(existingBalanceTypeRecords,balanceTypeForProcessedRecords);
				
				balanceTypeRepository.save(derivedBalanceTypeRecords);
				
			}
 		 	log.info("Time7: "+ new Date());
 			for(ReconciliationResult viewId:unReconciledIdsTarget)
			{
 				Long id = viewId.getTargetViewId();
				Long reconGroupId = viewId.getReconciliationRuleGroupId();
				Long reconRuleId = viewId.getReconciliationRuleId();
				
				HashMap<String, List<String>> groupBycolsAndQualifier = balanceTypeService.findGrpByColNamesAndQualifiersForDataView(id);
				String dataViewName = dataViewsRepository.findById(id).getDataViewName();
				List<String> groupBycols = groupBycolsAndQualifier.get("groupByCol");
				String amtQualifierCol = null;
				if(groupBycolsAndQualifier.get("AMOUNT")!=null)
				{
					amtQualifierCol = groupBycolsAndQualifier.get("AMOUNT").get(0);
				}
				else
				{
					continue;
				}
				if(groupBycols.size()==0)
				{
					continue;
				}
				viewColsMap.put(id, groupBycols );
				
				String subQuery = "SELECT target_row_id FROM "+schemaName+".t_reconciliation_result WHERE recon_job_reference = '"+jobReference+"' and "
						+ "reconciliation_rule_group_id = "+reconGroupId+" and reconciliation_rule_id = "+reconRuleId+" and target_view_id = "+id+
						" and recon_status = 'UNRECONCILED' and current_record_flag = true and target_row_id is not null";
				String inIds = "";
				
				for(Long unreconId:targetIds)
				{
					if(inIds.length()==0)
					{
						inIds = ""+unreconId;
					}
					else
					{
						inIds += ", "+unreconId;
					}
				}
				
				String groupBySQL = "SELECT SUM("+amtQualifierCol+") as type_amt";
				for(String col: groupBycols)
				{
					groupBySQL += ", "+col.toLowerCase(); 
				}
				
				groupBySQL += " FROM "+schemaName+".`"+dataViewName.toLowerCase()+ "` WHERE scrIds in ( "+inIds+" ) ";
				groupBySQL += " GROUP BY ";
				
				for(String col: groupBycols)
				{
					groupBySQL += col.toLowerCase()+", "; 
				}
				
				groupBySQL = groupBySQL.trim();
				if(groupBySQL.endsWith(","))
				{
					groupBySQL = groupBySQL.substring(0,groupBySQL.length()-1);
				}
				
				List<BalanceType> balanceTypeForProcessedRecords = new ArrayList<BalanceType>();
				if(inIds.length()>0)
				{
					balanceTypeForProcessedRecords = balanceTypeService.fetchProcessedRecords(groupBySQL,groupBycols,id, tenantId, userId, "RECONCILIATION", reconGroupId, reconRuleId, "TARGET");
				}
					
				List<BalanceType> existingBalanceTypeRecords = balanceTypeService.fetchExistingBalanceTypeRecords("RECONCILIATION", groupBycols, id, tenantId, reconGroupId, reconRuleId);
				List<BalanceType> derivedBalanceTypeRecords = balanceTypeService.deriveOpeningAndClosingBalance(existingBalanceTypeRecords,balanceTypeForProcessedRecords);
				
				balanceTypeRepository.save(derivedBalanceTypeRecords);
			}
 		 	log.info("Time8: "+ new Date());
 		}
*/  }

/**
   * Author: Shiva
   * Purpose: Posting reconciliation counts in t_app_module_summary table **/
  public void postAppModuleSummaryTable(Long groupId, Long viewId, Long ruleId, Long userId, Long typeCount, String type, String sourceOrTarget)
  {
	  log.info("Posting "+sourceOrTarget+" count in t_app_module_summary table for the group id: "+groupId+", view id: "+ viewId+", rule id: "+ ruleId+", type: "+ type);
	  AppModuleSummary amsSource = appModuleSummaryRepository.findByModuleAndRuleGroupIdAndRuleIdAndTypeAndViewId(type, groupId, ruleId, sourceOrTarget, viewId);
	  if(amsSource != null)
	  {
		  amsSource.setLastUpdatedBy(userId);
		  amsSource.setLastUpdatedDate(ZonedDateTime.now());
		  amsSource.setTypeCount(amsSource.getTypeCount()-typeCount);
		  AppModuleSummary amsSrcUpdate = appModuleSummaryRepository.save(amsSource);
	  }
	  else
	  {
		  AppModuleSummary amsCreate = new AppModuleSummary();
		  amsCreate.setCreatedBy(userId);
		  amsCreate.setCreatedDate(ZonedDateTime.now());
		  amsCreate.setLastUpdatedBy(userId);
		  amsCreate.setLastUpdatedDate(ZonedDateTime.now());
		  amsCreate.setModule(type);
		  amsCreate.setRuleGroupId(groupId);
		  amsCreate.setRuleId(ruleId);
		  amsCreate.setType(sourceOrTarget);
		  amsCreate.setTypeCount(typeCount);
		  amsCreate.setViewId(viewId);
		  AppModuleSummary amsSrcCreate = appModuleSummaryRepository.save(amsCreate);
	  }
  }
  public String convertDatsToString(List<String> dates)
  {
	  String datesAsString = "";
	  for(int i=0; i<dates.size(); i++)
	  {
		  if(i == dates.size()-1)
		  {
			  datesAsString = datesAsString + dates.get(i).trim(); 
		  }
		  else
		  {
			  datesAsString = datesAsString + dates.get(i).trim() + "|";			  
		  }
	  }
	  return datesAsString;
  }
  public HashMap getTotalByPeriodFactorForDays(Long viewId, String periodFactor, String rangeFrom, String rangeTo, List<String> transDates) throws ClassNotFoundException
  {
	  HashMap finalMap = new HashMap();
	  List<BigInteger> totalIds = new ArrayList<BigInteger>();
	  String status = "";
	  List<String> reasons = new ArrayList<String>();
	  String transDateQualifier = getTransDateQualifier(BigInteger.valueOf(viewId), "TRANSDATE");
	  if("dateQualifier".equalsIgnoreCase(periodFactor))
	  {
		  log.info("with date qualifier");
		  
		  log.info("Trans Date Qualifier for Data View Id: "+transDateQualifier);
		  if(transDateQualifier.length()>0)
		  {
			  /*List<BigInteger> totalOriginalIds = getOriginalIdsByTransDates(viewId, rangeFrom, rangeTo, transDateQualifier, transDates);*/
			  try{
				  totalIds = getOriginalIdsForDateQualifier(viewId, rangeFrom, rangeTo, transDateQualifier, transDates);
				  status = "Success";
			  }catch(Exception e)
			  {
				  status = "Failed";
				  reasons.add("Un able to fetch the total ids for the view id: "+ viewId+", trans date qualifier: "+ transDateQualifier+", range from: "+ rangeFrom+", range to: "+ rangeTo);
			  }
		  }
		  else
		  {
			  status = "Failed";
			  reasons.add("No trans date qualifier found for the view id: "+viewId);
			  log.info("No trans date qualifier found for the view id: "+viewId);
		  }
	  }
	  else if("fileDate".equalsIgnoreCase(periodFactor))
	  {
		  log.info("with file date");
		  try{
			  transDateQualifier = "fileDate";
			  totalIds = getOriginalIdsByTransDates(viewId, rangeFrom, rangeTo, transDateQualifier, transDates);
			  status = "Success";
		  }catch(Exception e)
		  {
			  status = "Failed";
			  reasons.add("Un able to fetch the total ids for the view id: "+ viewId+" between range: "+rangeFrom+"-"+rangeTo);
		  }
	  }
	  finalMap.put("status", status);
	  finalMap.put("reasons", reasons);
	  finalMap.put("totalIds", totalIds);
	  return finalMap;
  }
  
  public HashMap getTotalByPeriodFactor(Long viewId, String periodFactor, String rangeFrom, String rangeTo) throws ClassNotFoundException
  {
	  HashMap finalMap = new HashMap();
	  List<BigInteger> totalIds = new ArrayList<BigInteger>();
	  String status = "";
	  List<String> reasons = new ArrayList<String>();
	  if("dateQualifier".equalsIgnoreCase(periodFactor))
	  {
		  log.info("with date qualifier");
		  String transDateQualifier = getTransDateQualifier(BigInteger.valueOf(viewId), "TRANSDATE");
		  log.info("Trans Date Qualifier for Data View Id: "+transDateQualifier);
		  if(transDateQualifier.length()>0)
		  {
			  /*List<BigInteger> totalOriginalIds = getOriginalIdsByTransDates(viewId, rangeFrom, rangeTo, transDateQualifier, transDates);*/
			  try{
				  totalIds = getOriginalIdsByDateQualifier(viewId, transDateQualifier, rangeFrom, rangeTo);
				  status = "Success";
			  }catch(Exception e)
			  {
				  status = "Failed";
				  reasons.add("Un able to fetch the total ids for the view id: "+ viewId+", trans date qualifier: "+ transDateQualifier+", range from: "+ rangeFrom+", range to: "+ rangeTo);
			  }
		  }
		  else
		  {
			  status = "Failed";
			  reasons.add("No trans date qualifier found for the view id: "+viewId);
			  log.info("No trans date qualifier found for the view id: "+viewId);
		  }
	  }
	  else if("fileDate".equalsIgnoreCase(periodFactor))
	  {
		  log.info("with file date");
		  try{
			  totalIds = getViewOriginalIds(viewId, rangeFrom, rangeTo, "");
			  status = "Success";
		  }catch(Exception e)
		  {
			  status = "Failed";
			  reasons.add("Un able to fetch the total ids for the view id: "+ viewId+" between range: "+rangeFrom+"-"+rangeTo);
		  }
	  }
	  finalMap.put("status", status);
	  finalMap.put("reasons", reasons);
	  finalMap.put("totalIds", totalIds);
	  return finalMap;
  }
  
/*  public List<String> getCurrencyCodes(List<BigInteger> ids, Long viewId)
  {
	  List<String> currencyCodes = new ArrayList<String>();
	  
	  List<String> currenciesRec = getDistColumnValues(ids,currencyCodeColName,dv.getDataViewName());
	  return currencyCodes;
  }*/
  
  public HashMap getRecUnRecAmounts(ReconUnReconAmountsDTO params, Long viewId, String sourceOrTarget, Long tenantId) throws ClassNotFoundException
  {
	  log.info("Fetching rec un-rec amounts for the group id: "+params.getRuleGroupId()+", tenant id: "+tenantId+", view id: "+viewId);
	  HashMap finalMap = new HashMap();
	  List<BigInteger> totalIds = new ArrayList<BigInteger>();
	  List<BigInteger> recIds = new ArrayList<BigInteger>();
	  List<BigInteger> unRecIds = new ArrayList<BigInteger>();
	  List<BigInteger> suggestedIds = new ArrayList<BigInteger>();
	  
	  List<String> recCurrencies = new ArrayList<String>();
	  List<String> unRecCurrencies = new ArrayList<String>();
	  List<String> suggestedCurrencies = new ArrayList<String>();
	  String status = "";
	  List<String> reasons = new ArrayList<String>();
	  
	  String totalAmount = "0.0";
	  String recAmount = "0.0";
	  String unRecAmount = "0.0";
	  String suggestedAmount = "0.0";
	  DataViews dv = dataViewsRepository.findOne(viewId);
	  if(dv != null)
	  {
		  String amountQualifier = getTransDateQualifier(BigInteger.valueOf(viewId), "AMOUNT");
		  String currencyCodeColName = getTransDateQualifier(BigInteger.valueOf(viewId), "CURRENCYCODE");
		  if(amountQualifier.length()>0 && currencyCodeColName.length()>0)
		  {
			  // Fetching total ids based on date qualifier or file date.
			  HashMap totalIdsMap = getTotalByPeriodFactor(viewId, params.getPeriodFactor(), params.getRangeFrom(), params.getRangeTo());
			  if("Success".equalsIgnoreCase(totalIdsMap.get("status").toString()))
			  {
				  totalIds = (List<BigInteger>) totalIdsMap.get("totalIds");
				  log.info("Total original ids size: "+ totalIds.size());
				  // Fetching reconciled, un-reconciled amounts
				  if(totalIds.size()>0)
				  {
					  try{
						  totalAmount = getAmountSumByIds(totalIds, amountQualifier, BigInteger.valueOf(viewId));
						  if("source".equalsIgnoreCase(sourceOrTarget))
						  {
							  log.info("in source");
							  recIds = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForSource(tenantId, params.getRuleGroupId(), totalIds, viewId);
							  suggestedIds = reconciliationDuplicateResultRepository.fetchReconciledIdswithStatusUnreconciledForSource(tenantId, params.getRuleGroupId(), totalIds, viewId);
						  }
						  else if("target".equalsIgnoreCase(sourceOrTarget))
						  {
							  log.info("in target");
							  recIds = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForTarget(tenantId, params.getRuleGroupId(), totalIds, viewId);
							  suggestedIds = reconciliationDuplicateResultRepository.fetchReconciledIdswithStatusUnreconciledForTarget(tenantId, params.getRuleGroupId(), totalIds, viewId);
						  }
						  log.info("reconciled ids size: "+ recIds.size());
						  recAmount = getAmountSumByIds(recIds, amountQualifier, BigInteger.valueOf(viewId));
						  recCurrencies = getDistColumnValues(recIds,currencyCodeColName,dv.getDataViewName());	// Currencies List for Reconciled IDs
						  totalIds.removeAll(recIds);	// removing reconciled ids
						  totalIds.removeAll(suggestedIds);	// removing suggested ids
						  unRecAmount = getAmountSumByIds(totalIds, amountQualifier, BigInteger.valueOf(viewId));
						  unRecCurrencies = getDistColumnValues(totalIds,currencyCodeColName,dv.getDataViewName()); // Currencies List for UnReconciled IDs
						  suggestedAmount = getAmountSumByIds(suggestedIds, amountQualifier, BigInteger.valueOf(viewId));
						  suggestedCurrencies = getDistColumnValues(suggestedIds,currencyCodeColName,dv.getDataViewName());	// Currencies List for Reconciled IDs
						  log.info("un reconciled ids size: "+ totalIds.size());
						  status = "Success";
					  }
					  catch(Exception e)
					  {
						  status = "Failed";
						  reasons.add("Error while fetching reconciled data for the tenant id: "+tenantId+", rule group id: "+params.getRuleGroupId()+" view id: "+viewId);
					  }
				  }
			  }
		  }
		  else
		  {
			  status = "Failed";
			  reasons.add("No Amount or Currency Code Qualifier found for the view id: " + viewId);
			  log.info("No Amount or Currency Code Qualifier found for the view id: " + viewId);
		  }
	  }
	  else 
	  {
		  status = "Failed";
		  reasons.add("Data view doen't exist. View id: "+ viewId);
	  }
	  
	  finalMap.put("totalAmount", totalAmount);
	  finalMap.put("recAmount", recAmount);
	  finalMap.put("unRecAmount", unRecAmount);
	  finalMap.put("suggestedAmount", suggestedAmount);
	  finalMap.put("recCurrency", recCurrencies);
	  finalMap.put("unRecCurrency", unRecCurrencies);
	  finalMap.put("suggestedCurrency", suggestedCurrencies);
	  finalMap.put("status", status);
	  finalMap.put("reasons", reasons);
	  
	  return finalMap;
  }
  
  public HashMap getRecUnRecIdsForSrcNTargetForManualBatch(ReconCountNAmountsDTO params, List<String> manualBatches) throws ClassNotFoundException, SQLException, ParseException
  {
	  Long tenantId = params.getTenantId();
	  Long groupId = params.getRuleGroupId();
	  Long sViewId = params.getsViewId();
	  Long tViewId = params.gettViewId();
	  HashMap finalMap = new HashMap();
	  log.info("Fetching Recon Un-Recon counts and amounts for Manual Batch the tenant id: "+ tenantId+", group id: "+ groupId+", source view id: "+sViewId+", target view id "+ tViewId);
	  List<HashMap> groupedList = new ArrayList<HashMap>();
	  List<BigInteger> sTotalIds = new ArrayList<BigInteger>();
	  List<BigInteger> tTotalIds = new ArrayList<BigInteger>();
	  List<BigInteger> sRecIds = new ArrayList<BigInteger>();
	  List<BigInteger> tRecIds = new ArrayList<BigInteger>();
	  DataViews sdv = dataViewsRepository.findOne(params.getsViewId());
	  DataViews tdv = dataViewsRepository.findOne(params.gettViewId());
	  String sCurrencyCode = getTransDateQualifier(BigInteger.valueOf(params.getsViewId()), "CURRENCYCODE");
	  String tCurrencyCode = getTransDateQualifier(BigInteger.valueOf(params.gettViewId()), "CURRENCYCODE");
	  
	  String sAmountQualifier = getTransDateQualifier(BigInteger.valueOf(params.getsViewId()), "AMOUNT");
	  String tAmountQualifier = getTransDateQualifier(BigInteger.valueOf(params.gettViewId()), "AMOUNT");
	  log.info("sCurrencyCode: "+sCurrencyCode+", tCurrencyCode: "+tCurrencyCode+", sAmountQualifier: "+sAmountQualifier+". "+tAmountQualifier);
	  Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	  String currencyFormat = props.getProperty("currencyFormat");
	   
	  if(sdv != null && tdv != null)
	  {
		  try{
			  HashMap sTotalIdsMap = getTotalByPeriodFactor(params.getsViewId(), params.getPeriodFactor(), params.getRangeFrom(), params.getRangeTo());
			  HashMap tTotalIdsMap = getTotalByPeriodFactor(params.gettViewId(), params.getPeriodFactor(), params.getRangeFrom(), params.getRangeTo());
			  if("Success".equalsIgnoreCase(sTotalIdsMap.get("status").toString()) && "Success".equalsIgnoreCase(tTotalIdsMap.get("status").toString()))
			  {
				  sTotalIds = (List<BigInteger>) sTotalIdsMap.get("totalIds");
				  tTotalIds = (List<BigInteger>) tTotalIdsMap.get("totalIds");
			  }
			  else
			  {
				  log.info("Error while fetching total ids for the source view : "+params.getsViewId()+", or target view: "+params.gettViewId());
			  } 
		  }
		  catch(Exception e)
		  {
			  log.info("Error while fetching total ids for the source view : "+params.getsViewId()+", or target view: "+params.gettViewId());
		  }
		  log.info("sTotalIds.size(): "+sTotalIds.size()+", tTotalIds.size(): "+tTotalIds.size());
		  if(sTotalIds.size()>0 && tTotalIds.size()>0)
		  {
			  log.info("Manual Batches: "+manualBatches);
				  HashMap recMap = new HashMap();
				  recMap.put("name", "Manual");
				  sRecIds = reconciliationResultRepository.fetchReconciledIdswithJobReferencesForSource(tenantId, groupId, sTotalIds, manualBatches, params.getsViewId());
				  tRecIds = reconciliationResultRepository.fetchReconciledIdswithJobReferencesForTarget(tenantId, groupId, tTotalIds, manualBatches, params.gettViewId());
				  log.info("Batch: Manual , sRecIds.size(): "+sRecIds.size()+", tRecIds: "+tRecIds.size());
			  		String sRecCurrencySymbol = "";
			  		List<String> sRecCurrencies = getDistColumnValues(sRecIds,sCurrencyCode,sdv.getDataViewName());
			  		if(sRecCurrencies.size()==1)
			  		{
			  			sRecCurrencySymbol = sRecCurrencySymbol+getCurrencySymbol(sRecCurrencies.get(0));
			  		}
			  		else if(sRecCurrencies.size()>1)
			  		{
			  			sRecCurrencySymbol = sRecCurrencySymbol+"*";
			  		}
			  		
			  		String tRecCurrencySymbol = "";
			  		List<String> tRecCurrencies = getDistColumnValues(tRecIds,tCurrencyCode,tdv.getDataViewName());
			  		if(tRecCurrencies.size()==1)
			  		{
			  			tRecCurrencySymbol = tRecCurrencySymbol+getCurrencySymbol(tRecCurrencies.get(0));
			  		}
			  		else if(tRecCurrencies.size()>1)
			  		{
			  			tRecCurrencySymbol = tRecCurrencySymbol+"*";
			  		}
			  		
					HashMap sRecCountNAmount = reconciliationResultService.getCountNAmountForDVId(BigInteger.valueOf(params.getsViewId()), tenantId, sAmountQualifier,sRecIds);
					recMap.put("sAmount", sRecCurrencySymbol+" "+reconciliationResultService.getAmountInFormat(sRecCountNAmount.get("totalAmount").toString(),currencyFormat));
					recMap.put("sCount", sRecCountNAmount.get("totalCount"));
					recMap.put("dsCount", sRecIds.size());
					recMap.put("sCurrency", sRecCurrencySymbol);
					recMap.put("sAmountValue", sRecCountNAmount.get("totalAmount"));
					
					HashMap tRecCountNAmount = reconciliationResultService.getCountNAmountForDVId(BigInteger.valueOf(params.gettViewId()), tenantId, tAmountQualifier,tRecIds);
					recMap.put("tAmount", tRecCurrencySymbol+" "+reconciliationResultService.getAmountInFormat(tRecCountNAmount.get("totalAmount").toString(),currencyFormat));
					recMap.put("tCount", tRecCountNAmount.get("totalCount"));
					recMap.put("dtCount", tRecIds.size());
					recMap.put("tCurrency", tRecCurrencySymbol);
					recMap.put("tAmountValue", tRecCountNAmount.get("totalAmount"));
					log.info("Manual: map: "+recMap);
					groupedList.add(recMap);
		  }
		  else
		  {
			  log.info("No records fournd for the source view id: "+params.getsViewId()+", or target view id: "+params.gettViewId());
		  }
	  }
	  else
	  {
		  log.info("Source view i: "+ params.getsViewId()+" or target view id: "+ params.gettViewId()+" doesn't exist");
	  }
	  finalMap.put("summary", groupedList);
	  finalMap.put("status", "");
	  log.info("Manual Final Map Size: "+groupedList.size());
	  return finalMap;
  }

  //getUnReconIdsForDays
  public HashMap getRecUnRecIdsForSrcNTargetForBatch(ReconCountNAmountsDTO params, List<String> batches) throws ClassNotFoundException, SQLException, ParseException
  {	
	  Long tenantId = params.getTenantId();
	  Long groupId = params.getRuleGroupId();
	  Long sViewId = params.getsViewId();
	  Long tViewId = params.gettViewId();
	  HashMap finalMap = new HashMap();
	  log.info("Fetching Recon Un-Recon counts and amounts for the tenant id: "+ tenantId+", group id: "+ groupId+", source view id: "+sViewId+", target view id "+ tViewId);
	  List<HashMap> groupedList = new ArrayList<HashMap>();
	  List<BigInteger> sTotalIds = new ArrayList<BigInteger>();
	  List<BigInteger> tTotalIds = new ArrayList<BigInteger>();
	  List<BigInteger> sRecIds = new ArrayList<BigInteger>();
	  List<BigInteger> tRecIds = new ArrayList<BigInteger>();
	  DataViews sdv = dataViewsRepository.findOne(params.getsViewId());
	  DataViews tdv = dataViewsRepository.findOne(params.gettViewId());
	  String sCurrencyCode = getTransDateQualifier(BigInteger.valueOf(params.getsViewId()), "CURRENCYCODE");
	  String tCurrencyCode = getTransDateQualifier(BigInteger.valueOf(params.gettViewId()), "CURRENCYCODE");
	  
	  String sAmountQualifier = getTransDateQualifier(BigInteger.valueOf(params.getsViewId()), "AMOUNT");
	  String tAmountQualifier = getTransDateQualifier(BigInteger.valueOf(params.gettViewId()), "AMOUNT");
	  log.info("sCurrencyCode: "+sCurrencyCode+", tCurrencyCode: "+tCurrencyCode+", sAmountQualifier: "+sAmountQualifier+". "+tAmountQualifier);
	  Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	  String currencyFormat = props.getProperty("currencyFormat");
	   
	  if(sdv != null && tdv != null)
	  {
		  try{
			  HashMap sTotalIdsMap = getTotalByPeriodFactor(params.getsViewId(), params.getPeriodFactor(), params.getRangeFrom(), params.getRangeTo());
			  HashMap tTotalIdsMap = getTotalByPeriodFactor(params.gettViewId(), params.getPeriodFactor(), params.getRangeFrom(), params.getRangeTo());
			  if("Success".equalsIgnoreCase(sTotalIdsMap.get("status").toString()) && "Success".equalsIgnoreCase(tTotalIdsMap.get("status").toString()))
			  {
				  sTotalIds = (List<BigInteger>) sTotalIdsMap.get("totalIds");
				  tTotalIds = (List<BigInteger>) tTotalIdsMap.get("totalIds");
			  }
			  else
			  {
				  log.info("Error while fetching total ids for the source view : "+params.getsViewId()+", or target view: "+params.gettViewId());
			  } 
		  }
		  catch(Exception e)
		  {
			  log.info("Error while fetching total ids for the source view : "+params.getsViewId()+", or target view: "+params.gettViewId());
		  }
		  log.info("sTotalIds.size(): "+sTotalIds.size()+", tTotalIds.size(): "+tTotalIds.size());
		  if(sTotalIds.size()>0 && tTotalIds.size()>0)
		  {
			  for(String batch : batches)
			  {
				  HashMap recMap = new HashMap();
				  recMap.put("name", batch);
				  sRecIds = reconciliationResultRepository.fetchReconciledIdswithJobReferenceForSource(tenantId, groupId, sTotalIds, batch, params.getsViewId());
				  tRecIds = reconciliationResultRepository.fetchReconciledIdswithJobReferenceForTarget(tenantId, groupId, tTotalIds, batch, params.gettViewId());
				  log.info("Batch: "+batch+", sRecIds.size(): "+sRecIds.size()+", tRecIds: "+tRecIds.size());
			  		String sRecCurrencySymbol = "";
			  		List<String> sRecCurrencies = getDistColumnValues(sRecIds,sCurrencyCode,sdv.getDataViewName());
			  		if(sRecCurrencies.size()==1)
			  		{
			  			sRecCurrencySymbol = sRecCurrencySymbol+getCurrencySymbol(sRecCurrencies.get(0));
			  		}
			  		else if(sRecCurrencies.size()>1)
			  		{
			  			sRecCurrencySymbol = sRecCurrencySymbol+"*";
			  		}
			  		
			  		String tRecCurrencySymbol = "";
			  		List<String> tRecCurrencies = getDistColumnValues(tRecIds,tCurrencyCode,tdv.getDataViewName());
			  		if(tRecCurrencies.size()==1)
			  		{
			  			tRecCurrencySymbol = tRecCurrencySymbol+getCurrencySymbol(tRecCurrencies.get(0));
			  		}
			  		else if(tRecCurrencies.size()>1)
			  		{
			  			tRecCurrencySymbol = tRecCurrencySymbol+"*";
			  		}
			  		
					HashMap sRecCountNAmount = reconciliationResultService.getCountNAmountForDVId(BigInteger.valueOf(params.getsViewId()), tenantId, sAmountQualifier,sRecIds);
					recMap.put("sAmount", sRecCurrencySymbol+" "+reconciliationResultService.getAmountInFormat(sRecCountNAmount.get("totalAmount").toString(),currencyFormat));
					recMap.put("sCount", sRecCountNAmount.get("totalCount"));
					recMap.put("dsCount", sRecIds.size());
					recMap.put("sCurrency", sRecCurrencySymbol);
					recMap.put("sAmountValue", sRecCountNAmount.get("totalAmount"));
					
					HashMap tRecCountNAmount = reconciliationResultService.getCountNAmountForDVId(BigInteger.valueOf(params.gettViewId()), tenantId, tAmountQualifier,tRecIds);
					recMap.put("tAmount", tRecCurrencySymbol+" "+reconciliationResultService.getAmountInFormat(tRecCountNAmount.get("totalAmount").toString(),currencyFormat));
					recMap.put("tCount", tRecCountNAmount.get("totalCount"));
					recMap.put("dtCount", tRecIds.size());
					recMap.put("tCurrency", tRecCurrencySymbol);
					recMap.put("tAmountValue", tRecCountNAmount.get("totalAmount"));
					log.info("Batch: "+ batch+", map: "+recMap);
					groupedList.add(recMap);
			  	}
		  }
		  else
		  {
			  log.info("No records fournd for the source view id: "+params.getsViewId()+", or target view id: "+params.gettViewId());
		  }
	  }
	  else
	  {
		  log.info("Source view i: "+ params.getsViewId()+" or target view id: "+ params.gettViewId()+" doesn't exist");
	  }
	  finalMap.put("summary", groupedList);
	  finalMap.put("status", "");
	  log.info("Final Map Size: "+groupedList.size());
	  return finalMap;
  }
  
  public HashMap getRecUnRecIdsForSrcNTarget(ReconCountNAmountsDTO params, List<BigInteger> ruleIds) throws ClassNotFoundException, SQLException, ParseException
  {
	  Long tenantId = params.getTenantId();
	  Long groupId = params.getRuleGroupId();
	  Long sViewId = params.getsViewId();
	  Long tViewId = params.gettViewId();
	  HashMap finalMap = new HashMap();
	  log.info("Fetching Recon Un-Recon counts and amounts for the tenant id: "+ tenantId+", group id: "+ groupId+", source view id: "+sViewId+", target view id "+ tViewId);
	  List<HashMap> groupedList = new ArrayList<HashMap>();
	  List<BigInteger> sTotalIds = new ArrayList<BigInteger>();
	  List<BigInteger> tTotalIds = new ArrayList<BigInteger>();
	  List<BigInteger> sRecIds = new ArrayList<BigInteger>();
	  List<BigInteger> tRecIds = new ArrayList<BigInteger>();
	  DataViews sdv = dataViewsRepository.findOne(params.getsViewId());
	  DataViews tdv = dataViewsRepository.findOne(params.gettViewId());
	  String sCurrencyCode = getTransDateQualifier(BigInteger.valueOf(params.getsViewId()), "CURRENCYCODE");
	  String tCurrencyCode = getTransDateQualifier(BigInteger.valueOf(params.gettViewId()), "CURRENCYCODE");
	  
	  String sAmountQualifier = getTransDateQualifier(BigInteger.valueOf(params.getsViewId()), "AMOUNT");
	  String tAmountQualifier = getTransDateQualifier(BigInteger.valueOf(params.gettViewId()), "AMOUNT");
	  
	  Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	  String currencyFormat = props.getProperty("currencyFormat");
	   
	  if(sdv != null && tdv != null)
	  {
		  try{
			  HashMap sTotalIdsMap = getTotalByPeriodFactor(params.getsViewId(), params.getPeriodFactor(), params.getRangeFrom(), params.getRangeTo());
			  HashMap tTotalIdsMap = getTotalByPeriodFactor(params.gettViewId(), params.getPeriodFactor(), params.getRangeFrom(), params.getRangeTo());
			  if("Success".equalsIgnoreCase(sTotalIdsMap.get("status").toString()) && "Success".equalsIgnoreCase(tTotalIdsMap.get("status").toString()))
			  {
				  sTotalIds = (List<BigInteger>) sTotalIdsMap.get("totalIds");
				  tTotalIds = (List<BigInteger>) tTotalIdsMap.get("totalIds");
			  }
			  else
			  {
				  log.info("Error while fetching total ids for the source view : "+params.getsViewId()+", or target view: "+params.gettViewId());
			  } 
		  }
		  catch(Exception e)
		  {
			  log.info("Error while fetching total ids for the source view : "+params.getsViewId()+", or target view: "+params.gettViewId());
		  }
		  if(sTotalIds.size()>0 && tTotalIds.size()>0)
		  {
			 // log.info("RuleIDs:::::::: "+ ruleIds);
			  for(BigInteger ruleId : ruleIds)
			  {
				//  log.info("RuleID::::::::::::: "+ ruleId);
				  HashMap recMap = new HashMap();
				  if(ruleId == BigInteger.valueOf(0L))
				  {
					  recMap.put("id", ruleId);
					  recMap.put("name", "Manual");
				  }
				  else
				  {
					  Rules rule = rulesRepository.findOne(ruleId.longValue());
					  if(rule != null)
					  {
						  recMap.put("id", ruleId);
						  recMap.put("name", rule.getRuleCode());
					  }
				  }

				  List<Long> ruleIdSingle = new ArrayList<Long>();
				  ruleIdSingle.add(ruleId.longValue());
				  sRecIds = reconciliationResultRepository.fetchReconciledIdsWithOutJobRefWithStatusReconciledForSource(tenantId, ruleIdSingle, groupId, sTotalIds,params.getsViewId());
				  tRecIds = reconciliationResultRepository.fetchReconciledIdsWithOutJobRefWithStatusReconciledForTarget(tenantId, ruleIdSingle, groupId, tTotalIds, params.gettViewId());
			
			  		String sRecCurrencySymbol = "";
			  		List<String> sRecCurrencies = getDistColumnValues(sRecIds,sCurrencyCode,sdv.getDataViewName());
			  		if(sRecCurrencies.size()==1)
			  		{
			  			sRecCurrencySymbol = sRecCurrencySymbol+getCurrencySymbol(sRecCurrencies.get(0));
			  		}
			  		else if(sRecCurrencies.size()>1)
			  		{
			  			sRecCurrencySymbol = sRecCurrencySymbol+"*";
			  		}
			  		
			  		String tRecCurrencySymbol = "";
			  		List<String> tRecCurrencies = getDistColumnValues(tRecIds,tCurrencyCode,tdv.getDataViewName());
			  		if(tRecCurrencies.size()==1)
			  		{
			  			tRecCurrencySymbol = tRecCurrencySymbol+getCurrencySymbol(tRecCurrencies.get(0));
			  		}
			  		else if(tRecCurrencies.size()>1)
			  		{
			  			tRecCurrencySymbol = tRecCurrencySymbol+"*";
			  		}
			  		
					HashMap sRecCountNAmount = reconciliationResultService.getCountNAmountForDVId(BigInteger.valueOf(params.getsViewId()), tenantId, sAmountQualifier,sRecIds);
					recMap.put("sAmount", sRecCurrencySymbol+" "+reconciliationResultService.getAmountInFormat(sRecCountNAmount.get("totalAmount").toString(),currencyFormat));
					recMap.put("sCount", sRecCountNAmount.get("totalCount"));
					recMap.put("dsCount", sRecIds.size());
					recMap.put("sCurrency", sRecCurrencySymbol);
					recMap.put("sAmountValue", sRecCountNAmount.get("totalAmount"));
					
					HashMap tRecCountNAmount = reconciliationResultService.getCountNAmountForDVId(BigInteger.valueOf(params.gettViewId()), tenantId, tAmountQualifier,tRecIds);
					recMap.put("tAmount", tRecCurrencySymbol+" "+reconciliationResultService.getAmountInFormat(tRecCountNAmount.get("totalAmount").toString(),currencyFormat));
					recMap.put("tCount", tRecCountNAmount.get("totalCount"));
					recMap.put("dtCount", tRecIds.size());
					recMap.put("tCurrency", tRecIds.size());
					recMap.put("tAmountValue", tRecCountNAmount.get("totalAmount"));

					groupedList.add(recMap);
					//log.info("Map::::: "+ recMap);
			  	}
		  }
		  else
		  {
			  log.info("No records fournd for the source view id: "+params.getsViewId()+", or target view id: "+params.gettViewId());
		  }
	  }
	  else
	  {
		  log.info("Source view i: "+ params.getsViewId()+" or target view id: "+ params.gettViewId()+" doesn't exist");
	  }
	  finalMap.put("summary", groupedList);
	  finalMap.put("status", "");
	  return finalMap;
  }
  
  public String getCurrencySymbol(Set<String> codesList) throws ParseException
  {
	  String currencySymbol = "";
	  if(codesList.size() == 1)
	  {
		  currencySymbol = currencySymbol+getCurrencySymbol(codesList.toArray()[codesList.size()-1].toString());
	  }
	  else if(codesList.size()>1)
	  {
		  currencySymbol = currencySymbol+"*";
	  }
	  return currencySymbol;
  }
  
  public HashMap getRulesRecIdsForSource(Long viewId, String periodFacotr, String rangeFrom, String rangeTo, List<Long> ruleIds, Long tenantId, Long groupId, String typeOfRecData)
  {
	  HashMap finalMap = new HashMap();
	  List<BigInteger> totalIds = new ArrayList<BigInteger>();
	  List<BigInteger> recIds = new ArrayList<BigInteger>();
	  try{
		  HashMap stotalIdsMap = getTotalByPeriodFactor(viewId, periodFacotr, rangeFrom, rangeTo);
		  if("Success".equalsIgnoreCase(stotalIdsMap.get("status").toString()))
		  {
			  totalIds = (List<BigInteger>) stotalIdsMap.get("totalIds");
		  }
		  else
		  {
			  log.info("Error while fetching total ids for the source view : "+viewId);
		  } 
	  }
	  catch(Exception e)
	  {
		  log.info("Error while fetching total ids for the source view : "+viewId);
	  }
	  if(totalIds.size()>0)
	  {
		  if("suggestion".equalsIgnoreCase(typeOfRecData))
		  {
			  recIds = reconciliationDuplicateResultRepository.fetchReconciledIdsWithOutJobRefWithStatusReconciledForSource(tenantId, ruleIds, groupId, totalIds,viewId);
		  }
		  else
		  {
			  recIds = reconciliationResultRepository.fetchReconciledIdsWithOutJobRefWithStatusReconciledForSource(tenantId, ruleIds, groupId, totalIds,viewId);	  
		  }
	  }
	  finalMap.put("reconciled", recIds);
	  finalMap.put("totalIds", totalIds);
	  return finalMap;
  }
  
  
  
  
  public HashMap getAppRulesRecIdsForSource(Long viewId, String periodFacotr, String rangeFrom, String rangeTo, List<Long> ruleIds, Long tenantId, Long groupId)
  {
	  HashMap finalMap = new HashMap();
	  List<BigInteger> totalIds = new ArrayList<BigInteger>();
	  List<BigInteger> recIds = new ArrayList<BigInteger>();
	  try{
		  HashMap stotalIdsMap = getTotalByPeriodFactor(viewId, periodFacotr, rangeFrom, rangeTo);
		  if("Success".equalsIgnoreCase(stotalIdsMap.get("status").toString()))
		  {
			  totalIds = (List<BigInteger>) stotalIdsMap.get("totalIds");
		  }
		  else
		  {
			  log.info("Error while fetching total ids for the source view : "+viewId);
		  } 
	  }
	  catch(Exception e)
	  {
		  log.info("Error while fetching total ids for the source view : "+viewId);
	  }
	  if(totalIds.size()>0)
	  {
		  recIds = reconciliationResultRepository.fetchReconciledIdsWithOutJobRefWithStatusReconciledForSource(tenantId, ruleIds, groupId, totalIds,viewId);
	  }
	  finalMap.put("reconciled", recIds);
	  finalMap.put("totalIds", totalIds);
	  return finalMap;
  }
  
  public HashMap getRecIdsforBatches(Long viewId, String periodFactor, String rangeFrom, String rangeTo, Long tenantId, Long groupId, List<String> batches, String sourceOrTarget, String typeOfRecData)
  {
	  HashMap finalMap = new HashMap();
	  List<BigInteger> totalIds = new ArrayList<BigInteger>();
	  List<BigInteger> recIds = new ArrayList<BigInteger>();
	  try{
		  HashMap stotalIdsMap = getTotalByPeriodFactor(viewId, periodFactor, rangeFrom, rangeTo);
		  if("Success".equalsIgnoreCase(stotalIdsMap.get("status").toString()))
		  {
			  totalIds = (List<BigInteger>) stotalIdsMap.get("totalIds");
		  }
		  else
		  {
			  log.info("Error while fetching total ids for the source view : "+viewId);
		  } 
	  }
	  catch(Exception e)
	  {
		  log.info("Error while fetching total ids for the source view : "+viewId);
	  }
	  if(totalIds.size()>0)
	  {
		  if("source".equalsIgnoreCase(sourceOrTarget))
		  {
			  if("suggestion".equalsIgnoreCase(typeOfRecData))
			  {
				  recIds = reconciliationDuplicateResultRepository.fetchReconciledIdswittBatchesForSource(tenantId, groupId, totalIds, batches, viewId);
			  }
			  else
			  {
				  recIds = reconciliationResultRepository.fetchReconciledIdswittBatchesForSource(tenantId, groupId, totalIds, batches, viewId);  
			  }
		  }
		  else if("target".equalsIgnoreCase(sourceOrTarget))
		  {
			  if("suggestion".equalsIgnoreCase(typeOfRecData))
			  {
				  recIds = reconciliationDuplicateResultRepository.fetchReconciledIdswithJobReferencesForTarget(tenantId, groupId, totalIds, batches, viewId);
			  }
			  else
			  {
				  recIds = reconciliationResultRepository.fetchReconciledIdswithJobReferencesForTarget(tenantId, groupId, totalIds, batches, viewId);  
			  }
			  
		  }
	  }
	  log.info("RecIds Size: "+recIds.size());
	  log.info("Total Ids Size: "+totalIds.size());
	  finalMap.put("reconciled", recIds);
	  finalMap.put("totalIds", totalIds);
	  return finalMap;
  }
  
  public HashMap getRulesRecIdsForTarget(Long viewId, String periodFacotr, String rangeFrom, String rangeTo, List<Long> ruleIds, Long tenantId, Long groupId, String typeOfRecData)
  {
	  HashMap finalMap = new HashMap();
	  List<BigInteger> totalIds = new ArrayList<BigInteger>();
	  List<BigInteger> recIds = new ArrayList<BigInteger>();
	  try{
		  HashMap stotalIdsMap = getTotalByPeriodFactor(viewId, periodFacotr, rangeFrom, rangeTo);
		  if("Success".equalsIgnoreCase(stotalIdsMap.get("status").toString()))
		  {
			  totalIds = (List<BigInteger>) stotalIdsMap.get("totalIds");
		  }
		  else
		  {
			  log.info("Error while fetching total ids for the source view : "+viewId);
		  } 
	  }
	  catch(Exception e)
	  {
		  log.info("Error while fetching total ids for the source view : "+viewId);
	  }
	  if(totalIds.size()>0)
	  {
		  if("suggestion".equalsIgnoreCase(typeOfRecData))
		  {
			  recIds = reconciliationDuplicateResultRepository.fetchReconciledIdsWithOutJobRefWithStatusReconciledForTarget(tenantId, ruleIds, groupId, totalIds,viewId);
		  }
		  else
		  {
			  recIds = reconciliationResultRepository.fetchReconciledIdsWithOutJobRefWithStatusReconciledForTarget(tenantId, ruleIds, groupId, totalIds,viewId);
		  }
	  }
	  finalMap.put("reconciled", recIds);
	  finalMap.put("totalIds", totalIds);
	  return finalMap;
  }
  
  public HashMap getDatesUnRecSummaryInfo(List<String> dates, String periodFactor, String rangeFrom, String rangeTo, Long sViewId, Long tViewId, Long tenantId, Long groupId, String sourceOrTarget) throws java.text.ParseException, SQLException, ParseException, ClassNotFoundException
  {
	  HashMap finalMap = new HashMap();
	  Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	  String currencyFormat = props.getProperty("currencyFormat");
	  List<HashMap> finalList = new ArrayList<HashMap>();
	  for(String transDate : dates)
	  {
		  HashMap transDateMp = new HashMap();
		  DateFormat df = new SimpleDateFormat("yyyy-MM-dd");
		  Date date = df.parse(transDate);
		  df = new SimpleDateFormat("dd-MMM-yy");
		  transDateMp.put("name", df.format(date));
			  if("source".equalsIgnoreCase(sourceOrTarget))
			  {
				  log.info("Fetching source dates summary info");
				  DataViews dv = dataViewsRepository.findOne(sViewId);
				  List<BigInteger> recIdSource = new ArrayList<BigInteger>();
				  List<BigInteger> suggestedIdSource = new ArrayList<BigInteger>();
				  List<BigInteger> unRecIdSource = new ArrayList<BigInteger>();
				  String dateQualifier = getTransDateQualifier(BigInteger.valueOf(sViewId), "TRANSDATE");
				  List<BigInteger> totalOriginalIds = new ArrayList<BigInteger>();		
				  totalOriginalIds =   getOriginalIdsForDays(sViewId, rangeFrom, rangeTo, dateQualifier, transDate, periodFactor);
				  log.info("Source Date: "+transDate+" original ids size: "+totalOriginalIds.size());
				  if(totalOriginalIds.size()>0)
				  {
					  String currencyCodeColName = getTransDateQualifier(BigInteger.valueOf(sViewId), "CURRENCYCODE"); 
					  String amountQualifier = getTransDateQualifier(BigInteger.valueOf(sViewId), "AMOUNT"); 

					  recIdSource = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForSource(tenantId, groupId, totalOriginalIds,sViewId);
					  suggestedIdSource = reconciliationDuplicateResultRepository.fetchReconciledIdswithStatusUnreconciledForSource(tenantId, groupId, totalOriginalIds,sViewId);
					  HashMap unRecon = new HashMap();
					  String currencySymbolUnRec = "";
					   
					  for(BigInteger id: totalOriginalIds)
					  {
						  if(!recIdSource.contains(id))
						  {
							  unRecIdSource.add(id);
						  }
					  }
					  unRecIdSource.removeAll(suggestedIdSource);
						if(unRecIdSource.size()>0)
						{
							List<String> currenciesUnRec = getDistColumnValues(unRecIdSource,currencyCodeColName,dv.getDataViewName());
							if(currenciesUnRec.size()==1)
							{
								currencySymbolUnRec = currencySymbolUnRec+getCurrencySymbol(currenciesUnRec.get(0));
							}
							else if(currenciesUnRec.size()>1)
							{
								currencySymbolUnRec = currencySymbolUnRec+"*";
							}
							HashMap unRecAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(sViewId.toString()), tenantId, amountQualifier,unRecIdSource);
							transDateMp.put("sAmount", currencySymbolUnRec + " " + reconciliationResultService.getAmountInFormat(unRecAmountCount.get("totalAmount").toString(),currencyFormat));
							transDateMp.put("sCount", unRecAmountCount.get("totalCount"));			
							transDateMp.put("dsCount", unRecIdSource.size());
							transDateMp.put("sCurrency", currencySymbolUnRec);
							transDateMp.put("sAmountValue", unRecAmountCount.get("totalAmount"));
							
							transDateMp.put("tAmount", 0.0);
							transDateMp.put("tCount", 0);			
							transDateMp.put("dtCount", 0);
							transDateMp.put("tCurrency", "");
							transDateMp.put("tAmountValue", 0);
							finalList.add(transDateMp);
						}
				  }
			  }
			  else if("target".equalsIgnoreCase(sourceOrTarget))
			  {
				  log.info("Fetching target dates summary info");
				  List<BigInteger> recIdTarget = new ArrayList<BigInteger>();
				  List<BigInteger> unRecIdTarget = new ArrayList<BigInteger>();
				  List<BigInteger> suggestedIdTarget = new ArrayList<BigInteger>();
				  
				  List<BigInteger> totalOriginalIds = new ArrayList<BigInteger>();
				  String dateQualifier = getTransDateQualifier(BigInteger.valueOf(tViewId), "TRANSDATE");
				  totalOriginalIds =   getOriginalIdsForDays(tViewId, rangeFrom, rangeTo, dateQualifier, transDate, periodFactor);
				  log.info("Target Date: "+transDate+" original ids size: "+totalOriginalIds.size());
				  if(totalOriginalIds.size()>0)
				  {
					  String currencyCodeColName = getTransDateQualifier(BigInteger.valueOf(tViewId), "CURRENCYCODE"); 
					  String amountQualifier = getTransDateQualifier(BigInteger.valueOf(tViewId), "AMOUNT"); 
					  DataViews dv = dataViewsRepository.findOne(tViewId);
					  recIdTarget = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForTarget(tenantId, groupId, totalOriginalIds,tViewId);
					  suggestedIdTarget = reconciliationDuplicateResultRepository.fetchReconciledIdswithStatusUnreconciledForTarget(tenantId, groupId, totalOriginalIds,tViewId);
					   HashMap unRecon = new HashMap();
					   String currencySymbolUnRec = "";
					   
						  for(BigInteger id: totalOriginalIds)
						  {
							  if(!recIdTarget.contains(id))
							  {
								  unRecIdTarget.add(id);
							  }
						  }
						  unRecIdTarget.removeAll(suggestedIdTarget);
						  if(unRecIdTarget.size()>0)
						  {
							   List<String> currenciesUnRec = getDistColumnValues(unRecIdTarget,currencyCodeColName,dv.getDataViewName());
							   if(currenciesUnRec.size()==1)
							   {
								   currencySymbolUnRec = currencySymbolUnRec+getCurrencySymbol(currenciesUnRec.get(0));
							   }
							   else if(currenciesUnRec.size()>1)
							   {
								   currencySymbolUnRec = currencySymbolUnRec+"*";
							   }
							   HashMap unRecAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(tViewId.toString()), tenantId, amountQualifier,unRecIdTarget);
							   transDateMp.put("tAmount", currencySymbolUnRec + " " + reconciliationResultService.getAmountInFormat(unRecAmountCount.get("totalAmount").toString(),currencyFormat));
							   transDateMp.put("tCount", unRecAmountCount.get("totalCount"));
							   transDateMp.put("dtCount", unRecIdTarget.size());
							   transDateMp.put("tCurrency", currencySymbolUnRec);
							   transDateMp.put("tAmountValue", unRecAmountCount.get("totalAmount").toString());
							   
							   transDateMp.put("sAmount", 0.0);
							   transDateMp.put("sCount", 0);
							   transDateMp.put("dsCount", 0);
							   transDateMp.put("sCurrency", "");
							   transDateMp.put("sAmountValue", 0);
							   
							   finalList.add(transDateMp);
						  }
				  }
			  }
			  else if("common".equalsIgnoreCase(sourceOrTarget))
			  {
				  log.info("Fetching common dates info");
				  List<BigInteger> recIdTarget = new ArrayList<BigInteger>();
				  List<BigInteger> suggestedIdTarget = new ArrayList<BigInteger>();
				  List<BigInteger> unRecIdTarget = new ArrayList<BigInteger>();
				  
				  List<BigInteger> recIdSource = new ArrayList<BigInteger>();
				  List<BigInteger> suggestedIdSource = new ArrayList<BigInteger>();
				  List<BigInteger> unRecIdSource = new ArrayList<BigInteger>();
				  
				  String sDateQualifier = getTransDateQualifier(BigInteger.valueOf(sViewId), "TRANSDATE");
				  String tDateQualifier = getTransDateQualifier(BigInteger.valueOf(tViewId), "TRANSDATE");
				  List<BigInteger> sTotalOriginalIds = new ArrayList<BigInteger>();				  
				  sTotalOriginalIds =   getOriginalIdsForDays(sViewId, rangeFrom, rangeTo, sDateQualifier, transDate, periodFactor);
				  log.info("Source Date: "+transDate+", total ids size: "+sTotalOriginalIds.size());
				  if(sTotalOriginalIds.size()>0)
				  {
					  String sCurrencyCodeColName = getTransDateQualifier(BigInteger.valueOf(sViewId), "CURRENCYCODE"); 
					  String sAmountQualifier = getTransDateQualifier(BigInteger.valueOf(sViewId), "AMOUNT"); 

					  DataViews dv = dataViewsRepository.findOne(sViewId);
					  recIdSource = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForSource(tenantId, groupId, sTotalOriginalIds,sViewId);
					  suggestedIdSource = reconciliationDuplicateResultRepository.fetchReconciledIdswithStatusUnreconciledForSource(tenantId, groupId, sTotalOriginalIds,sViewId);
					  HashMap unRecon = new HashMap();
					  String currencySymbolUnRec = "";
					   
					  for(BigInteger id: sTotalOriginalIds)
					  {
						  if(!recIdSource.contains(id))
						  {
							  unRecIdSource.add(id);
						  }
					  }
					  unRecIdSource.removeAll(suggestedIdSource);
					  if(unRecIdSource.size()>0)
					  {
						  List<String> currenciesUnRec = getDistColumnValues(unRecIdSource,sCurrencyCodeColName,dv.getDataViewName());
						  if(currenciesUnRec.size()==1)
						  {
							  currencySymbolUnRec = currencySymbolUnRec+getCurrencySymbol(currenciesUnRec.get(0));
						  }
						  else if(currenciesUnRec.size()>1)
						  {
							  currencySymbolUnRec = currencySymbolUnRec+"*";
						  }
						  
						  HashMap unRecAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(sViewId.toString()), tenantId, sAmountQualifier,unRecIdSource);
						  transDateMp.put("sAmount", currencySymbolUnRec + " " + reconciliationResultService.getAmountInFormat(unRecAmountCount.get("totalAmount").toString(),currencyFormat));
						  transDateMp.put("sCount", unRecAmountCount.get("totalCount"));		
						  transDateMp.put("dsCount", unRecIdSource.size());
						  transDateMp.put("sCurrency", currencySymbolUnRec);
						  transDateMp.put("sAmountValue", unRecAmountCount.get("totalAmount"));
					  }
					  else
					  {
						   transDateMp.put("sAmount", 0.0);
						   transDateMp.put("sCount", 0);
						   transDateMp.put("dsCount", 0);
						   transDateMp.put("sCurrency", "");
						   transDateMp.put("sAmountValue", 0);
					  }

				  }

				  List<BigInteger> tTotalOriginalIds = new ArrayList<BigInteger>();
				  tTotalOriginalIds =   getOriginalIdsForDays(tViewId, rangeFrom, rangeTo, tDateQualifier, transDate, periodFactor);
				  log.info("Target: "+transDate+", total ids size: "+sTotalOriginalIds.size());
				  if(tTotalOriginalIds.size()>0)
				  {
					  String currencyCodeColName = getTransDateQualifier(BigInteger.valueOf(tViewId), "CURRENCYCODE"); 
					  String amountQualifier = getTransDateQualifier(BigInteger.valueOf(tViewId), "AMOUNT"); 
					  DataViews dv = dataViewsRepository.findOne(tViewId);
					  recIdTarget = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForTarget(tenantId, groupId, tTotalOriginalIds,tViewId);
					  suggestedIdTarget = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForTarget(tenantId, groupId, tTotalOriginalIds,tViewId);
					  HashMap unRecon = new HashMap();
					  String currencySymbolUnRec = "";
					   
					  for(BigInteger id: tTotalOriginalIds)
					  {
						  if(!recIdTarget.contains(id))
						  {
							  unRecIdTarget.add(id);
						  }
					  }
					  unRecIdTarget.removeAll(suggestedIdTarget);
					  if(unRecIdTarget.size()>0)
					  {
						  List<String> currenciesUnRec = getDistColumnValues(unRecIdTarget,currencyCodeColName,dv.getDataViewName());
						  if(currenciesUnRec.size()==1)
						  {
							  currencySymbolUnRec = currencySymbolUnRec+getCurrencySymbol(currenciesUnRec.get(0));
						  }
						  else if(currenciesUnRec.size()>1)
						  {
							  currencySymbolUnRec = currencySymbolUnRec+"*";
						  }
						  HashMap unRecAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(tViewId.toString()), tenantId, amountQualifier,unRecIdTarget);
						  transDateMp.put("tAmount", currencySymbolUnRec + " " + reconciliationResultService.getAmountInFormat(unRecAmountCount.get("totalAmount").toString(),currencyFormat));
						  transDateMp.put("tCount", unRecAmountCount.get("totalCount"));					  
						  transDateMp.put("dtCount", unRecIdTarget.size());
						  transDateMp.put("tCurrency", currencySymbolUnRec);
						  transDateMp.put("tAmountValue", unRecAmountCount.get("totalAmount"));
					  }
					  else
					  {
						   transDateMp.put("tAmount", 0.0);
						   transDateMp.put("tCount", 0); 
						   transDateMp.put("dtCount", 0);
						   transDateMp.put("tCurrency", "");
						   transDateMp.put("tAmountValue", 0);
					  }
				  }
				  if(unRecIdSource.size() == 0 && unRecIdTarget.size() == 0)
				  {}
				  else
				  {
					  finalList.add(transDateMp);
				  }
			  }
		  }
	  finalMap.put("summary", finalList);
	  finalMap.put("status", "");
	  return finalMap;
  }
  
  public HashMap getDatesUnRecSummary(List<String> sDates, List<String> tDates,List<String> commonDates, Long tenantId, Long sViewId, Long tViewId, String rangeFrom, String rangeTo, String sDateQualifier, String tDateQualifier, String periodFactor, Long groupId) throws ClassNotFoundException, java.text.ParseException, SQLException, ParseException
  {
	  HashMap finalMap = new HashMap();
	  List<HashMap> finalList = new ArrayList<HashMap>();
	  Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	  String currencyFormat = props.getProperty("currencyFormat"); 
	  String sCurrencyCode = getTransDateQualifier(BigInteger.valueOf(sViewId), "CURRENCYCODE"); 
	  String tCurrencyCode = getTransDateQualifier(BigInteger.valueOf(tViewId), "CURRENCYCODE"); 
	  DataViews sdv = dataViewsRepository.findOne(sViewId);
	  DataViews tdv = dataViewsRepository.findOne(tViewId);
	  List<HashMap> allDatesMap = new ArrayList<HashMap>();
	  if(sdv != null && tdv != null)
	  {	
		  if(sCurrencyCode.length()>0 && tCurrencyCode.length()>0)
		  {
			  if(sDates.size()>0)
			  {
				  log.info("source dates: "+sDates);
				  HashMap map = getDatesUnRecSummaryInfo(sDates, periodFactor, rangeFrom, rangeTo, sViewId, tViewId, tenantId, groupId, "source");
				  finalList.addAll((List<HashMap>) map.get("summary"));
			  }
			  if(tDates.size()>0)
			  {
				  log.info("target dates: "+tDates);
				  HashMap map = getDatesUnRecSummaryInfo(tDates, periodFactor, rangeFrom, rangeTo, sViewId, tViewId, tenantId, groupId, "target");
				  finalList.addAll((List<HashMap>) map.get("summary"));
			  }
			  if(commonDates.size()>0)
			  {
				  log.info("common dates: "+commonDates);
				  HashMap map = getDatesUnRecSummaryInfo(commonDates, periodFactor, rangeFrom, rangeTo, sViewId, tViewId, tenantId, groupId, "common");
				  finalList.addAll((List<HashMap>) map.get("summary"));
			  }
		  }
		  else
		  {
			  log.info("There is no currency code qualifiers found the source view id: "+sViewId+" or target view id: "+tViewId);
		  }
	  }
	  else 
	  {
		  log.info("source view id: "+sViewId+" or target view id: "+tViewId+" are");
	  }
	  finalMap.put("summary", finalList);
	  finalMap.put("status", "");
	  return finalMap;
  }
  
  public HashMap getColValuesUnRecSummaryInfo(List<String> colValues, ReconCountNAmountsDTO params, String sourceOrTarget, String columnName, String dataType) throws ClassNotFoundException, SQLException, ParseException
  {
	  HashMap finalMap = new HashMap();
	  List<HashMap> summaryInfo = new ArrayList<HashMap>();
	  List<HashMap> finalList = new ArrayList<HashMap>();
	  if("source".equalsIgnoreCase(sourceOrTarget))
	  {
		  log.info("Source column values summary info");
		 // DataViewsColumns sdvc = dataViewsColumnsRepository.findOne(params.getsColumnId());
		  //String sCurrenyCol = getTransDateQualifier(BigInteger.valueOf(params.getsViewId()), "CURRENCYCODE"); 
		  if("reconciled".equalsIgnoreCase(params.getStatus()))
		  {
			  log.info("Fetching source reconciled column values summary info");
			  summaryInfo = getColSummaryInfo(colValues, params.getsViewId(), params.getRangeFrom(), params.getRangeTo(), columnName, dataType, params.getTenantId(), params.getRuleGroupId(), sourceOrTarget, params.getStatus(), params.getPeriodFactor());
			  if(summaryInfo.size()>0)
			  {
				  for(HashMap hm : summaryInfo)
				  {
					  HashMap hmNew = new HashMap();
					  hmNew.put("sAmount", hm.get("rAmount").toString());
					  hmNew.put("sCount", hm.get("rCount").toString());
					  hmNew.put("dsCount", hm.get("dCount").toString());

					  hmNew.put("tAmount", 0.0);
					  hmNew.put("tCount", 0);
					  hmNew.put("dtCount", 0);

					  hmNew.put("name", hm.get("name").toString());
					  finalList.add(hmNew);
				  }
			  }
			  log.info("Source reconciled summary info size: "+summaryInfo.size());
		  }
		  else if("unReconciled".equalsIgnoreCase(params.getStatus()))
		  {
			  log.info("Fetching source un reconciled column values summary info");
			  summaryInfo = getColSummaryInfo(colValues, params.getsViewId(), params.getRangeFrom(), params.getRangeTo(), columnName, dataType, params.getTenantId(), params.getRuleGroupId(), sourceOrTarget, params.getStatus(), params.getPeriodFactor());
			  if(summaryInfo.size()>0)
			  {
				  for(HashMap hm : summaryInfo)
				  {
					  HashMap hmNew = new HashMap();
					  hmNew.put("sAmount", hm.get("uAmount").toString());
					  hmNew.put("sCount", hm.get("uCount").toString());
					  hmNew.put("dsCount", hm.get("dCount").toString());
					  hmNew.put("name", hm.get("name").toString());
					  
					  hmNew.put("tAmount", 0.0);
					  hmNew.put("tCount", 0);
					  hmNew.put("dtCount", 0);

					  
					  finalList.add(hmNew);
				  }
			  }
			  log.info("Source un reconciled summary info size: "+finalList.size());
		  }
	  }
	  else if("target".equalsIgnoreCase(sourceOrTarget))
	  {
		  log.info("Target column values summary info");
		  // DataViewsColumns tdvc = dataViewsColumnsRepository.findOne(params.gettColumnId());
		  // String tCurrenyCol = getTransDateQualifier(BigInteger.valueOf(params.gettViewId()), "CURRENCYCODE");
		   DataViews tdv = dataViewsRepository.findOne(params.gettViewId());
		   if("reconciled".equalsIgnoreCase(params.getStatus()))
		   {
			   log.info("Fetching target reconciled column values summary info");
				summaryInfo = getColSummaryInfo(colValues, params.gettViewId(), params.getRangeFrom(), params.getRangeTo(), columnName, dataType, params.getTenantId(), params.getRuleGroupId(), sourceOrTarget, params.getStatus(), params.getPeriodFactor());
				log.info("target reconciled column values summary info size: "+summaryInfo.size());
				if(summaryInfo.size()>0)
				  {
					  for(HashMap hm : summaryInfo)
					  {
						  HashMap hmNew = new HashMap();
						  hmNew.put("tAmount", hm.get("rAmount").toString());
						  hmNew.put("tCount", hm.get("rCount").toString());
						  hmNew.put("dtCount", hm.get("dCount").toString());
						  
						  hmNew.put("sAmount", 0.0);
						  hmNew.put("sCount", 0);
						  hmNew.put("dsCount", 0);
						  
						  hmNew.put("name", hm.get("name").toString());
						  finalList.add(hmNew);
					  }
				  }
				log.info("target reconciled column values summary info size: "+ finalList.size());
		   }
		   else if("unReconciled".equalsIgnoreCase(params.getStatus()))
		   {
			   log.info("Fetching target un reconciled column values summary info");
			   summaryInfo = getColSummaryInfo(colValues, params.gettViewId(), params.getRangeFrom(), params.getRangeTo(), columnName, dataType, params.getTenantId(), params.getRuleGroupId(), sourceOrTarget, params.getStatus(), params.getPeriodFactor());
				log.info("target un reconciled column values summary info");
			   if(summaryInfo.size()>0)
				  {
					  for(HashMap hm : summaryInfo)
					  {
						  HashMap hmNew = new HashMap();
						  hmNew.put("tAmount", hm.get("rAmount").toString());
						  hmNew.put("tCount", hm.get("rCount").toString());
						  hmNew.put("dtCount", hm.get("dCount").toString());
						  
						  hmNew.put("sAmount", 0.0);
						  hmNew.put("sCount", 0);
						  hmNew.put("dsCount", 0);
						  
						  hmNew.put("name", hm.get("name").toString());
						  finalList.add(hmNew);
					  }
				  }
			   log.info("target un reconciled column values summary info size: "+ finalList.size());
		   }
	  }
	  else if("common".equalsIgnoreCase(sourceOrTarget))
	  {
		  DataViews sdv = dataViewsRepository.findOne(params.getsViewId());
		  DataViews tdv = dataViewsRepository.findOne(params.gettViewId());
		  
		  HashMap smap = getDataTYpeNColumnName(params.getsColumnId());
		  HashMap tmap = getDataTYpeNColumnName(params.gettColumnId());
		   
		  String sColName = smap.get("columnName").toString();
		  String sDataType = smap.get("dataType").toString();
			  
		  String tColName = tmap.get("columnName").toString();
		  String tDataType = tmap.get("dataType").toString();
		  log.info("common: source column name: "+sColName+", dataType: "+ sDataType);
		  log.info("common: target column name: "+tColName+", dataType: "+ tDataType);

		  List<HashMap> srcRec = new ArrayList<HashMap>();
		  List<HashMap> srcUnRec = new ArrayList<HashMap>();
		  
		  List<HashMap> targetRec = new ArrayList<HashMap>();
		  List<HashMap> targetUnRec = new ArrayList<HashMap>();
		  
		  if("reconciled".equalsIgnoreCase(params.getStatus()))
		  {
			  log.info("Common reconciled column values summary info");
			  srcRec = getColSummaryInfo(colValues, params.getsViewId(), params.getRangeFrom(), params.getRangeTo(), sColName, sDataType, params.getTenantId(), params.getRuleGroupId(), "source", "reconciled",params.getPeriodFactor());
			  log.info("Common source reconciled column values summary info: "+srcRec.size());
			  if(srcRec.size()>0)
			  {
				  for(HashMap hm : srcRec)
				  {
					  HashMap hmNew = new HashMap();
					  hmNew.put("sAmount", hm.get("rAmount").toString());
					  hmNew.put("sCount", hm.get("rCount").toString());
					  hmNew.put("dsCount", hm.get("dCount").toString());
					  hmNew.put("name", hm.get("name").toString());
					  finalList.add(hmNew);
				  }
			  }
			  log.info("Common source reconcield column values summary info: "+finalList.size());
			  targetRec = getColSummaryInfo(colValues, params.gettViewId(), params.getRangeFrom(), params.getRangeTo(), tColName, tDataType, params.getTenantId(), params.getRuleGroupId(), "target", "reconciled",params.getPeriodFactor());
			  log.info("Common target reconciled column values summary info: "+targetRec.size());
			  if(targetRec.size()>0)
			  {
				  for(HashMap hm : targetRec)
				  {
					  HashMap hmNew = new HashMap();
					  hmNew.put("tAmount", hm.get("rAmount").toString());
					  hmNew.put("tCount", hm.get("rCount").toString());
					  hmNew.put("dtCount", hm.get("dCount").toString());
					  hmNew.put("name", hm.get("name").toString());
					  finalList.add(hmNew);
				  }
			  }
			  log.info("Common target reconciled column values summary info: "+ finalList.size());
		  }
		  else if("unReconciled".equalsIgnoreCase(params.getStatus()))
		  {
			  log.info("Fetching common un reconciled column values summary info");
			  srcUnRec = getColSummaryInfo(colValues, params.getsViewId(), params.getRangeFrom(), params.getRangeTo(), sColName, sDataType, params.getTenantId(), params.getRuleGroupId(), "source", "unReconciled",params.getPeriodFactor());
			  log.info("Common source un reconciled column values summary info: "+srcUnRec.size());
			  if(srcUnRec.size()>0)
			  {
				  for(HashMap hm : srcUnRec)
				  {
					  HashMap hmNew = new HashMap();
					  hmNew.put("sAmount", hm.get("uAmount").toString());
					  hmNew.put("sCount", hm.get("uCount").toString());
					  hmNew.put("dsCount", hm.get("dCount").toString());
					  hmNew.put("name", hm.get("name").toString());
					  finalList.add(hmNew);
				  }
			  }
			  log.info("Common source un reconciled column values summary info: "+finalList.size());
			  targetUnRec = getColSummaryInfo(colValues, params.gettViewId(), params.getRangeFrom(), params.getRangeTo(), tColName, tDataType, params.getTenantId(), params.getRuleGroupId(), "target", "unReconciled",params.getPeriodFactor());
			  log.info("Common targt un reconciled column values summary info: "+ targetUnRec.size());
			  if(targetUnRec.size()>0)
			  {
				  for(HashMap hm : targetUnRec)
				  {
					  HashMap hmNew = new HashMap();
					  hmNew.put("tAmount", hm.get("rAmount").toString());
					  hmNew.put("tCount", hm.get("rCount").toString());
					  hmNew.put("dtCount", hm.get("dCount").toString());
					  hmNew.put("name", hm.get("name").toString());
					  finalList.add(hmNew);
				  }
			  }
			  log.info("Common target un reconciled column values summary info: "+ finalList.size());
		  }
	  }
	  finalMap.put("summary", finalList);
	  finalMap.put("status", "");
	  return finalMap;
  }
  
  public List<HashMap> getColSummaryInfo(List<String> colValues, Long viewId, String rangeFrom, String rangeTo, String columnName, String dataType, Long tenantId, Long groupId, String sourceOrTarget, String status, String periodFactor) throws ClassNotFoundException, SQLException, ParseException
  {
	  String currencyCodeColName = getTransDateQualifier(new BigInteger(viewId.toString()), "CURRENCYCODE"); 
	  List<HashMap> finalList = new ArrayList<HashMap>();
	  Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	  String currencyFormat = props.getProperty("currencyFormat");
	  DataViews dv = dataViewsRepository.findOne(viewId);
	  String amountQualifier = getTransDateQualifier(new BigInteger(viewId.toString()), "AMOUNT"); 
	  if(dv != null)
	  {
		   for(String colValue: colValues)
		   {
			   HashMap colValuMP = new HashMap();
			   colValuMP.put("name", colValue);
			   List<BigInteger> totalOriginalIds = getOriginalIdsByTransDate(viewId, rangeFrom, rangeTo, columnName, colValue, dataType, periodFactor);
			   
			   List<BigInteger> unRecIds = new ArrayList<BigInteger>();
			   if(totalOriginalIds.size()>0)
			   {
				   List<BigInteger> recIds = new ArrayList<BigInteger>();
				   if("source".equalsIgnoreCase(sourceOrTarget))
				   {
					   recIds = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForSource(tenantId, groupId, totalOriginalIds, viewId);
				   }
				   else if("target".equalsIgnoreCase(sourceOrTarget))
				   {
					   recIds = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForTarget(tenantId, groupId, totalOriginalIds, viewId);
				   }
				   if(recIds.size()>0)
				   {
					   for(BigInteger id: totalOriginalIds)
					   {
						   if(!recIds.contains(id))
						   {
							   unRecIds.add(id);
						   }
					   }
					   HashMap total = new HashMap();
					   HashMap recon = new HashMap();
					   HashMap unRecon = new HashMap();
					   
					   String currencySymbolRec = "";
					   List<String> currenciesRec = getDistColumnValues(recIds,currencyCodeColName,dv.getDataViewName());
					   if(currenciesRec.size()==1)
					   {
						   currencySymbolRec = currencySymbolRec+getCurrencySymbol(currenciesRec.get(0));
					   }
					   else if(currenciesRec.size()>1)
					   {
						   currencySymbolRec = currencySymbolRec+"*";
					   }
					   
					   String currencySymbolUnRec = "";
					   List<String> currenciesUnRec = getDistColumnValues(unRecIds,currencyCodeColName,dv.getDataViewName());
					   if(currenciesUnRec.size()==1)
					   {
						   currencySymbolUnRec = currencySymbolUnRec+getCurrencySymbol(currenciesUnRec.get(0));
					   }
					   else if(currenciesUnRec.size()>1)
					   {
						   currencySymbolUnRec = currencySymbolUnRec+"*";
					   }
					   				   
					   if("reconciled".equalsIgnoreCase(status))
					   {
						   HashMap recAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, amountQualifier,recIds);
						   colValuMP.put("rAmount", currencySymbolRec + " " + reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
						   colValuMP.put("rCount", recAmountCount.get("totalCount"));
						   colValuMP.put("dCount", recIds.size());
						   
					   }
					   else if("unReconciled".equalsIgnoreCase(status))
					   {
						   HashMap unRecAmountCount = reconciliationResultService.getCountNAmountForDVId(new BigInteger(viewId.toString()), tenantId, amountQualifier,unRecIds);
						   colValuMP.put("uAmount", currencySymbolUnRec + " " + reconciliationResultService.getAmountInFormat(unRecAmountCount.get("totalAmount").toString(),currencyFormat));
						   colValuMP.put("uCount", unRecAmountCount.get("totalCount"));
						   colValuMP.put("dCount", unRecIds.size());					   
					   }
					   finalList.add(colValuMP);
				   }
			   }
		   }
	  }
	  return finalList;
  }
  public HashMap getDataTYpeNColumnName(Long colId)
  {
	  HashMap finalMap = new HashMap();
	  finalMap.put("dataType", "");
	  finalMap.put("columnName", "");
	  DataViewsColumns dvc = dataViewsColumnsRepository.findOne(colId);
	  if(dvc != null)
	  {
		  if("VARCHAR".equals(dvc.getColDataType()) || "DATE".equalsIgnoreCase(dvc.getColDataType()))
		  {
			  finalMap.put("dataType","string");
		  }
		  else if("INTEGER".equalsIgnoreCase(dvc.getColDataType()) || "DECIMAL".equalsIgnoreCase(dvc.getColDataType()))
		  {
			  finalMap.put("dataType","integer");
		  }
		  if("File Template".equalsIgnoreCase(dvc.getRefDvType()))
		  {
			  FileTemplateLines ftl = fileTemplateLinesRepository.findOne(Long.parseLong(dvc.getRefDvColumn().toString()));
			  if(ftl != null)
			  {
				 finalMap.put("columnName", ftl.getColumnAlias());
			  }
		  }
		  else if("Data View".equalsIgnoreCase(dvc.getRefDvType()) || dvc.getRefDvType() == null)
		  {
			  finalMap.put("columnName", dvc.getColumnName());
		  }
	   }
	  return finalMap;
  }
  public String getCurrencySymbolByIds(List<BigInteger> originalIds, String currencyCodeColName, String dataViewName) throws SQLException, ParseException
  {
	  String currencySymbol = "";
	  List<String> currencies = getDistColumnValues(originalIds,currencyCodeColName, dataViewName);
	  if(currencies.size()==1)
	  {
		  currencySymbol = currencySymbol+getCurrencySymbol(currencies.get(0));
	  }
	  else if(currencies.size()>1)
	  {
		  currencySymbol = currencySymbol+"*";
	  }
	  return currencySymbol;
  }
  
  public HashMap getColSummaryForSource(String status, String colValue, List<BigInteger> totalIds, Long tenantId, Long groupId, Long viewId) throws ClassNotFoundException, SQLException, ParseException
  {
	  HashMap finalMap = new HashMap();
	  List<BigInteger> recIds = new ArrayList<BigInteger>();
	  List<BigInteger> unRecIds = new ArrayList<BigInteger>();
	  List<BigInteger> suggestedIds = new ArrayList<BigInteger>();
	  DataViews dv = dataViewsRepository.findOne(viewId);
	  String currencyCodeColName = getTransDateQualifier(new BigInteger(viewId.toString()), "CURRENCYCODE");
	  String amountQualifier = getTransDateQualifier(new BigInteger(viewId.toString()), "AMOUNT");
	  
	  Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	  String currencyFormat = props.getProperty("currencyFormat");
	  log.info("getColSummaryForSource: ViewID: "+viewId+", CurrencyCodeColName: "+currencyCodeColName+", AmountQualifier: "+amountQualifier);
	  if(totalIds.size()>0)
	  {
		  recIds = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForSource(tenantId, groupId, totalIds, viewId);
		  suggestedIds = reconciliationDuplicateResultRepository.fetchReconciledIdswithStatusUnreconciledForSource(tenantId, groupId, totalIds, viewId);
		  log.info("RecIds Size: "+recIds.size());
		  log.info("Suggested Ids Size: "+suggestedIds.size());
		  for(BigInteger id : totalIds)
		  {
			  if(!recIds.contains(id))
			  {
				  unRecIds.add(id);
			  }
		  }
		  unRecIds.removeAll(suggestedIds); // Removing suggested Ids
		  log.info("UnRecIds Size: "+unRecIds.size());
		  if("reconciled".equalsIgnoreCase(status))
		  {
			  if(recIds.size()>0)
			  {
				  String currencySymbol = getCurrencySymbolByIds(recIds, currencyCodeColName, dv.getDataViewName());
				  HashMap recAmountCount = reconciliationResultService.getCountNAmountForDVId(BigInteger.valueOf(viewId), tenantId, amountQualifier,recIds);
				  finalMap.put("sAmount", currencySymbol +" " +reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
				  finalMap.put("sCount", recAmountCount.get("totalCount"));
				  finalMap.put("dsCount", recIds.size());
				  
				  finalMap.put("tAmount", 0.0);
				  finalMap.put("tCount", 0);
				  finalMap.put("dtCount", 0);
			  }
		  }
		  else if("unReconciled".equalsIgnoreCase(status))
		  {
			  if(unRecIds.size()>0)
			  {
				  String currencySymbol = getCurrencySymbolByIds(unRecIds, currencyCodeColName, dv.getDataViewName());
				  HashMap recAmountCount = reconciliationResultService.getCountNAmountForDVId(BigInteger.valueOf(viewId), tenantId, amountQualifier,unRecIds);
				  finalMap.put("sAmount", currencySymbol +" " +reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
				  finalMap.put("sCount", recAmountCount.get("totalCount"));
				  finalMap.put("dsCount", recIds.size());
				  
				  finalMap.put("tAmount", 0.0);
				  finalMap.put("tCount", 0);
				  finalMap.put("dtCount", 0);
			  }
		  }
		  else if("suggestion".equalsIgnoreCase(status))
		  {
			  log.info("In Suggestion Block");
			  if(suggestedIds.size()>0)
			  {
				  String currencySymbol = getCurrencySymbolByIds(suggestedIds, currencyCodeColName, dv.getDataViewName());
				  log.info("Currency Symbol: "+currencySymbol);
				  HashMap recAmountCount = reconciliationResultService.getCountNAmountForDVId(BigInteger.valueOf(viewId), tenantId, amountQualifier,suggestedIds);
				  finalMap.put("sAmount", currencySymbol +" " +reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
				  finalMap.put("sCount", recAmountCount.get("totalCount"));
				  finalMap.put("dsCount", suggestedIds.size());
				  
				  finalMap.put("tAmount", 0.0);
				  finalMap.put("tCount", 0);
				  finalMap.put("dtCount", 0);
			  }
		  }
	  }
	  return finalMap;
  }
  
  public HashMap getColSummaryForTarget(String status, String colValue,List<BigInteger> totalIds, Long tenantId, Long groupId, Long viewId) throws ClassNotFoundException, SQLException, ParseException
  {
	  HashMap finalMap = new HashMap();
	  List<BigInteger> recIds = new ArrayList<BigInteger>();
	  List<BigInteger> unRecIds = new ArrayList<BigInteger>();
	  List<BigInteger> suggestedIds = new ArrayList<BigInteger>();
	  DataViews dv = dataViewsRepository.findOne(viewId);
	  String currencyCodeColName = getTransDateQualifier(new BigInteger(viewId.toString()), "CURRENCYCODE");
	  String amountQualifier = getTransDateQualifier(new BigInteger(viewId.toString()), "AMOUNT");
	  Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
	  String currencyFormat = props.getProperty("currencyFormat");
	  if(totalIds.size()>0)
	  {
		  recIds = reconciliationResultRepository.fetchReconciledIdswithStatusUnreconciledForTarget(tenantId, groupId, totalIds, viewId);
		  suggestedIds = reconciliationDuplicateResultRepository.fetchReconciledIdswithStatusUnreconciledForTarget(tenantId, groupId, totalIds, viewId);
		  for(BigInteger id : totalIds)
		  {
			  if(!recIds.contains(id))
			  {
				  unRecIds.add(id);
			  }
		  }
		  unRecIds.removeAll(suggestedIds);
		  if("reconciled".equalsIgnoreCase(status))
		  {
			  if(recIds.size()>0)
			  {
				  String currencySymbol = getCurrencySymbolByIds(recIds, currencyCodeColName, dv.getDataViewName());
				  HashMap recAmountCount = reconciliationResultService.getCountNAmountForDVId(BigInteger.valueOf(viewId), tenantId, amountQualifier,recIds);
				  finalMap.put("tAmount", currencySymbol +" " +reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
				  finalMap.put("tCount", recAmountCount.get("totalCount"));
				  finalMap.put("dtCount", recIds.size());
				  
				  finalMap.put("sAmount", 0.0);
				  finalMap.put("sCount", 0);
				  finalMap.put("dsCount", 0);
			  }
		  }
		  else if("unReconciled".equalsIgnoreCase(status))
		  {
			  if(unRecIds.size()>0)
			  {
				  String currencySymbol = getCurrencySymbolByIds(unRecIds, currencyCodeColName, dv.getDataViewName());
				  HashMap recAmountCount = reconciliationResultService.getCountNAmountForDVId(BigInteger.valueOf(viewId), tenantId, amountQualifier,unRecIds);
				  finalMap.put("tAmount", currencySymbol +" " +reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
				  finalMap.put("tCount", recAmountCount.get("totalCount"));
				  finalMap.put("dtCount", recIds.size());
				  
				  finalMap.put("sAmount", 0.0);
				  finalMap.put("sCount", 0);
				  finalMap.put("dsCount", 0);
			  }
		  }
		  else if("suggestion".equalsIgnoreCase(status))
		  {
			  if(suggestedIds.size()>0)
			  {
				  String currencySymbol = getCurrencySymbolByIds(suggestedIds, currencyCodeColName, dv.getDataViewName());
				  HashMap recAmountCount = reconciliationResultService.getCountNAmountForDVId(BigInteger.valueOf(viewId), tenantId, amountQualifier,suggestedIds);
				  finalMap.put("tAmount", currencySymbol +" " +reconciliationResultService.getAmountInFormat(recAmountCount.get("totalAmount").toString(),currencyFormat));
				  finalMap.put("tCount", recAmountCount.get("totalCount"));
				  finalMap.put("dtCount", recIds.size());
				  
				  finalMap.put("sAmount", 0.0);
				  finalMap.put("sCount", 0);
				  finalMap.put("dsCount", 0);
			  }
		  }
	  }
	  return finalMap;
  }
 
  public HashMap getColumnValuesUnRecSummary2(ReconCountNAmountsDTO params, List<String> sCols, List<String> tCols, List<String> commonCols) throws ClassNotFoundException, SQLException, ParseException
  {
	  HashMap finalMap = new HashMap();
  	  DataViews sdv = dataViewsRepository.findOne(params.getsViewId());
  	  DataViews tdv = dataViewsRepository.findOne(params.gettViewId());
  	  List<HashMap> finalList = new ArrayList<HashMap>();
  	  if(sdv != null && tdv != null)
  	  {
  		 log.info("Source and target views exist.");
  		 if(sCols.size()>0)
  		 {
  			 log.info("Source Columns: "+ sCols);
  			 for(String col : sCols)
  			 {
  				 HashMap mp = getDataTYpeNColumnName(params.getsColumnId());
  				 List<BigInteger> totalOriginalIds = getOriginalIdsByTransDate(params.getsViewId(), params.getRangeFrom(), params.getRangeTo(), mp.get("columnName").toString(), col, mp.get("dataType").toString(), params.getPeriodFactor());
  				 HashMap colMap = getColSummaryForSource(params.getStatus(), col, totalOriginalIds, params.getTenantId(), params.getRuleGroupId(), params.getsViewId());
  				 if(colMap.size()>0)
  				 {
  					 colMap.put("name", col);
  	  				 finalList.add(colMap); 
  				 }
  			 }
  		 }
  		 if(tCols.size()>0)
  		 {
  			 log.info("Target Columns: "+tCols);
  			 for(String col : tCols)
  			 {
  				 HashMap mp = getDataTYpeNColumnName(params.gettColumnId()); 
  				 List<BigInteger> totalOriginalIds = getOriginalIdsByTransDate(params.gettViewId(), params.getRangeFrom(), params.getRangeTo(), mp.get("columnName").toString(), col, mp.get("dataType").toString(), params.getPeriodFactor());

  				 HashMap colMap = getColSummaryForTarget(params.getStatus(), col, totalOriginalIds,params.getTenantId(), params.getRuleGroupId(), params.gettViewId());
  				 if(colMap.size()>0)
  				 {
  					 colMap.put("name", col);
  	  				 finalList.add(colMap);
  				 }
  			 }
  		 }
  		 if(commonCols.size()>0)
  		 {
  			 log.info("Common Columns: "+ commonCols);
  			 for(String col : commonCols)
  			 {
  				 HashMap smp = getDataTYpeNColumnName(params.getsColumnId());
  				 List<BigInteger> sTotalIds = getOriginalIdsByTransDate(params.getsViewId(), params.getRangeFrom(), params.getRangeTo(), smp.get("columnName").toString(), col, smp.get("dataType").toString(), params.getPeriodFactor());

  				 HashMap tmp = getDataTYpeNColumnName(params.gettColumnId()); 
  				 List<BigInteger> tTotalIds = getOriginalIdsByTransDate(params.gettViewId(), params.getRangeFrom(), params.getRangeTo(), tmp.get("columnName").toString(), col, tmp.get("dataType").toString(), params.getPeriodFactor());
  				 
  				 HashMap colMapSrc = getColSummaryForSource(params.getStatus(), col, sTotalIds,params.getTenantId(), params.getRuleGroupId(), params.getsViewId());
  				 HashMap colMapTrgt = getColSummaryForTarget(params.getStatus(), col, tTotalIds,params.getTenantId(), params.getRuleGroupId(), params.gettViewId());
  				 log.info("Common: SourceMap: "+colMapSrc+", TargetMap: "+colMapTrgt);
  				 if(colMapSrc.size() > 0 && colMapTrgt.size() > 0)
  				 {
  					 HashMap commonMap = new HashMap();
  					 commonMap.put("sAmount", colMapSrc.get("sAmount").toString());
  					 commonMap.put("sCount", colMapSrc.get("sCount").toString());
  					 commonMap.put("dsCount", Integer.parseInt(colMapSrc.get("dsCount").toString()));
  					 commonMap.put("name", col); 
  					 commonMap.put("tAmount", colMapTrgt.get("tAmount").toString());
  					 commonMap.put("tCount", colMapTrgt.get("tCount").toString());
  					 commonMap.put("dtCount", Integer.parseInt(colMapTrgt.get("dtCount").toString()));
  					 finalList.add(commonMap);
  				 }
  			 }
  		 }
  	  }
  	  else
  	  {
  		  log.info("There are no data views found for the source view id: "+params.getsViewId() +" or target data view id: "+ params.gettViewId()); 
  	  }
  	  
	  finalMap.put("summary", finalList);
	  finalMap.put("status", "");
	  return finalMap;
  }
  
  public HashMap getColumnValuesUnRecSummary(ReconCountNAmountsDTO params, List<String> sCols, List<String> tCols, List<String> commonCols) throws ClassNotFoundException, SQLException, ParseException
  {
	  HashMap finalMap = new HashMap();
	  List<HashMap> finalList = new ArrayList<HashMap>();
	  Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
  	  DataViews sdv = dataViewsRepository.findOne(params.getsViewId());
  	  DataViews tdv = dataViewsRepository.findOne(params.gettViewId());
  	  if(sdv != null && tdv != null)
  	  {
  		  log.info("Source and target views exist.");
  		  if(sCols.size()>0)
  		  {
  			  log.info("Fetching source column values summary info");
  			  HashMap mp = getDataTYpeNColumnName(params.getsColumnId()); 
  			  log.info("Source column column name: "+ mp.get("columnName").toString()+", data type: "+ mp.get("dataType").toString());
  			  HashMap map = getColValuesUnRecSummaryInfo(sCols, params, "source", mp.get("columnName").toString(), mp.get("dataType").toString());
  			  finalList.addAll((List<HashMap>) map.get("summary"));
  			  log.info("Source column values summary size: "+ finalList.size());
  		  }
  		  if(tCols.size()>0)
  		  {
  			log.info("Fetching target column values summary info");
  			 HashMap mp = getDataTYpeNColumnName(params.gettColumnId());
  			 HashMap map = getColValuesUnRecSummaryInfo(tCols, params, "target", mp.get("columnName").toString(), mp.get("dataType").toString());
  			 finalList.addAll((List<HashMap>) map.get("summary"));
  		  }
  		  if(commonCols.size()>0)
  		  {
  			 log.info("Fetching common column values summary info");
  			 HashMap map = getColValuesUnRecSummaryInfo(commonCols, params, "common", "", "");
  			 finalList.addAll((List<HashMap>) map.get("summary"));
  		  }
  	  }
  	  else
  	  {
  		 log.info("There are no data views found for the source view id: "+params.getsViewId() +" or target data view id: "+ params.gettViewId()); 
  	  }
	  finalMap.put("summary", finalList);
	  finalMap.put("status", "");
	  return finalMap;
  }
  
  @Transactional
  public List<BigInteger> getOriginalIdsForDays(Long viewId, String rangeFrom, String rangeTo, String qualifier, String transDate, String periodFactor) throws SQLException
  {
	   List<BigInteger> viewOriginalIds = new ArrayList<BigInteger>();
	   Connection conn = null;
	   Statement stmt = null;
	   ResultSet result = null; 
	   try{
		   String dbUrl=env.getProperty("spring.datasource.url");
		   String[] parts=dbUrl.split("[\\s@&?$+-]+");
		   String host = parts[0].split("/")[2].split(":")[0];
		   String schemaName=parts[0].split("/")[3];
		   String userName = env.getProperty("spring.datasource.username");
		   String password = env.getProperty("spring.datasource.password");
		   String jdbcDriver = env.getProperty("spring.datasource.jdbcdriver");  
  		
		   Class.forName(jdbcDriver);
		   conn = DriverManager.getConnection(dbUrl, userName, password);
		   stmt = conn.createStatement();
    	   DataViews dv=dataViewsRepository.findOne(viewId.longValue());
    	   
    	   if(dv!= null)
    	   {
    		   String viewName = dv.getDataViewName();
        	   String query = "";
        	   if("fileDate".equalsIgnoreCase(periodFactor))
        	   {
        		   log.info("Total Ids Query: "+"SELECT scrIds FROM "+schemaName+".`"+viewName.toLowerCase()+"` where Date(fileDate) between '"+rangeFrom+"' AND '"+rangeTo+"' and Date(fileDate) REGEXP '"+transDate+"'");
         		   query = "SELECT scrIds FROM "+schemaName+".`"+viewName.toLowerCase()+"` where Date(fileDate) between '"+rangeFrom+"' AND '"+rangeTo+"' and Date(fileDate) REGEXP '"+transDate+"'";
        	   }
        	   else if("dateQualifier".equalsIgnoreCase(periodFactor))
        	   {
        		   log.info("Total Ids Query: "+"SELECT scrIds FROM "+schemaName+".`"+viewName.toLowerCase()+"` where Date(`"+qualifier+"`) between '"+rangeFrom+"' AND '"+rangeTo+"' and Date(`"+qualifier+"`) REGEXP '"+transDate+"'");
        		   query = "SELECT scrIds FROM "+schemaName+".`"+viewName.toLowerCase()+"` where Date(`"+qualifier+"`) between '"+rangeFrom+"' AND '"+rangeTo+"' and Date(`"+qualifier+"`) REGEXP '"+transDate+"'";
        	   }
        	   //log.info("Query: "+ query);
        	   result=stmt.executeQuery(query);
	       	   while(result.next()){
	       		   viewOriginalIds.add(new BigInteger((result.getString(1))));
	       	   }  
    	   }
    	   else
    	   {
    		   log.info("View doen't not exist for the view id: "+viewId);
    	   }
	   }
	   catch(SQLException se){
		   log.info("Error while executing query: "+se);
      }
	   catch(Exception e)
	   {
		   log.info("Exception while getting databse properties");
	   }
	   finally{
	   		if(result != null)
	   			result.close();	
	   		if(stmt != null)
	   			stmt.close();
			if(conn != null)
				conn.close();
			}
  	return viewOriginalIds;

  }

  public HashMap updateAppModuleSummaryForSource(String amountQualifier, Long viewId, Long groupId, String module, String type, String status, Long userId) throws SQLException, ClassNotFoundException
  {
	  	log.info("Updating counts and amounts in app_module_summary table for source...");
	  	HashMap finalMap = new HashMap();
	  	Connection conn = null;
	  	Statement countAmntsStmt = null;
	  	ResultSet countAmntsRS = null;
	  	
	  	Statement dvStmt = null;
	  	ResultSet dvRS = null;	  	
	  	
    	PreparedStatement appModSumIdsStmt = null;
    	ResultSet appModSumIdsRS = null;
    	
    	PreparedStatement checkRecordStmt = null;
    	ResultSet checkRecordRS = null;

    	Statement updateExistedRecordStmt = null;
    	String timeStamp = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date());

    	try
	  	{
	  		String dbUrl=env.getProperty("spring.datasource.url");
	  		String[] parts=dbUrl.split("[\\s@&?$+-]+");
	  		String host = parts[0].split("/")[2].split(":")[0];
	  		String schemaName=parts[0].split("/")[3];
	  		String userName = env.getProperty("spring.datasource.username");
	  		String password = env.getProperty("spring.datasource.password");
	  		String jdbcDriver = env.getProperty("spring.datasource.jdbcdriver");
	  		try {
				Class.forName(jdbcDriver);
			} catch (Exception e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
	  		
	  		conn = DriverManager.getConnection(dbUrl, userName, password);
	  		DataViews dv=dataViewsRepository.findOne(viewId.longValue());
	    	// Fetching app_module_summary ids based on status
	    	String appModSumIdsQuery = "select id from "+schemaName+".t_app_module_summary where rule_group_id = "+groupId+" and view_id = "+viewId+" and module = 'Reconciliation' and type = 'Source'";
	    	List<Long> appModSumIds = new ArrayList<Long>();
	    	appModSumIdsStmt = conn.prepareStatement(appModSumIdsQuery);
    		appModSumIdsRS = appModSumIdsStmt.executeQuery();
		    while(appModSumIdsRS.next())
		    {
		    	appModSumIds.add(appModSumIdsRS.getLong(1));
		    }
    		log.info("App Module Summary Ids: "+appModSumIds.size());

	  		if(dv != null)
	  		{
	  			String dvQuery = "select Date(fileDate), count(*), sum(`"+amountQualifier+"`) from "+schemaName+".`"+dv.getDataViewName().toLowerCase()+"` group by Date(fileDate)";
	  			dvStmt = conn.createStatement();
	  			dvRS = dvStmt.executeQuery(dvQuery);
	  			HashMap dvMap = new HashMap();
	  			while(dvRS.next())
	  			{
	  				HashMap dateMap = new HashMap();
	  				dateMap.put("count", dvRS.getString(2));
	  				dateMap.put("amount", dvRS.getString(3));
	  				dvMap.put(dvRS.getString(1), dateMap);
	  			}
	  			log.info("DV Dates Count And Amounts Size: "+dvMap.size());
		  		String query = "select Date(dv.`fileDate`), count(*), sum(dv.`"+amountQualifier+"`),"
		  				+ "    recon.reconciliation_rule_id, recon.reconciliation_rule_group_id"
		  				+ "    from "+schemaName+".t_reconciliation_result recon,"
		  				+ "    "+schemaName+".`"+dv.getDataViewName().toLowerCase()+"` dv"
		  				+ "	   where reconciliation_rule_group_id = "+groupId+" "
		  				+ "    and original_view_id = "+viewId+""
		  				+ "    and current_record_flag is true"
		  				+ "    and recon.original_row_id = dv.scrIds"
		  				+ "    and recon_status = 'RECONCILED'"
		  				+ "    group by Date(dv.`fileDate`),reconciliation_rule_id, reconciliation_rule_group_id";
		  		
				countAmntsStmt = conn.createStatement();
		  		countAmntsRS = countAmntsStmt.executeQuery(query);
		  		
		  		while(countAmntsRS.next()){
		    		  String date = countAmntsRS.getString(1);
		    		  Long count = Long.parseLong(countAmntsRS.getString(2));
		    		  BigDecimal amount = new BigDecimal(countAmntsRS.getString(3));
		    		  Long ruleId = Long.parseLong(countAmntsRS.getString(4));
		    		  LocalDate localDate = LocalDate.parse(date);
		    		  HashMap getDVMap = (HashMap) dvMap.get(date);
		    		  Long dvCount = Long.parseLong(getDVMap.get("count").toString());
		    		  BigDecimal dvAmount = new BigDecimal(getDVMap.get("amount").toString());
/*		    		  
		    		  AppModuleSummary checkRecord = appModuleSummaryRepository.findByFileDateAndModuleAndRuleGroupIdAndRuleIdAndViewIdAndType(localDate, module, groupId, ruleId, viewId, type);
*/		    		  
	    		    	// Check to record exist in app_module_summary table or not
	    		    	String checkRecordquery = "select * from "+schemaName+".t_app_module_summary where file_date = '"+date+"' and module = 'Reconciliation' and rule_group_id = "+groupId+" and rule_id = "+ruleId+" and view_id = "+viewId+" and type = 'Source'";

	    		    	checkRecordStmt = conn.prepareStatement(checkRecordquery);
	    		    	checkRecordRS = checkRecordStmt.executeQuery();
	    		    	int size = 0;
	    		    	Long id = null;
	    		    	while(checkRecordRS.next())
	    		    	{
	    		    		id = Long.parseLong(checkRecordRS.getString("id"));
	    		    		size = size + 1;
	    		    	}
	    		    	log.info("AppModuleSummaryID: "+id+", Size: "+size);

	    		    	if(size > 0)
	    		    	{
	    		    		if(size == 1)
	    		    		{
	    		    			// Updating existing record
	    		    			String updateQuery =  "update "+schemaName+".t_app_module_summary set type_count = "+count+", type_amt = "+amount+", dv_count = "+dvCount+", dv_amt = "+dvAmount+", last_updated_date = '"+timeStamp+"', last_updated_by = "+userId+" where id = "+id;
	    		    			updateExistedRecordStmt = conn.createStatement();
	    		    			updateExistedRecordStmt.executeUpdate(updateQuery);
	    		    			log.info("Updated app module summary for id: "+id);
	    		    			appModSumIds.remove(id);	// Removing updated Record
	    		    		}
	    		    		else
	    		    		{
	    		    			log.info("Duplicate records exist while updating count and amounts for the group id: "+ groupId+", viewId: "+ viewId+", date: "+ date+", ruleId: "+ ruleId+", status: Source, module: Reconciliation");
	    		    		}
	    		    	}
	    		    	else
	    		    	{
	    		    		log.info("Need to insert a record once data transmission has been completed for group id: "+ groupId+", viewId: "+ viewId+", date: "+ date+", ruleId: "+ ruleId+", status: Source, module: Reconciliation");
	    		    
	    		    		String insertTableSQL = "INSERT INTO "+schemaName+".t_app_module_summary"
	    		    				+ "(file_date, module, rule_group_id, rule_id, view_id, type, type_count, created_date, last_updated_date, type_amt, dv_count, dv_amt) VALUES"
	    		    				+ "(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
	    				    PreparedStatement preparedStatement = conn.prepareStatement(insertTableSQL);
	    				    preparedStatement.setDate(1, java.sql.Date.valueOf(date));
	    				    preparedStatement.setString(2, "Reconciliation");
	    				    preparedStatement.setLong(3, groupId);
	    				    if(ruleId != null)
	    				    {
	    				    	preparedStatement.setLong(4, ruleId);	
	    				   	}
	    				   	else
	    				   	{
	    				    	preparedStatement.setNull(4, java.sql.Types.INTEGER);
	    				   	}
	    				    preparedStatement.setLong(5, viewId);
	    				    preparedStatement.setString(6, "Source");
	    				    preparedStatement.setLong(7, count);
	    				    preparedStatement.setTimestamp(8, new java.sql.Timestamp(System.currentTimeMillis()));
	    				   	preparedStatement.setTimestamp(9, new java.sql.Timestamp(System.currentTimeMillis()));
	    				  	preparedStatement.setBigDecimal(10, amount);
	    				  	preparedStatement.setLong(11, dvCount);
	    				  	preparedStatement.setBigDecimal(12, dvAmount);
	    			 		// execute insert SQL stetement
	    		    		preparedStatement .executeUpdate();
	    		    	}
		  		}
		  		log.info("AppModuleSummaryIds After removing Ids: "+appModSumIds);
		  		if(appModSumIds.size()>0)
		  		{
    		    	for(Long id : appModSumIds)
    		    	{
    		    		String dvCountAmtQuery = "select * from t_app_module_summary where id = "+id;
    		  			dvStmt = conn.createStatement();
    		  			dvRS = dvStmt.executeQuery(dvCountAmtQuery);
    		  			Long dvCount = 0L;
    		  			BigDecimal dvAmount = new BigDecimal("0.0");
    		  			String date = "";
    		  			while(dvRS.next())
    		  			{
    		  				date = dvRS.getString("file_date");
    		  			}
    		  			HashMap getDVMap = (HashMap) dvMap.get(date);
    		  			if(getDVMap != null)
    		  			{
        		  			dvCount = Long.parseLong(getDVMap.get("count").toString());
        		  			dvAmount = new BigDecimal(getDVMap.get("amount").toString());
    		  			}

    		    		String updateQuery = "update "+schemaName+".t_app_module_summary set type_count = 0, type_amt = 0.0, dv_count = "+dvCount+", dv_amt = "+dvAmount+", last_updated_date = '"+timeStamp+"', last_updated_by = "+userId+" where id = "+id;
    		    		updateExistedRecordStmt = conn.createStatement();
    		    		updateExistedRecordStmt.executeUpdate(updateQuery);
    		    	}
    		    	System.out.println("Updated Remainig Records: "+appModSumIds);
		  			log.info("Updated remaining app module summary ids: "+appModSumIds);
		  		}
	  		}
	  	}
	  	catch(Exception e)
	  	{
	  		// log.info("Exception while updating count and amounts in app_module_summary: "+e);
	  	}
	  	finally
	  	{
	  		// ResultSet
	  		if(countAmntsRS != null)
	  			countAmntsRS.close();
    		if(appModSumIdsRS != null)
    			appModSumIdsRS.close();
    		if(checkRecordRS != null)
    			checkRecordRS.close();
    		if(dvRS != null)
    			dvRS.close();
	  		// Statement
		  	if(countAmntsStmt != null)
		  		countAmntsStmt.close();
   	        if(appModSumIdsStmt != null)
   	        	appModSumIdsStmt.close();
   	        if(checkRecordStmt != null)
   	        	checkRecordStmt.close();
   	        if(updateExistedRecordStmt != null)
   	        	updateExistedRecordStmt.close();
   	        if(dvStmt != null)
   	        	dvStmt.close();
	  		// Connection
	  		if(conn != null)
	  			conn.close();
	  	}
	  	
	  	return finalMap;
  }
  
  
  public HashMap updateAppModuleSummaryForTarget(String amountQualifier, Long viewId, Long groupId, String module, String type, String status, Long userId) throws SQLException, ClassNotFoundException
  {
	  	log.info("Updating counts and amounts in app_module_summary table for target...");
	  	HashMap finalMap = new HashMap();
	  	Connection conn = null;
	  	Statement countAmntsStmt = null;
	  	ResultSet countAmntsRS = null;
	  	
	  	PreparedStatement appModSumIdsStmt = null;
	  	ResultSet appModSumIdsRS = null;
  	
	  	PreparedStatement checkRecordStmt = null;
	  	ResultSet checkRecordRS = null;
	  	
	  	Statement dvStmt = null;
	  	ResultSet dvRS = null;	
  	
	  	Statement updateExistedRecordStmt = null;
  	
	  	String timeStamp = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date());
  	
	  	try
	  	{
	  		String dbUrl=env.getProperty("spring.datasource.url");
	  		String[] parts=dbUrl.split("[\\s@&?$+-]+");
	  		String host = parts[0].split("/")[2].split(":")[0];
	  		String schemaName=parts[0].split("/")[3];
	  		String userName = env.getProperty("spring.datasource.username");
	  		String password = env.getProperty("spring.datasource.password");
	  		String jdbcDriver = env.getProperty("spring.datasource.jdbcdriver");  
	  		try {
				Class.forName(jdbcDriver);
			} catch (Exception e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
	  		conn = DriverManager.getConnection(dbUrl, userName, password);
	  		DataViews dv=dataViewsRepository.findOne(viewId.longValue());
	  		
	    	// Fetching app_module_summary ids based on status
	    	String appModSumIdsQuery = "select id from "+schemaName+".t_app_module_summary where rule_group_id = "+groupId+" and view_id = "+viewId+" and module = 'Reconciliation' and type = 'Target'";
	    	List<Long> appModSumIds = new ArrayList<Long>();
	    	appModSumIdsStmt = conn.prepareStatement(appModSumIdsQuery);
	    	appModSumIdsRS = appModSumIdsStmt.executeQuery();
	    	
		    while(appModSumIdsRS.next())
		    {
		    	appModSumIds.add(appModSumIdsRS.getLong(1));
		    }
		    log.info("App Module Summary Ids: "+appModSumIds.size());

	  		if(dv != null)
	  		{
	  			String dvQuery = "select Date(fileDate), count(*), sum(`"+amountQualifier+"`) from "+schemaName+".`"+dv.getDataViewName().toLowerCase()+"` group by Date(fileDate)";
	  			dvStmt = conn.createStatement();
	  			dvRS = dvStmt.executeQuery(dvQuery);
	  			HashMap dvMap = new HashMap();
	  			while(dvRS.next())
	  			{
	  				HashMap dateMap = new HashMap();
	  				dateMap.put("count", dvRS.getString(2));
	  				dateMap.put("amount", dvRS.getString(3));
	  				dvMap.put(dvRS.getString(1), dateMap);
	  			}
	  			log.info("DV Dates Count And Amounts Size: "+dvMap.size());
	  			
		  		String query = "select Date(dv.`fileDate`), count(*), sum(dv.`"+amountQualifier+"`), "
		  				+ "    recon.reconciliation_rule_id, recon.reconciliation_rule_group_id"
		  				+ "    from "+schemaName+".t_reconciliation_result recon,"
		  				+ "    "+schemaName+".`"+dv.getDataViewName().toLowerCase()+"` dv"
		  				+ "	   where reconciliation_rule_group_id = "+groupId+" "
		  				+ "		and target_view_id = "+viewId+""
		  				+ "    and current_record_flag is true"
		  				+ "		and recon.target_row_id = dv.scrIds  "
		  				+ "    and recon_status = 'RECONCILED' "
		  				+ "    group by Date(`fileDate`),reconciliation_rule_id, reconciliation_rule_group_id";
		  		
				countAmntsStmt = conn.createStatement();
		  		countAmntsRS = countAmntsStmt.executeQuery(query);
		  		
		  		while(countAmntsRS.next()){
		    		  String date = countAmntsRS.getString(1);
		    		  Long count = Long.parseLong(countAmntsRS.getString(2));
		    		  BigDecimal amount = new BigDecimal(countAmntsRS.getString(3));
		    		  Long ruleId = Long.parseLong(countAmntsRS.getString(4));
		    		  LocalDate localDate = LocalDate.parse(date);
		    		  HashMap getDVMap = (HashMap) dvMap.get(date);
		    		  Long dvCount = Long.parseLong(getDVMap.get("count").toString());
		    		  BigDecimal dvAmount = new BigDecimal(getDVMap.get("amount").toString());
/*		    		  
		    		  AppModuleSummary checkRecord = appModuleSummaryRepository.findByFileDateAndModuleAndRuleGroupIdAndRuleIdAndViewIdAndType(localDate, module, groupId, ruleId, viewId, type);
*/		    		  
	    		    	// Check to record exist in app_module_summary table or not
	    		    	String checkRecordquery = "select * from "+schemaName+".t_app_module_summary where file_date = '"+date+"' and module = 'Reconciliation' and rule_group_id = "+groupId+" and rule_id = "+ruleId+" and view_id = "+viewId+" and type = 'Target'";

	    		    	checkRecordStmt = conn.prepareStatement(checkRecordquery);
	    		    	checkRecordRS = checkRecordStmt.executeQuery();
	    		    	int size = 0;
	    		    	Long id = null;
	    		    	while(checkRecordRS.next())
	    		    	{
	    		    		id = Long.parseLong(checkRecordRS.getString("id"));
	    		    		size = size + 1;
	    		    	}
	    		    	log.info("AppModuleSummaryID: "+id+", Size: "+size);

	    		    	if(size > 0)
	    		    	{
	    		    		if(size == 1)
	    		    		{
	    		    			// Updating existing record
	    		    			String updateQuery =  "update "+schemaName+".t_app_module_summary set type_count = "+count+", type_amt = "+amount+", dv_count = "+dvCount+", dv_amt = "+dvAmount+", last_updated_date = '"+timeStamp+"', last_updated_by = "+userId+" where id = "+id;
	    		    			updateExistedRecordStmt = conn.createStatement();
	    		    			updateExistedRecordStmt.executeUpdate(updateQuery);
	    		    			log.info("Updated app module summary for id: "+id);
	    		    			appModSumIds.remove(id);	// Removing updated Record
	    		    		}
	    		    		else
	    		    		{
	    		    			log.info("Duplicate records exist while updating count and amounts for the group id: "+ groupId+", viewId: "+ viewId+", date: "+ date+", ruleId: "+ ruleId+", status: Target, module: Reconciliation");
	    		    		}
	    		    	}
	    		    	else
	    		    	{
	    		    		log.info("Need to insert a record once data transmission has been completed for group id: "+ groupId+", viewId: "+ viewId+", date: "+ date+", ruleId: "+ ruleId+", status: Target, module: Reconciliation");
	    		    
	    		    		String insertTableSQL = "INSERT INTO "+schemaName+".t_app_module_summary"
	    		    				+ "(file_date, module, rule_group_id, rule_id, view_id, type, type_count, created_date, last_updated_date, type_amt, dv_count, dv_amt) VALUES"
	    		    				+ "(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
	    				    PreparedStatement preparedStatement = conn.prepareStatement(insertTableSQL);
	    				    preparedStatement.setDate(1, java.sql.Date.valueOf(date));
	    				    preparedStatement.setString(2, "Reconciliation");
	    				    preparedStatement.setLong(3, groupId);
	    				    if(ruleId != null)
	    				    {
	    				    	preparedStatement.setLong(4, ruleId);	
	    				   	}
	    				   	else
	    				   	{
	    				    	preparedStatement.setNull(4, java.sql.Types.INTEGER);
	    				   	}
	    				    preparedStatement.setLong(5, viewId);
	    				    preparedStatement.setString(6, "Target");
	    				    preparedStatement.setLong(7, count);
	    				    preparedStatement.setTimestamp(8, new java.sql.Timestamp(System.currentTimeMillis()));
	    				   	preparedStatement.setTimestamp(9, new java.sql.Timestamp(System.currentTimeMillis()));
	    				  	preparedStatement.setBigDecimal(10, amount);
	    				  	preparedStatement.setLong(11, dvCount);
	    				  	preparedStatement.setBigDecimal(12, dvAmount);
	    			 		// execute insert SQL stetement
	    		    		preparedStatement .executeUpdate();
	    		    	}
		  		}
		  		log.info("AppModuleSummaryIds After removing Ids: "+appModSumIds);
		  		if(appModSumIds.size()>0)
		  		{
	  		    	for(Long id : appModSumIds)
	  		    	{
    		    		String dvCountAmtQuery = "select * from t_app_module_summary where id = "+id;
    		  			dvStmt = conn.createStatement();
    		  			dvRS = dvStmt.executeQuery(dvCountAmtQuery);
    		  			Long dvCount = 0L;
    		  			BigDecimal dvAmount = new BigDecimal("0.0");
    		  			String date = "";
    		  			while(dvRS.next())
    		  			{
    		  				date = dvRS.getString("file_date");
    		  			}
    		  			HashMap getDVMap = (HashMap) dvMap.get(date);
    		  			if(getDVMap != null)
    		  			{
        		  			dvCount = Long.parseLong(getDVMap.get("count").toString());
        		  			dvAmount = new BigDecimal(getDVMap.get("amount").toString());
    		  			}
    		  			
	  		    		String updateQuery = "update "+schemaName+".t_app_module_summary set type_count = 0, type_amt = 0.0, dv_count = "+dvCount+", dv_amt = "+dvAmount+", last_updated_date = '"+timeStamp+"', last_updated_by = "+userId+" where id = "+id;
	  		    		updateExistedRecordStmt = conn.createStatement();
	  		    		updateExistedRecordStmt.executeUpdate(updateQuery);
	  		    	}
	  		    	System.out.println("Updated Remainig Records: "+appModSumIds);
		  			log.info("Updated remaining app module summary ids: "+appModSumIds);
		  		}
	  		}
	  	}
	  	catch(Exception e)
	  	{
	  		// log.info("Exception while updating count and amounts in app_module_summary: "+e);
	  	}
	  	finally
	  	{
	  		// ResultSet
	  		if(countAmntsRS != null)
	  			countAmntsRS.close();
	  		if(appModSumIdsRS != null)
	  			appModSumIdsRS.close();
	  		if(checkRecordRS != null)
	  			checkRecordRS.close();
	  		if(dvRS != null)
				dvRS.close();
	  		// Statement
		  	if(countAmntsStmt != null)
		  		countAmntsStmt.close();
 	        if(appModSumIdsStmt != null)
 	        	appModSumIdsStmt.close();
 	        if(checkRecordStmt != null)
 	        	checkRecordStmt.close();
 	        if(updateExistedRecordStmt != null)
 	        	updateExistedRecordStmt.close();
 	       if(dvStmt != null)
  	        	dvStmt.close();
	  		// Connection
	  		if(conn != null)
	  			conn.close();
	  	}
	  	
	  	return finalMap;
  }
  
	public HashMap updateAppModuleSummaryInfoSource(String amountQualifier, String viewName, Long groupId, Long viewId, String status, Long ruleId, Long userId) throws ClassNotFoundException, SQLException
	{
		System.out.println("Updating count and amounts for for Source Reconciliation...");
		HashMap finalMap = new HashMap();
		Connection conn = null;	
		ResultSet countsAmountsRS = null;
		PreparedStatement fetchCountAmntsStmt = null;
		PreparedStatement checkRecordStmt = null;
		Statement updateStament = null;
		ResultSet checkRecordRS = null;
  	
		PreparedStatement appModSumIdsStmt = null;
		ResultSet appModSumIdsRS = null;
		Statement updateExistedRecordStmt = null;
		
		try
		{
			String timeStamp = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date());
	  		String dbUrl=env.getProperty("spring.datasource.url");
	  		String[] parts=dbUrl.split("[\\s@&?$+-]+");
	  		String host = parts[0].split("/")[2].split(":")[0];
	  		String schemaName=parts[0].split("/")[3];
	  		String userName = env.getProperty("spring.datasource.username");
	  		String password = env.getProperty("spring.datasource.password");
	  		String jdbcDriver = env.getProperty("spring.datasource.jdbcdriver");  
	  		Class.forName(jdbcDriver);
	  		conn = DriverManager.getConnection(dbUrl, userName, password);
			
	    	// Fetching app_module_summary ids based on status
			List<Long> appSummaryIds = new ArrayList<Long>();
			String appModSumIdsQuery = "select id from t_app_module_summary where module = 'Reconciliation' and rule_group_id = "+groupId+" and view_id = "+viewId+" and type = 'Source'";
			appModSumIdsStmt = conn.prepareStatement(appModSumIdsQuery);
			appModSumIdsRS = appModSumIdsStmt.executeQuery();
  		
		    while(appModSumIdsRS.next())
		    {
		    	appSummaryIds.add(appModSumIdsRS.getLong(1));
		    }
		    System.out.println("AppModuleSummaryIds for "+status+" status: "+appSummaryIds);
			
			String countsAmntsQuery = "select Date(grp.`fileDate`), count(*), sum(grp.`"+amountQualifier+"`), grp.reconciliation_rule_id from ("
					+ " 	select dv.*, recon.recon_status,"
					+ "     recon.reconciliation_rule_id"
					+ "     from t_reconciliation_result recon,"
					+ "		t_rule_group_details rgd, "
					+ "     t_rules rl, "
					+ "     "+viewName+" dv"
					+ " 	where reconciliation_rule_group_id = "+groupId+" "
					+ " 	and original_view_id = "+viewId+""
					+ " 	and current_record_flag is true"
					+ "		and reconciliation_rule_group_id = rgd.rule_group_id"
					+ "		and rgd.rule_id = rl.id "
					+ "		and recon.reconciliation_rule_id = rl.id"
					+ "		and recon.original_row_id = dv.scrIds ) grp"
					+ "		where grp.recon_status = '"+status+"' and grp.reconciliation_rule_id = "+ruleId+" group by Date(grp.`fileDate`), grp.reconciliation_rule_id";
			fetchCountAmntsStmt = conn.prepareStatement(countsAmntsQuery);
			countsAmountsRS = fetchCountAmntsStmt.executeQuery();
			
		    while(countsAmountsRS.next())
		    {
		    	String date = countsAmountsRS.getString(1).toString();
		    	Long count = Long.parseLong(countsAmountsRS.getString(2).toString());
		    	Double amount = Double.parseDouble(countsAmountsRS.getString(3).toString());
		    	BigDecimal bdAmount = new BigDecimal(amount);
		    	bdAmount = bdAmount.setScale(2, BigDecimal.ROUND_HALF_UP);
		    	
		    	String query = "select * from t_app_module_summary where file_date = '"+date+"' and module = 'Reconciliation' and rule_group_id = "+groupId+" and rule_id = "+ruleId+" and view_id = "+viewId+" and type = 'Source'";

		    	checkRecordStmt = conn.prepareStatement(query);
		    	checkRecordRS = checkRecordStmt.executeQuery();
		    	int size = 0;
		    	Long id = null;
		    	while(checkRecordRS.next())
		    	{
		    		id = Long.parseLong(checkRecordRS.getString("id"));
		    		size = size + 1;
		    	}
		    	if(size > 0)
		    	{
		    		if(size == 1)
		    		{
		    			  String updateQuery = "UPDATE t_app_module_summary SET type_count = "+count+", type_amt = "+bdAmount+", last_updated_date = '"+timeStamp+"', last_updated_by = "+userId+" where id = "+id;  
		    			  updateStament = conn.createStatement();
		    			  updateStament.executeUpdate(updateQuery);
		    			  appSummaryIds.remove(id);
		    		}
		    		else
		    		{
		    			  System.out.println("Duplicate records exist while updating count and amounts for view id: "+ viewId+", group id: "+ groupId+", rule id: "+ ruleId+", date: "+date);
		    		}
		    	}
		    	else
		    	{
		    		log.info("Amount::: "+ bdAmount);
		    		System.out.println("Need to insert record once data transmission has been completed for "+ groupId+", viewId: "+ viewId+", date: "+ date+", ruleId: "+ ruleId+", status: "+ status+", module: Reconciliation");
		    		String insertTableSQL = "INSERT INTO t_app_module_summary"
		    				+ "(file_date, module, rule_group_id, rule_id, view_id, type, type_count, created_date, last_updated_date, type_amt) VALUES"
		    				+ "(?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
				    		PreparedStatement preparedStatement = conn.prepareStatement(insertTableSQL);
				    		preparedStatement.setDate(1, java.sql.Date.valueOf(date));
				    		preparedStatement.setString(2, "Reconciliation");
				    		preparedStatement.setLong(3, groupId);
				    		if(ruleId != null)
				    		{
				    			preparedStatement.setLong(4, ruleId);	
				    		}
				    		else
				    		{
				    			preparedStatement.setNull(4, java.sql.Types.INTEGER);
				    		}
				    		preparedStatement.setLong(5, viewId);
				    		preparedStatement.setString(6, "Source");
				    		preparedStatement.setLong(7, count);
				    		preparedStatement.setTimestamp(8, new java.sql.Timestamp(System.currentTimeMillis()));
				    		preparedStatement.setTimestamp(9, new java.sql.Timestamp(System.currentTimeMillis()));
				    		preparedStatement.setBigDecimal(10, bdAmount);
				    		// execute insert SQL stetement
				    		preparedStatement .executeUpdate();
		    	}
		    }
		    
		    System.out.println("AppModuleSummaryIds After removing ids: "+appSummaryIds);
		    if(appSummaryIds.size()>0)
		    {
		    	for(Long id : appSummaryIds)
		    	{
		    		String updateQuery = "update t_app_module_summary set type_count = 0, type_amt = 0.0, last_updated_date = '"+timeStamp+"', last_updated_by = "+userId+" where id = "+id;
		    		updateExistedRecordStmt = conn.createStatement();
		    		updateExistedRecordStmt.executeUpdate(updateQuery);
		    	}
		    	System.out.println("Updated Remainig Records: "+appSummaryIds);
		    }
		}
		catch(Exception e)
		{
			System.out.println("Exception while updating count and amounts: "+e);
		}
		finally
		{
			try{

				// ResultSet
				if(countsAmountsRS != null)
					countsAmountsRS.close();
				if(checkRecordRS != null)
					checkRecordRS.close();
				if(appModSumIdsRS != null)
					appModSumIdsRS.close();
				// Statemnt
				if(fetchCountAmntsStmt != null)
					fetchCountAmntsStmt.close();
				if(checkRecordStmt != null)
					checkRecordStmt.close();
				if(updateStament != null)
					updateStament.close();
				if(appModSumIdsStmt != null)
					appModSumIdsStmt.close();
				if(updateExistedRecordStmt != null)
					updateExistedRecordStmt.close();
				// Connection
				if(conn != null)
					conn.close();
			}
			catch(Exception e)
			{
				System.out.println("Exception while closing statements");
			}
		}
		return finalMap;
	}
	
	
	
	
	 @Transactional
	   public HashMap getOriginalIdsByTransDateApprovals(Long viewId, String rangeFrom, String rangeTo, String periodFactor,List<BigInteger> srcIds,String amountQualifier) throws SQLException, ClassNotFoundException
	 {
		 List<BigInteger> viewOriginalIds = new ArrayList<BigInteger>();
		 Connection conn = null;
		 Statement stmt = null;
		 ResultSet result = null; 
		 HashMap finalMap=new HashMap();
		 String srcId=srcIds.toString().replaceAll("\\[", "").replaceAll("\\]", "").replaceAll("\\s", "");

		 try{
			 String dbUrl=env.getProperty("spring.datasource.url");
			 String[] parts=dbUrl.split("[\\s@&?$+-]+");
			 String host = parts[0].split("/")[2].split(":")[0];
			 String schemaName=parts[0].split("/")[3];
			 String userName = env.getProperty("spring.datasource.username");
			 String password = env.getProperty("spring.datasource.password");
			 String jdbcDriver = env.getProperty("spring.datasource.jdbcdriver");  

			 Class.forName(jdbcDriver);
			 conn = DriverManager.getConnection(dbUrl, userName, password);
			 stmt = conn.createStatement();
			 DataViews dv=dataViewsRepository.findOne(viewId.longValue());

			 if(dv!= null)
			 {
				 String viewName = dv.getDataViewName();
				 String query = "";
				 if("fileDate".equalsIgnoreCase(periodFactor))
				 {

					 query = "SELECT count(scrIds),SUM(`"+amountQualifier+"`) FROM "+schemaName+".`"+viewName.toLowerCase()+"` where scrIds in ("+srcId+") and Date(fileDate) between '"+rangeFrom+"' AND '"+rangeTo+"'";
				 }
				 else if("dateQualifier".equalsIgnoreCase(periodFactor))
				 {
					 String dateQualifier = getTransDateQualifier(new BigInteger(viewId.toString()), "TRANSDATE"); 
					 if(dateQualifier.length()>0)
					 {
						 query = "SELECT count(scrIds),SUM(`"+amountQualifier+"`) FROM "+schemaName+".`"+viewName.toLowerCase()+"` where scrIds in ("+srcId+") and Date(`"+dateQualifier+"`) between '"+rangeFrom+"' AND '"+rangeTo+"'";
					 }
				 }
				 //log.info("finalQuery getOriginalIdsByTransDateApprovals :"+query);
				 result=stmt.executeQuery(query);
				 while(result.next()){
					 //log.info("result1 :"+result.getString(1));
					 //log.info("result2 :"+result.getString(2));
					 finalMap.put("count", result.getString(1));
					 finalMap.put("amount", result.getString(2));
				 }  
			 }
			 else
			 {
				 log.info("View doen't not exist for the view id: "+viewId);
			 }
		 }
		 catch(SQLException se){
			 log.info("Error while executing query: "+se);
		 }
		 catch(Exception e)
		 {
			 log.info("Exception while getting databse properties");
		 }
		 finally{
			 if(result != null)
				 result.close();	
			 if(stmt != null)
				 stmt.close();
			 if(conn != null)
				 conn.close();
		 }
		  log.info("Ids Size: "+viewOriginalIds.size());
		 return finalMap;
	 }
	
	 public HashMap fileExport(String newFileName,String newFileName2,String updRes,String name,String localPath,Long tenantId) throws IOException
	 {
		 HashMap pathMap=new HashMap();


		 XSSFWorkbook workBook = new XSSFWorkbook();
		 XSSFSheet sheet1 = workBook.createSheet("sheet1");
		
		 String currentLine=null;
		 int RowNum=0;
		 int RowNumSheet2=0;
		 String xlsxFileAddress = localPath+name.replaceAll("\\s","")+"_"+updRes+".xlsx";

		 BufferedReader br = new BufferedReader(new FileReader(newFileName));
		 while ((currentLine = br.readLine()) != null) {
			 String str[] = currentLine.split(",");
			 XSSFRow currentRow=sheet1.createRow(RowNum);
			 for(int i=0;i<str.length;i++){
				
				 currentRow.createCell(i).setCellValue(str[i]);

			 }
			 RowNum++;
		 }

		 if(newFileName2!=null)
		 {
			 XSSFSheet sheet2 = workBook.createSheet("sheet2");

			 BufferedReader br2 = new BufferedReader(new FileReader(newFileName2));
			 while ((currentLine = br2.readLine()) != null) {
				 String str[] = currentLine.split(",");
				 XSSFRow currentRow=sheet2.createRow(RowNumSheet2);
				 for(int i=0;i<str.length;i++){

					 currentRow.createCell(i).setCellValue(str[i]);

				 }
				 RowNumSheet2++;
			 }
		 }
		 FileOutputStream fileOutputStream =  new FileOutputStream(xlsxFileAddress);
		 workBook.write(fileOutputStream);
		 fileOutputStream.close();

		 File file = new File(xlsxFileAddress);
		 InputStream inputStream=new FileInputStream(file);

		 String[] destPath=fileService.fileUpload(inputStream, name.replaceAll("\\s","")+"_"+updRes+".xlsx");

		 if(destPath[0].equalsIgnoreCase("success"))
		 {
			 pathMap.put("status", destPath[0]);
			 log.info("destPath[1] :"+destPath[1]);
			 String finalFSPath="";
			 TenantConfig fileServerUrl=tenantConfigRepository.findByTenantIdAndKey(tenantId, "File Server Path");

			 if(fileServerUrl!=null)
				 finalFSPath=fileServerUrl.getValue()+destPath[1];
			 else
			 {
				 fileServerUrl=tenantConfigRepository.findByTenantIdAndKey(0l, "File Server Path");
				 finalFSPath=fileServerUrl.getValue()+destPath[1];
			 }

			 pathMap.put("destPath", finalFSPath);
		 }
		 else
		 {
			 pathMap.put("status", "failure");
		 }
		 return pathMap;


	 }

	 
	 public HashMap getSuggestionSummaryForRules(ReconCountNAmountsDTO params, List<BigInteger> ruleIds) throws ClassNotFoundException, SQLException, ParseException
	 {
		 Long tenantId = params.getTenantId();
		 Long groupId = params.getRuleGroupId();
		 Long sViewId = params.getsViewId();
		 Long tViewId = params.gettViewId();
		 HashMap finalMap = new HashMap();
		 log.info("Fetching Suggestion counts and amounts for the tenant id: "+ tenantId+", group id: "+ groupId+", source view id: "+sViewId+", target view id "+ tViewId);
		 List<HashMap> groupedList = new ArrayList<HashMap>();
		 List<BigInteger> sTotalIds = new ArrayList<BigInteger>();
		 List<BigInteger> tTotalIds = new ArrayList<BigInteger>();
		 List<BigInteger> sRecIds = new ArrayList<BigInteger>();
		 List<BigInteger> tRecIds = new ArrayList<BigInteger>();
		 DataViews sdv = dataViewsRepository.findOne(params.getsViewId());
		 DataViews tdv = dataViewsRepository.findOne(params.gettViewId());
		 String sCurrencyCode = getTransDateQualifier(BigInteger.valueOf(params.getsViewId()), "CURRENCYCODE");
		 String tCurrencyCode = getTransDateQualifier(BigInteger.valueOf(params.gettViewId()), "CURRENCYCODE");
		  
		 String sAmountQualifier = getTransDateQualifier(BigInteger.valueOf(params.getsViewId()), "AMOUNT");
		 String tAmountQualifier = getTransDateQualifier(BigInteger.valueOf(params.gettViewId()), "AMOUNT");
		  
		 Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
		 String currencyFormat = props.getProperty("currencyFormat");
		 if(sdv != null && tdv != null)
		 {
			 try{
				 HashMap sTotalIdsMap = getTotalByPeriodFactor(params.getsViewId(), params.getPeriodFactor(), params.getRangeFrom(), params.getRangeTo());
				 HashMap tTotalIdsMap = getTotalByPeriodFactor(params.gettViewId(), params.getPeriodFactor(), params.getRangeFrom(), params.getRangeTo());
				 if("Success".equalsIgnoreCase(sTotalIdsMap.get("status").toString()) && "Success".equalsIgnoreCase(tTotalIdsMap.get("status").toString()))
				 {
					 sTotalIds = (List<BigInteger>) sTotalIdsMap.get("totalIds");
					 tTotalIds = (List<BigInteger>) tTotalIdsMap.get("totalIds");
				 }
				 else
				 {
					 log.info("Error while fetching total ids for the source view : "+params.getsViewId()+", or target view: "+params.gettViewId());
				 } 
			 }
			 catch(Exception e)
			 {
				 log.info("Error while fetching total ids for the source view : "+params.getsViewId()+", or target view: "+params.gettViewId());
			 }
			 if(sTotalIds.size()>0 && tTotalIds.size()>0)
			 {
				 for(BigInteger ruleId : ruleIds)
				 {
					 HashMap recMap = new HashMap();
					 Rules rule = rulesRepository.findOne(ruleId.longValue());
					 if(rule != null)
					 {
						 recMap.put("id", ruleId);
						 recMap.put("name", rule.getRuleCode());
					 }

					  List<Long> ruleIdSingle = new ArrayList<Long>();
					  ruleIdSingle.add(ruleId.longValue());

					  sRecIds = reconciliationDuplicateResultRepository.fetchSuggestionIdsWithRulesForSource(tenantId, ruleIdSingle, groupId, sTotalIds,params.getsViewId());
					  tRecIds = reconciliationDuplicateResultRepository.fetchSuggestionIdsWithRulesForTarget(tenantId, ruleIdSingle, groupId, tTotalIds, params.gettViewId());

					  String sRecCurrencySymbol = "";
					  List<String> sRecCurrencies = getDistColumnValues(sRecIds,sCurrencyCode,sdv.getDataViewName());
					  if(sRecCurrencies.size()==1)
					  {
						  sRecCurrencySymbol = sRecCurrencySymbol+getCurrencySymbol(sRecCurrencies.get(0));
					  }
					  else if(sRecCurrencies.size()>1)
					  {
						  sRecCurrencySymbol = sRecCurrencySymbol+"*";
					  }
					  
					  String tRecCurrencySymbol = "";
					  List<String> tRecCurrencies = getDistColumnValues(tRecIds,tCurrencyCode,tdv.getDataViewName());
					  if(tRecCurrencies.size()==1)
					  {
						  tRecCurrencySymbol = tRecCurrencySymbol+getCurrencySymbol(tRecCurrencies.get(0));
					  }
					  else if(tRecCurrencies.size()>1)
					  {
						  tRecCurrencySymbol = tRecCurrencySymbol+"*";
					  }
				  		
					  HashMap sRecCountNAmount = reconciliationResultService.getCountNAmountForDVId(BigInteger.valueOf(params.getsViewId()), tenantId, sAmountQualifier,sRecIds);
					  recMap.put("sAmount", sRecCurrencySymbol+" "+reconciliationResultService.getAmountInFormat(sRecCountNAmount.get("totalAmount").toString(),currencyFormat));
					  recMap.put("sCount", sRecCountNAmount.get("totalCount"));
					  recMap.put("dsCount", sRecIds.size());
					  recMap.put("sCurrency", sRecCurrencySymbol);
					  recMap.put("sAmountValue", sRecCountNAmount.get("totalAmount"));
						
					  HashMap tRecCountNAmount = reconciliationResultService.getCountNAmountForDVId(BigInteger.valueOf(params.gettViewId()), tenantId, tAmountQualifier,tRecIds);
					  recMap.put("tAmount", tRecCurrencySymbol+" "+reconciliationResultService.getAmountInFormat(tRecCountNAmount.get("totalAmount").toString(),currencyFormat));
					  recMap.put("tCount", tRecCountNAmount.get("totalCount"));
					  recMap.put("dtCount", tRecIds.size());
					  recMap.put("tCurrency", tRecIds.size());
					  recMap.put("tAmountValue", tRecCountNAmount.get("totalAmount"));

					  groupedList.add(recMap);

				  	}
			  }
			  else
			  {
				  log.info("No records fournd for the source view id: "+params.getsViewId()+", or target view id: "+params.gettViewId());
			  }
		  }
		  else
		  {
			  log.info("Source view i: "+ params.getsViewId()+" or target view id: "+ params.gettViewId()+" doesn't exist");
		  }
		  finalMap.put("summary", groupedList);
		  finalMap.put("status", "");
		  return finalMap;
	 }

	  public HashMap getSuggestionSummaryForBatches(ReconCountNAmountsDTO params, List<String> batches) throws ClassNotFoundException, SQLException, ParseException
	  {	
		  Long tenantId = params.getTenantId();
		  Long groupId = params.getRuleGroupId();
		  Long sViewId = params.getsViewId();
		  Long tViewId = params.gettViewId();
		  HashMap finalMap = new HashMap();
		  log.info("Fetching Suggestion Data counts and amounts for the tenant id: "+ tenantId+", group id: "+ groupId+", source view id: "+sViewId+", target view id "+ tViewId);
		  List<HashMap> groupedList = new ArrayList<HashMap>();
		  List<BigInteger> sTotalIds = new ArrayList<BigInteger>();
		  List<BigInteger> tTotalIds = new ArrayList<BigInteger>();
		  List<BigInteger> sRecIds = new ArrayList<BigInteger>();
		  List<BigInteger> tRecIds = new ArrayList<BigInteger>();
		  DataViews sdv = dataViewsRepository.findOne(params.getsViewId());
		  DataViews tdv = dataViewsRepository.findOne(params.gettViewId());
		  String sCurrencyCode = getTransDateQualifier(BigInteger.valueOf(params.getsViewId()), "CURRENCYCODE");
		  String tCurrencyCode = getTransDateQualifier(BigInteger.valueOf(params.gettViewId()), "CURRENCYCODE");
		  
		  String sAmountQualifier = getTransDateQualifier(BigInteger.valueOf(params.getsViewId()), "AMOUNT");
		  String tAmountQualifier = getTransDateQualifier(BigInteger.valueOf(params.gettViewId()), "AMOUNT");
		  log.info("sCurrencyCode: "+sCurrencyCode+", tCurrencyCode: "+tCurrencyCode+", sAmountQualifier: "+sAmountQualifier+". "+tAmountQualifier);
		  Properties props = propertiesUtilService.getPropertiesFromClasspath("File.properties");
		  String currencyFormat = props.getProperty("currencyFormat");
		   
		  if(sdv != null && tdv != null)
		  {
			  try{
				  HashMap sTotalIdsMap = getTotalByPeriodFactor(params.getsViewId(), params.getPeriodFactor(), params.getRangeFrom(), params.getRangeTo());
				  HashMap tTotalIdsMap = getTotalByPeriodFactor(params.gettViewId(), params.getPeriodFactor(), params.getRangeFrom(), params.getRangeTo());
				  if("Success".equalsIgnoreCase(sTotalIdsMap.get("status").toString()) && "Success".equalsIgnoreCase(tTotalIdsMap.get("status").toString()))
				  {
					  sTotalIds = (List<BigInteger>) sTotalIdsMap.get("totalIds");
					  tTotalIds = (List<BigInteger>) tTotalIdsMap.get("totalIds");
				  }
				  else
				  {
					  log.info("Error while fetching total ids for the source view : "+params.getsViewId()+", or target view: "+params.gettViewId());
				  } 
			  }
			  catch(Exception e)
			  {
				  log.info("Error while fetching total ids for the source view : "+params.getsViewId()+", or target view: "+params.gettViewId());
			  }
			  log.info("sTotalIds.size(): "+sTotalIds.size()+", tTotalIds.size(): "+tTotalIds.size());
			  if(sTotalIds.size()>0 && tTotalIds.size()>0)
			  {
				  for(String batch : batches)
				  {
					  HashMap recMap = new HashMap();
					  recMap.put("name", batch);

					  sRecIds = reconciliationDuplicateResultRepository.fetchReconciledIdswithJobReferenceForSource(tenantId, groupId, sTotalIds, batch, params.getsViewId());
					  tRecIds = reconciliationDuplicateResultRepository.fetchReconciledIdswithJobReferenceForTarget(tenantId, groupId, tTotalIds, batch, params.gettViewId());
					  
					  log.info("Batch: "+batch+", sRecIds.size(): "+sRecIds.size()+", tRecIds: "+tRecIds.size());
					  
					  String sRecCurrencySymbol = "";
					  List<String> sRecCurrencies = getDistColumnValues(sRecIds,sCurrencyCode,sdv.getDataViewName());
					  if(sRecCurrencies.size()==1)
					  {
						  sRecCurrencySymbol = sRecCurrencySymbol+getCurrencySymbol(sRecCurrencies.get(0));
					  }
					  else if(sRecCurrencies.size()>1)
					  {
						  sRecCurrencySymbol = sRecCurrencySymbol+"*";
					  }
				  		
					  String tRecCurrencySymbol = "";
					  List<String> tRecCurrencies = getDistColumnValues(tRecIds,tCurrencyCode,tdv.getDataViewName());
					  if(tRecCurrencies.size()==1)
					  {
						  tRecCurrencySymbol = tRecCurrencySymbol+getCurrencySymbol(tRecCurrencies.get(0));
					  }
					  else if(tRecCurrencies.size()>1)
					  {
						  tRecCurrencySymbol = tRecCurrencySymbol+"*";
					  }

					  HashMap sRecCountNAmount = reconciliationResultService.getCountNAmountForDVId(BigInteger.valueOf(params.getsViewId()), tenantId, sAmountQualifier,sRecIds);
					  recMap.put("sAmount", sRecCurrencySymbol+" "+reconciliationResultService.getAmountInFormat(sRecCountNAmount.get("totalAmount").toString(),currencyFormat));
					  recMap.put("sCount", sRecCountNAmount.get("totalCount"));
					  recMap.put("dsCount", sRecIds.size());
					  recMap.put("sCurrency", sRecCurrencySymbol);
					  recMap.put("sAmountValue", sRecCountNAmount.get("totalAmount"));
						
					  HashMap tRecCountNAmount = reconciliationResultService.getCountNAmountForDVId(BigInteger.valueOf(params.gettViewId()), tenantId, tAmountQualifier,tRecIds);
					  recMap.put("tAmount", tRecCurrencySymbol+" "+reconciliationResultService.getAmountInFormat(tRecCountNAmount.get("totalAmount").toString(),currencyFormat));
					  recMap.put("tCount", tRecCountNAmount.get("totalCount"));
					  recMap.put("dtCount", tRecIds.size());
					  recMap.put("tCurrency", tRecCurrencySymbol);
					  recMap.put("tAmountValue", tRecCountNAmount.get("totalAmount"));
					  log.info("Batch: "+ batch+", map: "+recMap);
					  groupedList.add(recMap);
				  }
			  }
			  else
			  {
				  log.info("No records fournd for the source view id: "+params.getsViewId()+", or target view id: "+params.gettViewId());
			  }
		  }
		  else
		  {
			  log.info("Source view i: "+ params.getsViewId()+" or target view id: "+ params.gettViewId()+" doesn't exist");
		  }
		  finalMap.put("summary", groupedList);
		  finalMap.put("status", "");
		  log.info("Final Map Size: "+groupedList.size());
		  return finalMap;
	/*  }

	 
		 if(destPath[0].equalsIgnoreCase("success"))
		 {
			 pathMap.put("status", destPath[0]);
			 log.info("destPath[1] :"+destPath[1]);
			 String finalFSPath="";
			 TenantConfig fileServerUrl=tenantConfigRepository.findByTenantIdAndKey(tenantId, "File Server Path");

			 if(fileServerUrl!=null)
				 finalFSPath=fileServerUrl.getValue()+destPath[1];
			 else
			 {
				 fileServerUrl=tenantConfigRepository.findByTenantIdAndKey(0l, "File Server Path");
				 finalFSPath=fileServerUrl.getValue()+destPath[1];
			 }

			 pathMap.put("destPath", finalFSPath);
		 }
		 else
		 {
			 pathMap.put("status", "failure");
		 }
		 return pathMap;*/


	 }
	
	 
	 
	
	 
	    public List<LinkedHashMap> getReconDataDetailInfoByViewIds(HttpServletRequest request,@RequestParam(value = "pageNumber", required=false) Long pageNumber, @RequestParam(value = "pageSize", required=false) Long pageSize, 
	    		@RequestParam(value = "exportFile", required=false) String exportFile,@RequestBody RWQDetailInfoDTO params) throws ClassNotFoundException, SQLException, java.text.ParseException, IOException{
	    	HashMap map=userJdbcService.getuserInfoFromToken(request);
	    	Long tenantId=Long.parseLong(map.get("tenantId").toString());
	    	params.setTenantId(tenantId);
	    	List<LinkedHashMap> finalList = new ArrayList<LinkedHashMap>();
			Long limit = 0L;
			limit = (pageNumber * pageSize + 1)-1;
			log.info("Limit Starting Values : "+ limit);
			log.info("Page Number : "+ pageNumber);
			String amtQualifier = reconciliationResultService.getQualifierColumnName(BigInteger.valueOf(params.getDataViewId()));
			log.info("AmountQualifier::: "+ amtQualifier);
			log.info("SortByColumnId::: "+params.getSortByColumnId());
			HashMap colNameNType = new HashMap();
			colNameNType.put("columnName", params.getSortByColumnId());
			colNameNType.put("dataType", params.getDataType());
			/*reconciliationResultService.getColNameNType(params.getSortByColumnId());*/
	    	/*log.info("columnName: "+colNameNType.get("columnName")+", data type: "+colNameNType.get("dataType"));*/
	    	String columnsString = reconciliationResultService.getColumnNamesAsString(params.getDataViewId());
	    	RWQDataFetchDTO keyValues = params.getKeyValues();
	    	ManualUnRecByColumnDTO columnvalues = keyValues.getColumnValues();
	    	List<HashMap> searchColumnsMps = params.getColumnSearch();
	    	//Building Column Search functionaligy Query
	    	String columnSearchQuery = "";
	    	String statusNReconRefQuery = "";
			HashMap recNStatusMp = new HashMap();
	    	if(params.getColumnSearch() != null)
	    	{
	    		if(searchColumnsMps.size()>0)
	    		{
	    			for(int i=0; i<searchColumnsMps.size(); i++)
	    			{
	    				HashMap mp = searchColumnsMps.get(i);
	    				String searchWord = mp.get("searchWord").toString();
	    				if("recon_reference".equalsIgnoreCase(mp.get("columnId").toString()) || "recon_status".equalsIgnoreCase(mp.get("columnId").toString()))
	    				{
	        				if("recon_status".equalsIgnoreCase(mp.get("columnId").toString()))
	        				{
	        					//recNStatusMp.put("recon_status", searchWord);
	        					statusNReconRefQuery = statusNReconRefQuery + " AND reconStatus LIKE '%" + searchWord + "%'";
	        				}
	        				if("recon_reference".equalsIgnoreCase(mp.get("columnId").toString()))
	        				{
	        					//recNStatusMp.put("recon_reference", searchWord);
	        					statusNReconRefQuery = statusNReconRefQuery + " AND reconReference LIKE '%"+searchWord + "%'";
	        				}
	    				}
	    				else
	    				{
	        				Long columnId = Long.parseLong(mp.get("columnId").toString());
	        				HashMap colInfo = reconciliationResultService.getColNameNType(columnId);
	        				String colName = colInfo.get("columnName").toString();
	        				String dataType = colInfo.get("dataType").toString();
	            			if(i == searchColumnsMps.size()-1)
	            			{
	            				columnSearchQuery = columnSearchQuery + " AND `" + colName +"` LIKE '%"+searchWord+"%'";
	            			}
	            			else
	            			{
	            				columnSearchQuery = columnSearchQuery + " AND `" + colName +"` LIKE '%"+searchWord+"%'";
	            			}
	    				}
	    			}
	    		}
	    	}
	    	log.info("Column Search Query: " + columnSearchQuery);
	    	log.info("Recon Reference or Recon Status Search Query: "+statusNReconRefQuery);
	    	if("reconciled".equalsIgnoreCase(params.getStatus()))
	    	{
	    		log.info("Fetching reconciled data");
	    		if("source".equalsIgnoreCase(params.getSourceOrTarget()))
	    		{
	    			log.info("Feching reconciled source data");
	    			HashMap headerColumns = reconciliationResultService.getColHeadersMapInSequence(params.getDataViewId(),params.getGroupId(),params.getTenantId(),"source");
	    	    	log.info("Header Columns Source: "+ headerColumns);
	    			if("rules".equalsIgnoreCase(params.getGroupBy()))
	    			{
	    				log.info("Fetching source group by rules detail data...");
	    				if(keyValues.getRuleIds().size()>0)
	    				{
	        				HashMap recIds = reconciliationResultService.getRulesRecIdsForSource(params.getDataViewId(), params.getPeriodFactor(), params.getRangeFrom(), params.getRangeTo(), keyValues.getRuleIds(), params.getTenantId(), params.getGroupId(), "reconData");
	        				Map<String, List<BigInteger>> recIdsMP = new HashMap<String, List<BigInteger>>();
	        				recIdsMP.put("reconciled", (List<BigInteger>) recIds.get("reconciled"));
	        				finalList = reconciliationResultService.getReconData(recIdsMP, "reconciled", params.getTenantId(), params.getDataViewId(), limit, pageSize, headerColumns, params.getGroupId(), amtQualifier,params.getSearchWord(),columnsString,exportFile,colNameNType,params.getSortOrderBy(), columnSearchQuery,statusNReconRefQuery);
	    				}
	    				else 
	    				{
	    					List<BigInteger> ruleIds = reconciliationResultRepository.fetchRuleIdsByGroupIdAndTenantId(params.getTenantId(), params.getGroupId(), params.getDataViewId());
	    					List<Long> ruleIdsLong = new ArrayList<Long>();
	    					if(ruleIds.size()>0)
	    					{
	    						for(BigInteger id : ruleIds)
	    						{
	    							ruleIdsLong.add(id.longValue());
	    						}
	            				HashMap recIds = reconciliationResultService.getRulesRecIdsForSource(params.getDataViewId(), params.getPeriodFactor(), params.getRangeFrom(), params.getRangeTo(), ruleIdsLong, params.getTenantId(), params.getGroupId(), "reconData");
	            				Map<String, List<BigInteger>> recIdsMP = new HashMap<String, List<BigInteger>>();
	            				recIdsMP.put("reconciled", (List<BigInteger>) recIds.get("reconciled"));
	            				recIdsMP.put("totalIds", (List<BigInteger>) recIds.get("totalIds"));
	            				finalList = reconciliationResultService.getReconData(recIdsMP, "", params.getTenantId(), params.getDataViewId(), limit, pageSize, headerColumns, params.getGroupId(), amtQualifier,params.getSearchWord(),columnsString,exportFile,colNameNType,params.getSortOrderBy(), columnSearchQuery, statusNReconRefQuery);
	    					}
	    				}
	    			}
	    			else if("batch".equalsIgnoreCase(params.getGroupBy()))
	    			{
	    				List<String> batches = new ArrayList<String>();
	    				List<String> inputBatches = new ArrayList<String>();
	    				inputBatches.addAll(keyValues.getBatchNames());
	    				if(keyValues.getBatchNames().size()>0)
	    				{
	        				if(keyValues.getBatchNames().contains("Manual"))
	        				{
	        					batches = reconciliationResultRepository.fetchDistinctbatchesByGroup(params.getGroupId(), params.getTenantId());
	        					if(batches.size()>0)
	        					{
	        						for(String batch : batches)
	        						{
	        							if(batch.contains("MANUAL"))
	        							{
	        								inputBatches.add(batch);
	        							}
	        						}
	        					}
	        					inputBatches.remove("Manual");
	        				}
	        				log.info("Final Input Batches: "+inputBatches);
	        				if(inputBatches.size()>0)
	        				{
	        					HashMap recIds = reconciliationResultService.getRecIdsforBatches(params.getDataViewId(), params.getPeriodFactor(), params.getRangeFrom(), params.getRangeTo(), params.getTenantId(), params.getGroupId(), inputBatches, "source", "reconData");
	            				Map<String, List<BigInteger>> recIdsMP = new HashMap<String, List<BigInteger>>();
	            				recIdsMP.put("reconciled", (List<BigInteger>) recIds.get("reconciled"));
	            				finalList = reconciliationResultService.getReconData(recIdsMP, "reconciled", params.getTenantId(), params.getDataViewId(), limit, pageSize, headerColumns, params.getGroupId(), amtQualifier,params.getSearchWord(),columnsString,exportFile,colNameNType,params.getSortOrderBy(), columnSearchQuery, statusNReconRefQuery);
	        				}
	    				}
	    				else
	    				{
	    					List<String> batchesList = new ArrayList<String>();
	    					batchesList = reconciliationResultRepository.fetchDistinctbatchesByGroupNView(params.getGroupId(), params.getTenantId(), params.getDataViewId());
	    					HashMap recIds = reconciliationResultService.getRecIdsforBatches(params.getDataViewId(), params.getPeriodFactor(), params.getRangeFrom(), params.getRangeTo(), params.getTenantId(), params.getGroupId(), batchesList, "source", "reconData");
	        				Map<String, List<BigInteger>> recIdsMP = new HashMap<String, List<BigInteger>>();
	        				recIdsMP.put("reconciled", (List<BigInteger>) recIds.get("reconciled"));
	        				recIdsMP.put("totalIds", (List<BigInteger>) recIds.get("totalIds"));
	        				finalList = reconciliationResultService.getReconData(recIdsMP, "", params.getTenantId(), params.getDataViewId(), limit, pageSize, headerColumns, params.getGroupId(), amtQualifier,params.getSearchWord(),columnsString,exportFile,colNameNType,params.getSortOrderBy(), columnSearchQuery, statusNReconRefQuery);
	    				}
	    			}
	    			else if("columnName".equalsIgnoreCase(params.getGroupBy()))
	    			{
	    				if(columnvalues.getColumnValues().size()>0)
	    				{
	    					log.info("with column values...");
	    					Map<String, List<BigInteger>> recUnrecIds = reconciliationResultService.getRecUnRecGroupByColumnValuesForSource(params.getDataViewId(), columnvalues.getColumnId(), params.getRangeFrom(), params.getRangeTo(), columnvalues.getColumnValues(), "", params.getTenantId(), params.getGroupId(), params.getPeriodFactor(), "reconData");
	    					finalList = reconciliationResultService.getReconData(recUnrecIds, params.getStatus(), params.getTenantId(), params.getDataViewId(), limit, pageSize, headerColumns, params.getGroupId(), amtQualifier,params.getSearchWord(),columnsString,exportFile,colNameNType,params.getSortOrderBy(), columnSearchQuery, statusNReconRefQuery);
	    				}
	    				else
	    				{
	    					List<String> distColValues = reconciliationResultService.getDistinctColValues(params.getDataViewId(), params.getRangeFrom(), params.getRangeTo(), columnvalues.getColumnId(), params.getPeriodFactor());
	    					if(distColValues.size()>0)
	    					{
	        					Map<String, List<BigInteger>> recUnrecIds = reconciliationResultService.getRecUnRecGroupByColumnValuesForSource(params.getDataViewId(), columnvalues.getColumnId(), params.getRangeFrom(), params.getRangeTo(), distColValues, "", params.getTenantId(), params.getGroupId(), params.getPeriodFactor(), "reconData");
	        					finalList = reconciliationResultService.getReconData(recUnrecIds, "", params.getTenantId(), params.getDataViewId(), limit, pageSize, headerColumns, params.getGroupId(), amtQualifier,params.getSearchWord(),columnsString,exportFile,colNameNType,params.getSortOrderBy(), columnSearchQuery, statusNReconRefQuery);		
	    					}
	    				}
	    			}
	    			
	    			
	    			else if("approvalRule".equalsIgnoreCase(params.getGroupBy()))
	    			{
	    				log.info("Fetching source group by Approval rules detail data...");
	    				if(keyValues.getRuleIds().size()>0)
	    				{
	    					RuleGroup rg=ruleGroupRepository.findOne(params.getGroupId());
	    					List<BigInteger> orginalRowIds=reconciliationResultRepository.findOrginalRowIdByApprovalRuleGroupIdAndOrginalViewIdAndApprovalRuleIdInInAndStatus(params.getGroupId(), rg.getApprRuleGrpId(), params.getDataViewId(), keyValues.getRuleIds(),keyValues.getStatus());
	    					log.info("orginalRowIds of apprval Rule:"+orginalRowIds);
	    					Map<String, List<BigInteger>> recIdsMP = new HashMap<String, List<BigInteger>>();
	    					recIdsMP.put("reconciled", (List<BigInteger>) orginalRowIds);
	    					finalList = reconciliationResultService.getReconData(recIdsMP, "reconciled", params.getTenantId(), params.getDataViewId(), limit, pageSize, headerColumns, params.getGroupId(), amtQualifier,params.getSearchWord(),columnsString,exportFile,colNameNType,params.getSortOrderBy(), columnSearchQuery,statusNReconRefQuery);
	    				}


	    			}
	    			else if("approvalDate".equalsIgnoreCase(params.getGroupBy()))
	    			{
					log.info("Fetching source group by Approval approvalDate detail data...");
					if(keyValues.getDays().size()>0)
					{
						RuleGroup rg=ruleGroupRepository.findOne(params.getGroupId());
					    List<BigInteger> orginalRowIds=reconciliationResultRepository.findOrginalRowIdByApprovalRuleGroupIdAndOrginalViewIdAndFinalActionDateIn(params.getGroupId(), rg.getApprRuleGrpId(), params.getDataViewId(), keyValues.getDays());
	    				//HashMap recIds = reconciliationResultService.getRulesRecIdsForSource(params.getDataViewId(), params.getPeriodFactor(), params.getRangeFrom(), params.getRangeTo(), keyValues.getRuleIds(), params.getTenantId(), params.getGroupId());
	    				Map<String, List<BigInteger>> recIdsMP = new HashMap<String, List<BigInteger>>();
	    				recIdsMP.put("reconciled", (List<BigInteger>) orginalRowIds);
	    				finalList = reconciliationResultService.getReconData(recIdsMP, "reconciled", params.getTenantId(), params.getDataViewId(), limit, pageSize, headerColumns, params.getGroupId(), amtQualifier,params.getSearchWord(),columnsString,exportFile,colNameNType,params.getSortOrderBy(), columnSearchQuery,statusNReconRefQuery);
					}

	    		}
	    			
	    			else if("approvalStatus".equalsIgnoreCase(params.getGroupBy()))
	    			{
					log.info("Fetching source group by Approval approvalDate detail data...");
					if(keyValues.getStatus().size()>0)
					{
						RuleGroup rg=ruleGroupRepository.findOne(params.getGroupId());
						List<BigInteger> orginalRowIds=reconciliationResultRepository.findByApprovalRuleGroupIdAndOrginalViewIdAndFinalStatusIn(params.getGroupId(), rg.getApprRuleGrpId(), params.getDataViewId(), keyValues.getStatus());
						//HashMap recIds = reconciliationResultService.getRulesRecIdsForSource(params.getDataViewId(), params.getPeriodFactor(), params.getRangeFrom(), params.getRangeTo(), keyValues.getRuleIds(), params.getTenantId(), params.getGroupId());
						Map<String, List<BigInteger>> recIdsMP = new HashMap<String, List<BigInteger>>();
						recIdsMP.put("reconciled", (List<BigInteger>) orginalRowIds);
						finalList = reconciliationResultService.getReconData(recIdsMP, "reconciled", params.getTenantId(), params.getDataViewId(), limit, pageSize, headerColumns, params.getGroupId(), amtQualifier,params.getSearchWord(),columnsString,exportFile,colNameNType,params.getSortOrderBy(), columnSearchQuery,statusNReconRefQuery);
					}
		
	    		}
	    			
	    			
	    		}
	    		else if("target".equalsIgnoreCase(params.getSourceOrTarget()))
	    		{
	    			HashMap headerColumns = reconciliationResultService.getColHeadersMapInSequence(params.getDataViewId(), params.getGroupId(), params.getTenantId(),"target");
	    			if("rules".equalsIgnoreCase(params.getGroupBy()))
	    			{
	    				if(keyValues.getRuleIds().size()>0)
	    				{
	        				HashMap recIds = reconciliationResultService.getRulesRecIdsForTarget(params.getDataViewId(), params.getPeriodFactor(), params.getRangeFrom(), params.getRangeTo(), keyValues.getRuleIds(), params.getTenantId(), params.getGroupId(), "reconData");
	        				Map<String, List<BigInteger>> recIdsMP = new HashMap<String, List<BigInteger>>();
	        				recIdsMP.put("reconciled", (List<BigInteger>) recIds.get("reconciled"));
	        				finalList = reconciliationResultService.getReconDataTarget(recIdsMP, "reconciled", params.getTenantId(), params.getDataViewId(), limit, pageSize, headerColumns, params.getGroupId(), amtQualifier,params.getSearchWord(),columnsString,exportFile,colNameNType,params.getSortOrderBy(),columnSearchQuery, statusNReconRefQuery);    					
	    				}
	    				else
	    				{
	    					List<BigInteger> ruleIds = new ArrayList<BigInteger>();
	    					ruleIds = reconciliationResultRepository.fetchRuleIdsByGroupIdAndTenantIdForTarget(params.getTenantId(), params.getGroupId(), params.getDataViewId());
	    					List<Long> ruleIdsLong = new ArrayList<Long>();
	    					if(ruleIds.size()>0)
	    					{
	    						for(BigInteger id: ruleIds)
	    						{
	    							ruleIdsLong.add(id.longValue());
	    						}
	            				HashMap recIds = reconciliationResultService.getRulesRecIdsForTarget(params.getDataViewId(), params.getPeriodFactor(), params.getRangeFrom(), params.getRangeTo(), ruleIdsLong, params.getTenantId(), params.getGroupId(), "reconData");
	            				Map<String, List<BigInteger>> recIdsMP = new HashMap<String, List<BigInteger>>();
	            				recIdsMP.put("reconciled", (List<BigInteger>) recIds.get("reconciled"));
	            				recIdsMP.put("totalIds", (List<BigInteger>) recIds.get("totalIds"));
	            				finalList = reconciliationResultService.getReconDataTarget(recIdsMP, "", params.getTenantId(), params.getDataViewId(), limit, pageSize, headerColumns, params.getGroupId(), amtQualifier,params.getSearchWord(),columnsString,exportFile,colNameNType,params.getSortOrderBy(),columnSearchQuery, statusNReconRefQuery);    					
	    					}
	    				}
	    			}
	    			else if("batch".equalsIgnoreCase(params.getGroupBy()))
	    			{
	    				List<String> batches = new ArrayList<String>();
	    				List<String> inputBatches = new ArrayList<String>();
	    				inputBatches.addAll(keyValues.getBatchNames());
	    				if(keyValues.getBatchNames().size()>0)
	    				{
	        				if(keyValues.getBatchNames().contains("Manual"))
	        				{
	        					batches = reconciliationResultRepository.fetchDistinctbatchesByGroup(params.getGroupId(), params.getTenantId());
	        					if(batches.size()>0)
	        					{
	        						for(String batch : batches)
	        						{
	        							if(batch.contains("MANUAL"))
	        							{
	        								inputBatches.add(batch);
	        							}
	        						}
	        					}
	        					inputBatches.remove("Manual");
	        				}
	        				if(inputBatches.size()>0)
	        				{
	        					HashMap recIds = reconciliationResultService.getRecIdsforBatches(params.getDataViewId(), params.getPeriodFactor(), params.getRangeFrom(), params.getRangeTo(), params.getTenantId(), params.getGroupId(), inputBatches, "target", "reconData");
	            				Map<String, List<BigInteger>> recIdsMP = new HashMap<String, List<BigInteger>>();
	            				recIdsMP.put("reconciled", (List<BigInteger>) recIds.get("reconciled"));
	            				finalList = reconciliationResultService.getReconDataTarget(recIdsMP, "reconciled", params.getTenantId(), params.getDataViewId(), limit, pageSize, headerColumns, params.getGroupId(), amtQualifier,params.getSearchWord(),columnsString,exportFile,colNameNType,params.getSortOrderBy(),columnSearchQuery, statusNReconRefQuery);
	        				}
	    				}
	    				else
	    				{
	    					List<String> batchList = new ArrayList<String>();
	    					batchList = reconciliationResultRepository.fetchDistinctbatchesTarget(params.getGroupId(), params.getTenantId(), params.getDataViewId());
	    					if(batchList.size()>0)
	    					{
	           					HashMap recIds = reconciliationResultService.getRecIdsforBatches(params.getDataViewId(), params.getPeriodFactor(), params.getRangeFrom(), params.getRangeTo(), params.getTenantId(), params.getGroupId(), batchList, "target", "reconData");
	            				Map<String, List<BigInteger>> recIdsMP = new HashMap<String, List<BigInteger>>();
	            				recIdsMP.put("reconciled", (List<BigInteger>) recIds.get("reconciled"));
	            				recIdsMP.put("totalIds", (List<BigInteger>) recIds.get("totalIds"));
	            				finalList = reconciliationResultService.getReconDataTarget(recIdsMP, "", params.getTenantId(), params.getDataViewId(), limit, pageSize, headerColumns, params.getGroupId(), amtQualifier,params.getSearchWord(),columnsString,exportFile,colNameNType,params.getSortOrderBy(),columnSearchQuery, statusNReconRefQuery);
	    					}
	    				}

	    			}
	    			else if("columnName".equalsIgnoreCase(params.getGroupBy()))
	    			{
	    				if(columnvalues.getColumnValues().size()>0)
	    				{
	    					log.info("with column values...");
	    					Map<String, List<BigInteger>> recUnrecIds = reconciliationResultService.getRecUnRecGroupByColumnValuesForTarget(params.getDataViewId(), columnvalues.getColumnId(), params.getRangeFrom(), params.getRangeTo(), columnvalues.getColumnValues(), "", params.getTenantId(), params.getGroupId(), "reconData");
	    					finalList = reconciliationResultService.getReconDataTarget(recUnrecIds, params.getStatus(), params.getTenantId(), params.getDataViewId(), limit, pageSize, headerColumns, params.getGroupId(), amtQualifier, params.getSearchWord(),columnsString,exportFile,colNameNType,params.getSortOrderBy(),columnSearchQuery, statusNReconRefQuery);
	    				}
	    				else
	    				{
	    					List<String> tDistColValues = reconciliationResultService.getDistinctColValues(params.getDataViewId(), params.getRangeFrom(), params.getRangeTo(), columnvalues.getColumnId(), params.getPeriodFactor());
	    					if(tDistColValues.size()>0)
	    					{
	        					Map<String, List<BigInteger>> recUnrecIds = reconciliationResultService.getRecUnRecGroupByColumnValuesForTarget(params.getDataViewId(), columnvalues.getColumnId(), params.getRangeFrom(), params.getRangeTo(), tDistColValues, "", params.getTenantId(), params.getGroupId(), "reconData");
	        					finalList = reconciliationResultService.getReconDataTarget(recUnrecIds, "", params.getTenantId(), params.getDataViewId(), limit, pageSize, headerColumns, params.getGroupId(), amtQualifier, params.getSearchWord(),columnsString,exportFile,colNameNType,params.getSortOrderBy(),columnSearchQuery, statusNReconRefQuery);
	    					}
	    				}
	    			}
	    			else if("approvalRule".equalsIgnoreCase(params.getGroupBy()))
	    			{
	    				log.info("Fetching source group by Approval rules detail data...");
	    				if(keyValues.getRuleIds().size()>0)
	    				{
	    					RuleGroup rg=ruleGroupRepository.findOne(params.getGroupId());
	    					List<BigInteger> targetRowIds=reconciliationResultRepository.findTargetRowIdByApprovalRuleGroupIdAndTargetViewIdAndApprovalRuleIdInInAndStatus(params.getGroupId(), rg.getApprRuleGrpId(), params.getDataViewId(), keyValues.getRuleIds(),keyValues.getStatus());
	    					Map<String, List<BigInteger>> recIdsMP = new HashMap<String, List<BigInteger>>();
	    					recIdsMP.put("reconciled", (List<BigInteger>) targetRowIds);
	    					finalList = reconciliationResultService.getReconDataTarget(recIdsMP, "reconciled", params.getTenantId(), params.getDataViewId(), limit, pageSize, headerColumns, params.getGroupId(), amtQualifier,params.getSearchWord(),columnsString,exportFile,colNameNType,params.getSortOrderBy(), columnSearchQuery,statusNReconRefQuery);
	    				}


	    			}
	    			else if("approvalDate".equalsIgnoreCase(params.getGroupBy()))
	    			{
					log.info("Fetching source group by Approval approvalDate detail data...");
					if(keyValues.getDays().size()>0)
					{
						RuleGroup rg=ruleGroupRepository.findOne(params.getGroupId());
					    List<BigInteger> targetRowIds=reconciliationResultRepository.findTargetRowIdByApprovalRuleGroupIdAndTargetViewIdAndFinalActionDateIn(params.getGroupId(), rg.getApprRuleGrpId(), params.getDataViewId(), keyValues.getDays());
	    				//HashMap recIds = reconciliationResultService.getRulesRecIdsForSource(params.getDataViewId(), params.getPeriodFactor(), params.getRangeFrom(), params.getRangeTo(), keyValues.getRuleIds(), params.getTenantId(), params.getGroupId());
	    				Map<String, List<BigInteger>> recIdsMP = new HashMap<String, List<BigInteger>>();
	    				recIdsMP.put("reconciled", (List<BigInteger>) targetRowIds);
	    				finalList = reconciliationResultService.getReconDataTarget(recIdsMP, "reconciled", params.getTenantId(), params.getDataViewId(), limit, pageSize, headerColumns, params.getGroupId(), amtQualifier,params.getSearchWord(),columnsString,exportFile,colNameNType,params.getSortOrderBy(), columnSearchQuery,statusNReconRefQuery);
					}

	    		}
	    			
	    			else if("approvalStatus".equalsIgnoreCase(params.getGroupBy()))
	    			{
					log.info("Fetching source group by Approval approvalDate detail data...");
					if(keyValues.getStatus().size()>0)
					{
						RuleGroup rg=ruleGroupRepository.findOne(params.getGroupId());
						List<BigInteger> targetRowIds=reconciliationResultRepository.findByApprovalRuleGroupIdAndTargetViewIdAndFinalStatusIn(params.getGroupId(), rg.getApprRuleGrpId(), params.getDataViewId(), keyValues.getStatus());
						//HashMap recIds = reconciliationResultService.getRulesRecIdsForSource(params.getDataViewId(), params.getPeriodFactor(), params.getRangeFrom(), params.getRangeTo(), keyValues.getRuleIds(), params.getTenantId(), params.getGroupId());
						Map<String, List<BigInteger>> recIdsMP = new HashMap<String, List<BigInteger>>();
						recIdsMP.put("reconciled", (List<BigInteger>) targetRowIds);
						finalList = reconciliationResultService.getReconDataTarget(recIdsMP, "reconciled", params.getTenantId(), params.getDataViewId(), limit, pageSize, headerColumns, params.getGroupId(), amtQualifier,params.getSearchWord(),columnsString,exportFile,colNameNType,params.getSortOrderBy(), columnSearchQuery,statusNReconRefQuery);
					}
		
	    		}
	    		}
	    	}
	    	else if("unReconciled".equalsIgnoreCase(params.getStatus()))
	    	{
	    		if("days".equalsIgnoreCase(params.getGroupBy()))
	    		{   			
	    			if("source".equalsIgnoreCase(params.getSourceOrTarget()))
	    			{
	    				HashMap headerColumns = reconciliationResultService.getColHeadersMapInSequence(params.getDataViewId(),params.getGroupId(),params.getTenantId(),"source");
	    				String sDateQualifier = reconciliationResultService.getTransDateQualifier(BigInteger.valueOf(params.getDataViewId()), "TRANSDATE");
	    				log.info("Header Columns Source: "+ headerColumns);
	    				if(keyValues.getDays().size()>0)
	    				{
	    					Map<String, List<BigInteger>> recUnrecIds = reconciliationResultService.getUnRecIdsForSource(params.getTenantId(), params.getGroupId(), params.getDataViewId(), params.getRangeFrom(), params.getRangeTo(), sDateQualifier, keyValues.getDays(), params.getPeriodFactor());
	    					finalList = reconciliationResultService.getReconData(recUnrecIds, params.getStatus(), params.getTenantId(), params.getDataViewId(), limit, pageSize, headerColumns, params.getGroupId(), amtQualifier, params.getSearchWord(),columnsString,exportFile,colNameNType,params.getSortOrderBy(), columnSearchQuery, statusNReconRefQuery);
	    				}
	    				else
	    				{
	    					List<String> sDistinctTransDates = reconciliationResultService.getDistinctDates(params.getDataViewId(),params.getPeriodFactor(), params.getRangeFrom(), params.getRangeTo(), sDateQualifier);
	    					if(sDistinctTransDates.size()>0)
	    					{
	        					Map<String, List<BigInteger>> recUnrecIds = reconciliationResultService.getUnRecIdsForSource(params.getTenantId(), params.getGroupId(), params.getDataViewId(), params.getRangeFrom(), params.getRangeTo(), sDateQualifier, sDistinctTransDates, params.getPeriodFactor());
	        					finalList = reconciliationResultService.getReconData(recUnrecIds, "", params.getTenantId(), params.getDataViewId(), limit, pageSize, headerColumns, params.getGroupId(), amtQualifier, params.getSearchWord(),columnsString,exportFile,colNameNType,params.getSortOrderBy(), columnSearchQuery, statusNReconRefQuery);    						
	    					}
	    				}
	    			}
	    			else if("target".equalsIgnoreCase(params.getSourceOrTarget()))
	    			{
	       				HashMap headerColumns = reconciliationResultService.getColHeadersMapInSequence(params.getDataViewId(),params.getGroupId(),params.getTenantId(),"target");
	    		    	log.info("Header Columns Source: "+ headerColumns);
	        			String tDateQualifier = reconciliationResultService.getTransDateQualifier(BigInteger.valueOf(params.getDataViewId()), "TRANSDATE");
	    				if(keyValues.getDays().size()>0)
	    				{
	          				Map<String, List<BigInteger>> recUnrecIds = reconciliationResultService.getUnRecIdsForTarget(params.getTenantId(), params.getGroupId(), params.getDataViewId(), params.getRangeFrom(), params.getRangeTo(), tDateQualifier, keyValues.getDays(), params.getPeriodFactor());
	         				finalList = reconciliationResultService.getReconDataTarget(recUnrecIds, params.getStatus(), params.getTenantId(), params.getDataViewId(), limit, pageSize, headerColumns, params.getGroupId(), amtQualifier, params.getSearchWord(),columnsString,exportFile,colNameNType,params.getSortOrderBy(),columnSearchQuery, statusNReconRefQuery);
	    				}
	    				else
	    				{
	    					List<String> tDistinctTransDates = reconciliationResultService.getDistinctDates(params.getDataViewId(), params.getPeriodFactor(), params.getRangeFrom(), params.getRangeTo(), tDateQualifier);
	         				if(tDistinctTransDates.size()>0)
	         				{
	        					Map<String, List<BigInteger>> recUnrecIds = reconciliationResultService.getUnRecIdsForTarget(params.getTenantId(), params.getGroupId(), params.getDataViewId(), params.getRangeFrom(), params.getRangeTo(), tDateQualifier, tDistinctTransDates, params.getPeriodFactor());
	             				finalList = reconciliationResultService.getReconDataTarget(recUnrecIds, "", params.getTenantId(), params.getDataViewId(), limit, pageSize, headerColumns, params.getGroupId(), amtQualifier, params.getSearchWord(),columnsString,exportFile,colNameNType,params.getSortOrderBy(),columnSearchQuery, statusNReconRefQuery);	
	         				}
	    				}
	    			}
	    		}
	    		else if("columnName".equalsIgnoreCase(params.getGroupBy()))
	    		{
	    			if("source".equalsIgnoreCase(params.getSourceOrTarget()))
	    			{
	    				HashMap headerColumns = reconciliationResultService.getColHeadersMapInSequence(params.getDataViewId(), params.getGroupId(), params.getTenantId(),"source");
	    				if(columnvalues.getColumnValues().size()>0)
	    				{
	    					log.info("with column values...");
	    					Map<String, List<BigInteger>> recUnrecIds = reconciliationResultService.getRecUnRecGroupByColumnValuesForSource(params.getDataViewId(), columnvalues.getColumnId(), params.getRangeFrom(), params.getRangeTo(), columnvalues.getColumnValues(), "", params.getTenantId(), params.getGroupId(), params.getPeriodFactor(), "reconData");
	    					finalList = reconciliationResultService.getReconData(recUnrecIds, params.getStatus(), params.getTenantId(), params.getDataViewId(), limit, pageSize, headerColumns,  params.getGroupId(), amtQualifier,params.getSearchWord(),columnsString,exportFile,colNameNType,params.getSortOrderBy(), columnSearchQuery, statusNReconRefQuery);
	    				}
	    				else
	    				{
	    					List<String> sDistColValues = reconciliationResultService.getDistinctColValues(params.getDataViewId(), params.getRangeFrom(), params.getRangeTo(), columnvalues.getColumnId(), params.getPeriodFactor());
	    					if(sDistColValues.size()>0)
	    					{
	    	   					Map<String, List<BigInteger>> recUnrecIds = reconciliationResultService.getRecUnRecGroupByColumnValuesForSource(params.getDataViewId(), columnvalues.getColumnId(), params.getRangeFrom(), params.getRangeTo(), sDistColValues, "", params.getTenantId(), params.getGroupId(), params.getPeriodFactor(), "reconData");
	        					finalList = reconciliationResultService.getReconData(recUnrecIds, "", params.getTenantId(), params.getDataViewId(), limit, pageSize, headerColumns,  params.getGroupId(), amtQualifier,params.getSearchWord(),columnsString,exportFile,colNameNType,params.getSortOrderBy(), columnSearchQuery, statusNReconRefQuery);
	    					}
	    				}
	    			}
	    			else if("target".equalsIgnoreCase(params.getSourceOrTarget()))
	    			{
	    				HashMap headerColumns = reconciliationResultService.getColHeadersMapInSequence(params.getDataViewId(), params.getGroupId(), params.getTenantId(),"target");
	    				if(columnvalues.getColumnValues().size()>0)
	    				{
	    					log.info("with column values...");
	    					Map<String, List<BigInteger>> recUnrecIds = reconciliationResultService.getRecUnRecGroupByColumnValuesForTarget(params.getDataViewId(), columnvalues.getColumnId(), params.getRangeFrom(), params.getRangeTo(), columnvalues.getColumnValues(), "", params.getTenantId(),  params.getGroupId(), "reconData");
	    					finalList = reconciliationResultService.getReconDataTarget(recUnrecIds, params.getStatus(), params.getTenantId(), params.getDataViewId(), limit, pageSize, headerColumns,  params.getGroupId(), amtQualifier, params.getSearchWord(),columnsString,exportFile,colNameNType,params.getSortOrderBy(),columnSearchQuery, statusNReconRefQuery);
	    				}
	    				else
	    				{
	    					List<String> tDistColValues = reconciliationResultService.getDistinctColValues(params.getDataViewId(), params.getRangeFrom(), params.getRangeTo(), columnvalues.getColumnId(), params.getPeriodFactor());
	    					if(tDistColValues.size()>0)
	    					{
	        					Map<String, List<BigInteger>> recUnrecIds = reconciliationResultService.getRecUnRecGroupByColumnValuesForTarget(params.getDataViewId(), columnvalues.getColumnId(), params.getRangeFrom(), params.getRangeTo(), tDistColValues, "", params.getTenantId(),  params.getGroupId(), "reconData");
	        					finalList = reconciliationResultService.getReconDataTarget(recUnrecIds, "", params.getTenantId(), params.getDataViewId(), limit, pageSize, headerColumns,  params.getGroupId(), amtQualifier, params.getSearchWord(),columnsString,exportFile,colNameNType,params.getSortOrderBy(),columnSearchQuery, statusNReconRefQuery);
	    					}
	    				}
	    			}
	    		}
	    	}
	    	return finalList;
	    }

	    
	    
	    
	    public String jsonToCSV(List<LinkedHashMap> finalList,String newFileName) throws IOException
	    { 	LinkedHashMap keysList=finalList.get(0);
	    List<String> keyList=new ArrayList<String>();
	    Set<String> keyset=keysList.keySet();
	    log.info("keyset :"+keyset.remove("Id"));

	    String commaSeparated = keyset.stream()
	    		.collect(Collectors.joining(","));


	    HashMap pathMap=new  HashMap();

	    //String newFileName = prog.getGeneratedPath()+rg.getName().replaceAll("\\s","")+"_"+updRes+".csv";


	    try (

	    		BufferedWriter writer = Files.newBufferedWriter(Paths.get(newFileName));

	    		CSVPrinter csvPrinter = new CSVPrinter(writer, CSVFormat.DEFAULT
	    				.withHeader(commaSeparated));
	    		) {

	    	for(int j=0;j<finalList.size();j++)
	    	{
	    		List<String> valuesList=new ArrayList<String>();
	    		for(String hea:keyset)
	    		{
	    			//log.info("hea: "+hea);
	    			if(finalList.get(j).containsKey(hea)){
	    				//log.info("values.get(j).get(hea): "+values.get(j).get(hea));
	    				if(finalList.get(j).get(hea)!=null)
	    					valuesList.add(finalList.get(j).get(hea).toString());
	    				else
	    					valuesList.add("");
	    			}
	    			else{
	    				valuesList.add("");
	    			}
	    		}

	    		commaSeparated=valuesList.stream()
	    				.collect(Collectors.joining(","));

	    		csvPrinter.printRecord(commaSeparated);
	    	}
	    	csvPrinter.flush();    
	    }
		
	    return newFileName;
	    }
	    
	    public List<LinkedHashMap> getSuggestedDataGroupById(Long viewId, String sourceOrTarget, String amountQualifier, Long groupId, Long tenantId, String sortBy,
	    		Long pageIndx, Long pageSize, String groupByValues, String columnsAsString, HashMap headerColumns,
	    		String columnSearchQuery, String statusNReconRefQuery)
	    {
	    	String reconColString = columnsAsString.replaceAll("dv.", "recon.");
	    	List<LinkedHashMap> finalList = new ArrayList<LinkedHashMap>();
    		Connection conn = null;
    		Statement stmt = null;
    		Statement stmt2 = null;
    		ResultSet result = null;
    		ResultSet result2 = null;
    		LinkedHashMap info = new LinkedHashMap();
	    	LinkedHashMap recMain = new LinkedHashMap();
	    	info.put("amountQualifier", amountQualifier);
	    	try{
	    		String dbUrl=env.getProperty("spring.datasource.url");
	    		String[] parts=dbUrl.split("[\\s@&?$+-]+");
	    		String host = parts[0].split("/")[2].split(":")[0];
	    		String schemaName=parts[0].split("/")[3];
	    		String userName = env.getProperty("spring.datasource.username");
	    		String password = env.getProperty("spring.datasource.password");
	    		String jdbcDriver = env.getProperty("spring.datasource.jdbcdriver");
	    		String withLimit =  "";
	    		String withoutLimit = "";
	    		String query = "";
		    	DataViews dv = dataViewsRepository.findById(viewId.longValue());
		    	String id = "";
		    	if(dv != null)
		    	{
		    		if("source".equalsIgnoreCase(sourceOrTarget))
		    		{
		    			id = "original_row_id";
		    			query = "select recon.original_row_id, recon.recon_reference, recon.reconciliation_rule_group_id, recon.count, recon.amount_sum, v_recon.variance_amount "+reconColString
		    					+ " from (select original_row_id, GROUP_CONCAT(DISTINCT recon_reference"
		    					+ " ORDER BY recon_reference DESC SEPARATOR ',') as recon_reference, reconciliation_rule_group_id, count(*) count,  avg(dv.`"+amountQualifier+"`) amount_sum"
		    					+ " "+columnsAsString
		    					+ "	from "+schemaName+".t_reconciliation_suggestion_result recon,"
		    					+ "	"+schemaName+".`"+dv.getDataViewName().toLowerCase()+"` dv"
		    					+ "	where reconciliation_rule_group_id = "+groupId+" "
		    					+ " and original_view_id = "+viewId+""
		    					+ "	and current_record_flag is true"
		    					+ "	and recon.original_row_id = dv.scrIds"
		    					+ "	and recon_status = 'RECONCILED'"
		    					+ " and tenant_id = "+tenantId+""
		    					+ " and sign(original_row_id) = 1"
				    			+ columnSearchQuery
				    			+ statusNReconRefQuery
		    					+ "	and "+groupByValues+""	// Need to Write Code
		    					+ "	group by original_row_id, reconciliation_rule_group_id ) recon"
		    					+ " left outer join (select original_row_id, GROUP_CONCAT(DISTINCT recon_reference"
		    					+ " ORDER BY recon_reference DESC SEPARATOR ',') as recon_reference, reconciliation_rule_group_id, count(*) count, avg(dv.`"+amountQualifier+"`) variance_amount"
		    					+ "	from "+schemaName+".t_reconciliation_suggestion_result recon,"
		    					+ "	"+schemaName+".`"+dv.getDataViewName().toLowerCase()+"` dv"
		    					+ "	where reconciliation_rule_group_id = "+groupId+" "
		    					+ " and original_view_id = "+viewId+""
		    					+ "	and current_record_flag is true"
		    					+ "	and recon.original_row_id = dv.scrIds"
		    					+ "	and recon_status = 'RECONCILED'"
		    					+ " and tenant_id = "+tenantId+""
		    					+ " and sign(original_row_id) = -1"
				    			+ columnSearchQuery
				    			+ statusNReconRefQuery
		    					+ "	and "+groupByValues+""	// Need to Write Code
		    					+ "	group by original_row_id, reconciliation_rule_group_id"
		    					+ " ) v_recon on recon.recon_reference = v_recon.recon_reference order by original_row_id "+sortBy+"";
		    		}
		    		else if("target".equalsIgnoreCase(sourceOrTarget))
		    		{
		    			id = "target_row_id";
		    			query = " select recon.target_row_id,recon.recon_reference,recon.reconciliation_rule_group_id,recon.count,recon.amount_sum,v_recon.variance_amount "+reconColString
		    					+ " from (select target_row_id,GROUP_CONCAT(DISTINCT recon_reference"
		    					+ " ORDER BY recon_reference DESC SEPARATOR ',') as recon_reference, reconciliation_rule_group_id, count(*) count,  avg(dv.`"+amountQualifier+"`) amount_sum"
		    					+ " "+columnsAsString
		    					+ "	from "+schemaName+".t_reconciliation_suggestion_result recon,"
		    					+ "	"+schemaName+".`"+dv.getDataViewName().toLowerCase()+"` dv"
		    					+ "	where reconciliation_rule_group_id = "+groupId+" "
		    					+ " and target_view_id = "+viewId+""
		    					+ "	and current_record_flag is true"
		    					+ "	and recon.target_row_id = dv.scrIds"
		    					+ "	and recon_status = 'RECONCILED'"
		    					+ " and tenant_id = "+tenantId+""
		    					+ " and sign(target_row_id) = 1"
				    			+ columnSearchQuery
				    			+ statusNReconRefQuery
		    					+ "	and "+groupByValues+""	// Need to Write Code
		    					+ "	group by target_row_id, reconciliation_rule_group_id"
		    					+ " ) recon left outer join (select target_row_id, GROUP_CONCAT(DISTINCT recon_reference"
		    					+ " ORDER BY recon_reference DESC SEPARATOR ',') as recon_reference, reconciliation_rule_group_id, count(*) count, avg(dv.`"+amountQualifier+"`) variance_amount"
		    					+ "	from "+schemaName+".t_reconciliation_suggestion_result recon,"
		    					+ "	"+schemaName+".`"+dv.getDataViewName().toLowerCase()+"` dv"
		    					+ "	where reconciliation_rule_group_id = "+groupId+" "
		    					+ " and target_view_id = "+viewId+""
		    					+ "	and current_record_flag is true"
		    					+ "	and recon.target_row_id = dv.scrIds"
		    					+ "	and recon_status = 'RECONCILED'"
		    					+ " and tenant_id = "+tenantId+""
		    					+ " and sign(target_row_id) = -1"
				    			+ columnSearchQuery
				    			+ statusNReconRefQuery
		    					+ "	and "+groupByValues+""	// Need to Write Code
		    					+ "	group by target_row_id, reconciliation_rule_group_id"
		    					+ " ) v_recon on recon.recon_reference = v_recon.recon_reference order by target_row_id "+sortBy+"";
		    		}
			    	
			    	withLimit = query +" limit "+pageIndx+", "+pageSize+"";
			    	withoutLimit = query;
			    	log.info(sourceOrTarget.toUpperCase()+" query to fetching original row id grouping info: "+withLimit);
		    		Class.forName(jdbcDriver);
		     	    conn = DriverManager.getConnection(dbUrl, userName, password);
		     	    stmt = conn.createStatement();
		     	    result=stmt.executeQuery(withLimit);
		     	    
			    	stmt2 = conn.createStatement();
			    	result2 = stmt2.executeQuery(withoutLimit);
			    	int totalCount = 0;
			    	while(result2.next())
			    	{
			    		totalCount = totalCount+1;
			    	}
			    	info.put("totalCount", totalCount);
			        while(result.next()){
			        	LinkedHashMap reconRecord = new LinkedHashMap();
			        	Iterator it = headerColumns.entrySet().iterator();
			        	while(it.hasNext())	// header columns
 	 	    	    	{
 	 	    	    		Map.Entry pair = (Map.Entry)it.next();
 	 	    	    		reconRecord.put(pair.getValue().toString(), result.getString(pair.getKey().toString()));	    		
 	 	    	    	}
			        	reconRecord.put("Id", result.getString(id));
			        	reconRecord.put("reconReference", result.getString("recon_reference"));
			        	reconRecord.put("count", result.getString("count"));
			        	reconRecord.put("amount", result.getString("amount_sum"));
			        	reconRecord.put("varianceAmount", result.getString("variance_amount"));
			        	finalList.add(reconRecord);			        	
			       	}
		    	}
	    	}
	    	catch(Exception e)
	    	{
	    		log.info("Exception while fetching recon grouping by recon reference info: "+e);
	    	}
	    	finally
	    	{
	    		try{
					if(result != null)
						result.close();
					if(result2 != null)
						result2.close();
					if(stmt != null)
						stmt.close();
					if(stmt2 != null)
						stmt2.close();
					if(conn != null)
						conn.close();	    			
	    		}
	    		catch(Exception e)
	    		{
	    			log.info("Exception while closing jdbc statements.(Grouping ReconRefId Info)"+e);
	    		}
	    	}
	    	log.info("Service for fetching reconciled transaction with group by recon reference id end....");
	    	recMain.put("info", info);
	    	finalList.add(recMain);
	    	return finalList;
	    }
	    
	    public List<LinkedHashMap> getGroupByReconRefDetailInfo(Long tenantId, Long groupId, Long viewId,String groupByValues,
	    		Long pageIndx, Long pageSize, String rangeFrom, String rangeTo, String periodFactor, String amountQualifier, 
	    		String sourceOrTarget, String typeOfReconData, String sortBy, String columnSearchQuery, String statusNReconRefQuery) throws SQLException, ClassNotFoundException
	    {
	    	log.info("Service for fetching reconciled transaction with group by recon reference id start....");
	    	List<LinkedHashMap> finalList = new ArrayList<LinkedHashMap>();
	    	LinkedHashMap info = new LinkedHashMap();
	    	LinkedHashMap recMain = new LinkedHashMap();
	    	info.put("amountQualifier", amountQualifier);
    		Connection conn = null;
    		Statement stmt = null;
    		Statement stmt2 = null;
    		ResultSet result = null;
    		ResultSet result2 = null;
    		String reconResultTable = "";
    		if("suggestion".equalsIgnoreCase(typeOfReconData))
    		{
    			reconResultTable = "t_reconciliation_suggestion_result";
    		}
    		else 
    		{
    			reconResultTable = "t_reconciliation_result";    			
    		}
	    	try{
	    		String dbUrl=env.getProperty("spring.datasource.url");
	    		String[] parts=dbUrl.split("[\\s@&?$+-]+");
	    		String host = parts[0].split("/")[2].split(":")[0];
	    		String schemaName=parts[0].split("/")[3];
	    		String userName = env.getProperty("spring.datasource.username");
	    		String password = env.getProperty("spring.datasource.password");
	    		String jdbcDriver = env.getProperty("spring.datasource.jdbcdriver");
	    		String withLimit =  "";
	    		String withoutLimit = "";
		    	DataViews dv = dataViewsRepository.findById(viewId.longValue());
		    	if(dv != null)
		    	{
		    		String query = "";
		    		if("source".equalsIgnoreCase(sourceOrTarget))
		    		{
				    	query = "select recon.recon_reference,recon.reconciliation_rule_id,recon.count,recon.amount_sum,v_recon.variance_amount from "
				    			+ " (select recon_reference, reconciliation_rule_id, count(*) count,  sum(dv.`"+amountQualifier+"`)  amount_sum"
				    			+ "	from "+schemaName+"."+reconResultTable+" recon,"
				    			+ "	"+schemaName+".`"+dv.getDataViewName().toLowerCase()+"` dv"
				    			+ "	where reconciliation_rule_group_id = "+ groupId +" "
				    			+ " and Date(dv.`"+periodFactor+"`) between '"+rangeFrom+"' and '"+rangeTo+"'"
				    			+ "	and original_view_id = "+viewId+""
				    			+ "	and current_record_flag is true"
				    			+ "	and recon.original_row_id = dv.scrIds"
				    			+ "	and recon_status = 'RECONCILED'"
				    			+ " and tenant_id = "+tenantId+""
				    			+ " and sign(original_row_id) = 1"
				    			+ "	and "+groupByValues+""
				    			+ 	columnSearchQuery
				    			+ 	statusNReconRefQuery
				    			+ "	group by recon_reference, reconciliation_rule_id"
				    			+ " ) recon"
				    			+ " left outer join (select recon_reference, reconciliation_rule_id, count(*) count,  sum(dv.`"+amountQualifier+"`)  variance_amount"
				    			+ "	from "+schemaName+"."+reconResultTable+" recon,"
				    			+ "	"+schemaName+".`"+dv.getDataViewName().toLowerCase()+"` dv"
				    			+ "	where reconciliation_rule_group_id = "+groupId+" "
				    			+ " and Date(dv.`"+periodFactor+"`) between '"+rangeFrom+"' and '"+rangeTo+"'"
				    			+ "	and original_view_id = "+viewId+""
				    			+ "	and current_record_flag is true"
				    			+ "	and recon.original_row_id = dv.scrIds"
				    			+ "	and recon_status = 'RECONCILED'"
				    			+ " and tenant_id = "+tenantId+""
				    			+ " and sign(original_row_id) = -1"
				    			+ "	and "+groupByValues+""
				    			+ columnSearchQuery
				    			+ statusNReconRefQuery
				    			+ "	group by recon_reference, reconciliation_rule_id"
				    			+ " ) v_recon on recon.recon_reference = v_recon.recon_reference order by recon.recon_reference "+sortBy+" ";
		    		}
		    		else if("target".equalsIgnoreCase(sourceOrTarget))
		    		{
				    	query = "select recon.recon_reference,recon.reconciliation_rule_id,recon.count,recon.amount_sum,v_recon.variance_amount"
				    			+ " from "
				    			+ " (select recon_reference, reconciliation_rule_id, count(*) count,  sum(dv.`"+amountQualifier+"`) amount_sum"
				    			+ "	from "+schemaName+"."+reconResultTable+" recon,"
				    			+ "	"+schemaName+".`"+dv.getDataViewName().toLowerCase()+"` dv"
				    			+ "	where reconciliation_rule_group_id = "+groupId+" "
				    			+ " and Date(dv.`"+periodFactor+"`) between '"+rangeFrom+"' and '"+rangeTo+"'"
				    			+ "	and target_view_id = "+viewId+""
				    			+ "	and current_record_flag is true"
				    			+ "	and recon.target_row_id = dv.scrIds"
				    			+ "	and recon_status = 'RECONCILED'"
				    			+ " and tenant_id = "+tenantId+""
				    			+ " and sign(target_row_id) = 1"
				    			+ "	and "+groupByValues+""
				    			+ columnSearchQuery
				    			+ statusNReconRefQuery
				    			+ "	group by recon_reference, reconciliation_rule_id"
				    			+ " ) recon"
				    			+ " left outer join (select recon_reference, reconciliation_rule_id, count(*) count,  sum(dv.`"+amountQualifier+"`) variance_amount"
				    			+ "	from "+schemaName+"."+reconResultTable+" recon,"
				    			+ "	"+schemaName+".`"+dv.getDataViewName().toLowerCase()+"` dv"
				    			+ "	where reconciliation_rule_group_id = "+groupId+" "
				    			+ " and Date(dv.`"+periodFactor+"`) between '"+rangeFrom+"' and '"+rangeTo+"'"
				    			+ "	and target_view_id = "+viewId+""
				    			+ "	and current_record_flag is true"
				    			+ "	and recon.target_row_id = dv.scrIds"
				    			+ "	and recon_status = 'RECONCILED'"
				    			+ " and tenant_id = "+tenantId+""
				    			+ " and sign(target_row_id) = -1"
				    			+ columnSearchQuery
				    			+ statusNReconRefQuery
				    			+ "	and "+groupByValues+""
				    			+ "	group by recon_reference, reconciliation_rule_id"
				    			+ " ) v_recon on recon.recon_reference = v_recon.recon_reference order by recon.recon_reference "+sortBy+" ";
		    		}
			    	
			    	withLimit = query +" limit "+pageIndx+", "+pageSize+"";
			    	withoutLimit = query;
			    	log.info(sourceOrTarget.toUpperCase()+" query to fetching recon ref id grouping info: "+withLimit);
		    		Class.forName(jdbcDriver);
		     	    conn = DriverManager.getConnection(dbUrl, userName, password);
		     	    stmt = conn.createStatement();
		     	    result=stmt.executeQuery(withLimit);
		     	    
			    	stmt2 = conn.createStatement();
			    	result2 = stmt2.executeQuery(withoutLimit);
			    	int totalCount = 0;
			    	while(result2.next())
			    	{
			    		totalCount = totalCount+1;
			    	}
			    	info.put("totalCount", totalCount);
			    	
			    	if("source".equalsIgnoreCase(sourceOrTarget))
			    	{
			    		HashMap headerColumns = reconciliationResultService.getColHeadersMapInSequence(viewId, groupId, tenantId,"source");
			        	while(result.next()){
			        		LinkedHashMap reconRecord = new LinkedHashMap();
			        		// Need to add data
			        		reconRecord.put("reconReference", result.getString(1).toString());
			        		reconRecord.put("ruleId", result.getString(2));
			        		reconRecord.put("count", result.getString(3));
			        		reconRecord.put("amount", result.getString(4));
			        		reconRecord.put("varianceAmount", result.getString(5));
			        		List<String> recRefs = new ArrayList<String>();
			        		recRefs.add(result.getString(1).toString());
			        		List<BigInteger> scrIds = new ArrayList<BigInteger>();
/*			        		if("suggestion".equalsIgnoreCase(typeOfReconData))
			        		{
			        			scrIds = reconciliationDuplicateResultRepository.fetchByReconSourceRefIdsAndTenantId(recRefs, viewId);
			        		}
			        		else
			        		{*/
			        			scrIds = reconciliationResultRepository.fetchByReconSourceRefIdsAndTenantId(recRefs, viewId);
			        		/*}*/
			        		
			        		List<LinkedHashMap> childData = fetchDataByViewIdInSequence(viewId, scrIds, null, null, headerColumns, sourceOrTarget, tenantId, groupId, "", "Yes", "", "", "", typeOfReconData);
			        		reconRecord.put("children", childData);
			        		finalList.add(reconRecord);
			        	}
			    	}
			    	else if("target".equalsIgnoreCase(sourceOrTarget))
			    	{
			    		HashMap headerColumns = reconciliationResultService.getColHeadersMapInSequence(viewId, groupId, tenantId,"target");
			        	while(result.next()){
			        		LinkedHashMap reconRecord = new LinkedHashMap();
			        		// Need to add data
			        		reconRecord.put("reconReference", result.getString(1).toString());
			        		reconRecord.put("ruleId", result.getString(2));
			        		reconRecord.put("count", result.getString(3));
			        		reconRecord.put("amount", result.getString(4));
			        		reconRecord.put("varianceAmount", result.getString(5));
			        		List<String> recRefs = new ArrayList<String>();
			        		recRefs.add(result.getString(1).toString());
			        		log.info("ReconReference: "+recRefs);
			        		List<BigInteger> scrIds = new ArrayList<BigInteger>();
			        	/*	if("suggestion".equalsIgnoreCase(typeOfReconData))
			        		{
			        			scrIds = reconciliationDuplicateResultRepository.fetchByTargetReconRefIdsAndTenantId(recRefs, viewId);
			        		}
			        		else
			        		{*/
			        			scrIds = reconciliationResultRepository.fetchByTargetReconRefIdsAndTenantId(recRefs, viewId);
			        		/*}*/
			        		
			        		List<LinkedHashMap> childData = fetchDataByViewIdInSequence(viewId, scrIds, null, null, headerColumns, sourceOrTarget, tenantId, groupId, "", "Yes", "", "", "", typeOfReconData);
			        		reconRecord.put("children", childData);
			        		finalList.add(reconRecord);
			        	}
			    	}
		    	}
		    	else
		    	{
		    		log.info("View Doesn't exist for the view id: "+viewId);
		    	}
		    }
	    	catch(Exception e)
	    	{
	    		log.info("Exception while fetching recon grouping by recon reference info: "+e);
	    	}
	    	finally
	    	{
	    		try{
					if(result != null)
						result.close();
					if(result2 != null)
						result2.close();
					if(stmt != null)
						stmt.close();
					if(stmt2 != null)
						stmt2.close();
					if(conn != null)
						conn.close();	    			
	    		}
	    		catch(Exception e)
	    		{
	    			log.info("Exception while closing jdbc statements.(Grouping ReconRefId Info)"+e);
	    		}
	    	}
	    	log.info("Service for fetching reconciled transaction with group by recon reference id end....");
	    	recMain.put("info", info);
	    	finalList.add(recMain);
	    	return finalList;
	    }
	    
	    public String getStringWithNumbers(List<Long> values)
	    {
	    	String finalString = "";
	    	for(int i=0; i<values.size(); i++)
	    	{
	    		if(i == values.size()-1)
	    		{
	    			finalString = finalString + values.get(i);
	    		}
	    		else
	    		{
	    			finalString = finalString + values.get(i)+", ";
	    		}
	    	}
	    	return finalString;
	    }
	    public String getStringWithStrings(List<String> values)
	    {
	    	String finalString = "";
	    	for(int i=0; i<values.size(); i++)
	    	{
	    		if(i == values.size()-1)
	    		{
	    			finalString = finalString + "'"+values.get(i)+"'";
	    		}
	    		else
	    		{
	    			finalString = finalString+ "'" +values.get(i)+"', ";	    			
	    		}	    		
	    	}
	    	return finalString;
	    }
	    
	    public List<BigInteger> getScrIdsByReconReference(String sourceOrTarget, Long viewId, String recRefsAsString, Long tenantId, Long groupId, String typeOfReconData, String varianceType)
	    {
	    	List<BigInteger> scrIds = new ArrayList<BigInteger>();

	    	String dbUrl=env.getProperty("spring.datasource.url");
    		String[] parts=dbUrl.split("[\\s@&?$+-]+");
    		String host = parts[0].split("/")[2].split(":")[0];
    		String schemaName=parts[0].split("/")[3];
    		String userName = env.getProperty("spring.datasource.username");
    		String password = env.getProperty("spring.datasource.password");
    		String jdbcDriver = env.getProperty("spring.datasource.jdbcdriver");
    		String varianceCondition = "";
    		Connection conn = null;
    		Statement stmt = null;
    		ResultSet result = null;
    		String reconResultTable = "";
    		
    		String srcVarType = "";
    		String trgVarType = "";
    		
    		if("variance".equalsIgnoreCase(varianceType))
    		{
    			srcVarType = " sign(original_row_id) = -1";
    			trgVarType = " sign(target_row_id) = -1";
    			varianceCondition = " dv.adjustmentType = 'VARIANCE' ";
    		}
    		else
    		{
    			srcVarType = " sign(original_row_id) = 1";
    			trgVarType = " sign(target_row_id) = 1"; 	
    			varianceCondition = " 1=1 "; 
    		}
    		
    		if("suggestion".equalsIgnoreCase(typeOfReconData))
    		{
    			reconResultTable = "t_reconciliation_suggestion_result";
    		}
    		else 
    		{
    			reconResultTable = "t_reconciliation_result";    			
    		}    	
    		try
    		{
    	    	String query = "";
    	    	DataViews dv = dataViewsRepository.findById(viewId);
    	    	if(dv != null)
    	    	{
    		    	if("source".equalsIgnoreCase(sourceOrTarget))
    		    	{
    		    		query = "select original_row_id from "+schemaName+"."+reconResultTable+" rs,"
    		    				+ "	"+schemaName+".`"+dv.getDataViewName().toLowerCase()+"` dv"
    		    				+ " where recon_reference in("+recRefsAsString+") and original_view_id = "+viewId+" and target_view_id is null and "+srcVarType+""
    		    				+ "	and "+varianceCondition
    		    				+ " and tenant_id = "+tenantId+""
    		    				+ " and reconciliation_rule_group_id = "+groupId+""
    		    				+ " group by original_row_id";	    	
    		    	}
    		    	else if("target".equalsIgnoreCase(sourceOrTarget))
    		    	{
    		    		query = "select target_row_id from "+schemaName+"."+reconResultTable+" rs,"
    		    				+ "	"+schemaName+".`"+dv.getDataViewName().toLowerCase()+"` dv"
    		    				+ " where recon_reference in("+recRefsAsString+") and target_view_id = "+viewId+" and original_view_id is null and "+trgVarType+""
    		    				+ "	and "+varianceCondition
    		    				+ " and tenant_id = "+tenantId+""
    		    				+ " and reconciliation_rule_group_id = "+groupId+""
    		    				+ " group by target_row_id";
    		    	}
    		    	log.info("Query to fetch variance/non-variance ids based on recon reference: "+query);
    	    		Class.forName(jdbcDriver);
    	     	    conn = DriverManager.getConnection(dbUrl, userName, password);
    	     	    stmt = conn.createStatement();
    	     	    result=stmt.executeQuery(query);
    	     	    
    	     	   while(result.next()){
    	     		   scrIds.add(new BigInteger(result.getString(1).toString()));
    	     	   }
    	    	}
    		}
    		catch(Exception e)
    		{
    			log.info("Exception while fetching row ids: "+e);
    		}
    		finally
    		{
	    		try{
					if(result != null)
						result.close();
					if(stmt != null)
						stmt.close();
					if(conn != null)
						conn.close();	    			
	    		}
	    		catch(Exception e)
	    		{
	    			log.info("Exception while closing jdbc statements.(Grouping ReconRefId Info)"+e);
	    		}
	    	}
	    	return scrIds;
	    }

}

	    